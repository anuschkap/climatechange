<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Anuschka Peelen" />

<meta name="date" content="2023-09-05" />

<title>Extract coefficients of gamlss regressions shorter time spans</title>

<script src="site_libs/header-attrs-2.11/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="tweaks.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li>
  <a href="blog.html">Blog</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Scripts datapreparation
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="dataprep_EB.html">Data preparation Eurobarometer</a>
    </li>
    <li>
      <a href="dataprep_EVS_ESS_ISSP.html">Data preparation EVS, ESS, ISSP</a>
    </li>
    <li>
      <a href="dataprep_I-O.html">Data preparation I&amp;O Research</a>
    </li>
    <li>
      <a href="weights.html">Weighing data</a>
    </li>
    <li>
      <a href="dataprep_polcat.html">Left right placement</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Scripts descriptives and analysis
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="descriptives.html">Descriptives</a>
    </li>
    <li>
      <a href="single_regression_gamlss_weigh_new.html">Gamlss regressions weighted</a>
    </li>
    <li>
      <a href="single_regression_gw_py_new.html">Gamlss regression shorter time spans</a>
    </li>
    <li>
      <a href="regression_to_meta_analysis_weight_gamlss_new.html">Extract coefficients gamlss regressions</a>
    </li>
    <li>
      <a href="regression_to_meta_analysis_wg_waves_new.html">Extract coefficients shorter time spans</a>
    </li>
    <li>
      <a href="regression_to_indep_var_analysis_weight_gamlss_new.html">Extract coefficients independent var model</a>
    </li>
    <li>
      <a href="regression_to_interact_analysis_weight_gamlss_new.html">Extract coefficients interaction model</a>
    </li>
    <li>
      <a href="meta_analysis_gamlss_weigh.html">Meta-analysis weighted gamlss</a>
    </li>
    <li>
      <a href="meta_analysis_indep_var.html">Meta-analysis independent variables</a>
    </li>
    <li>
      <a href="meta_analysis_gw_waves.html">Meta-analysis shorter time spans</a>
    </li>
    <li>
      <a></a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/apeelen/climatechange">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Extract coefficients of gamlss regressions
shorter time spans</h1>
<h4 class="author">Anuschka Peelen</h4>
<h4 class="date">2023-09-05</h4>

</div>


<p>In this script I extract the coefficients for the time effects and
intercepts and put them in a dataset together, to use them as input for
the meta-regression. This script uses the gamlss regressions with the
time effects over shorter time spans.</p>
<pre class="r"><code>rm(list=ls())
library(tidyverse)
library(dplyr)
library(gamlss)
library(here)
here()
here::i_am(&quot;scripts/analysis/regression_to_meta_analysis_wg_waves_new.Rmd&quot;)</code></pre>
<div id="evs" class="section level2 unnumbered">
<h2 class="unnumbered">EVS</h2>
<pre class="r"><code># Now the same for the EVS
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;evs_list_empty1.RData&quot;))

# Store the results in a new dataframe
evs_empty_df &lt;- data.frame(dep_var = character())

# Loop over the list for all the dep vars
for (i in seq_along(evs_list_empty)) {

  # Extract the name of the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(evs_list_empty[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(evs_list_empty[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  evs_empty_df &lt;- rbind(evs_empty_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
}

# And the predictor model
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;evs_list_preds1_new.RData&quot;))

# Store the results in a new dataframe
evs_preds_df &lt;- data.frame(dep_var = character())

# Loop over the list of models
for (i in seq_along(evs_list_preds)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(evs_list_preds[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(evs_list_preds[[i]])
  
  # Extract the intercept and standard deviation for mu and sigma
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results 
  evs_preds_df &lt;- rbind(evs_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
}

# And lastly the interaction model
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;evs_list_interactions1_new.RData&quot;))

# Store the results in a new dataframe
evs_interactions_df &lt;- data.frame(dep_var = character())

# Loop over the number of dep vars in the list
for (i in seq_along(evs_list_interactions)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(evs_list_interactions[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(evs_list_interactions[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  evs_interactions_df &lt;- rbind(evs_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
}

# Merge the results, and add some variables with extra information 
evs_results_df &lt;- left_join(evs_empty_df, evs_preds_df)
evs_results_df &lt;- left_join(evs_results_df, evs_interactions_df)
evs_results_df$first_year &lt;- 1990 
evs_results_df$mean_year &lt;- 1995
evs_results_df$waveset &lt;- 1
evs_results_df$data &lt;- &quot;EVS&quot;

save(evs_results_df, file=&quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/evs_results_df1_new.RData&quot;)</code></pre>
<pre class="r"><code># And the second set
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;evs_list_empty2.RData&quot;))

# Store the results in a new dataframe
evs_empty_df &lt;- data.frame(dep_var = character())

# Loop over the list for all the dep vars
for (i in seq_along(evs_list_empty)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(evs_list_empty[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(evs_list_empty[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  evs_empty_df &lt;- rbind(evs_empty_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
}

load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;evs_list_preds2_new.RData&quot;))

# Store the results in a new dataframe
evs_preds_df &lt;- data.frame(dep_var = character())

# Loop over the list of models
for (i in seq_along(evs_list_preds)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(evs_list_preds[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(evs_list_preds[[i]])
  
  # Extract the intercept and standard deviation for mu and sigma
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results 
  evs_preds_df &lt;- rbind(evs_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
}

# And lastly the interaction model
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;evs_list_interactions2_new.RData&quot;))

# Store the results in a new dataframe
evs_interactions_df &lt;- data.frame(dep_var = character())

# Loop over the number of dep vars in the list
for (i in seq_along(evs_list_interactions)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(evs_list_interactions[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(evs_list_interactions[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  evs_interactions_df &lt;- rbind(evs_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
}

# Merge the results
evs_results_df &lt;- left_join(evs_empty_df, evs_preds_df)
evs_results_df &lt;- left_join(evs_results_df, evs_interactions_df)
evs_results_df$first_year &lt;- 1999
evs_results_df$mean_year &lt;- 2004
evs_results_df$waveset &lt;- 2
evs_results_df$data &lt;- &quot;EVS&quot;

save(evs_results_df, file=&quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/evs_results_df2_new.RData&quot;)</code></pre>
</div>
<div id="io-research" class="section level2 unnumbered">
<h2 class="unnumbered">I&amp;O Research</h2>
<pre class="r"><code>rm(list=ls())
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;io_list_empty1.RData&quot;))

# Store the results in a new dataframe
io_empty_df &lt;- data.frame(dep_var = character())

for (i in seq_along(io_list_empty)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(io_list_empty[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(io_list_empty[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  io_empty_df &lt;- rbind(io_empty_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
}

# Predictor model
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;io_list_preds1_new.RData&quot;))

# Store the results in a new dataframe
io_preds_df &lt;- data.frame(dep_var = character())

# Loop over the list 
for (i in seq_along(io_list_preds)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(io_list_preds[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(io_list_preds[[i]])
  
  # Extract info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results in a dataframe
  io_preds_df &lt;- rbind(io_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
}

# Interaction model
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;io_list_interactions1_new.RData&quot;))

# Store the results in a new dataframe
io_interactions_df &lt;- data.frame(dep_var = character())

# Loop over the number of dep vars in the list
for (i in seq_along(io_list_interactions)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(io_list_interactions[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(io_list_interactions[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  io_interactions_df &lt;- rbind(io_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
}

# Merge the results
io_results_df &lt;- left_join(io_empty_df, io_preds_df)
io_results_df &lt;- left_join(io_results_df, io_interactions_df)
io_results_df$first_year &lt;- 2019
io_results_df$mean_year &lt;- 2020
io_results_df$waveset &lt;- 1
io_results_df$data &lt;- &quot;IO&quot;

save(io_results_df, file=&quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/io_results_df1_new.RData&quot;)</code></pre>
<pre class="r"><code># Second set
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;io_list_empty2.RData&quot;))

# Store the results in a new dataframe
io_empty_df &lt;- data.frame(dep_var = character())

for (i in seq_along(io_list_empty)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(io_list_empty[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(io_list_empty[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  io_empty_df &lt;- rbind(io_empty_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
}

# Predictor model
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;io_list_preds2_new.RData&quot;))

# Store the results in a new dataframe
io_preds_df &lt;- data.frame(dep_var = character())

# Loop over the list 
for (i in seq_along(io_list_preds)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(io_list_preds[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(io_list_preds[[i]])
  
  # Extract info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results in a dataframe
  io_preds_df &lt;- rbind(io_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
}

# Interaction model
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;io_list_interactions2_new.RData&quot;))

# Store the results in a new dataframe
io_interactions_df &lt;- data.frame(dep_var = character())

# Loop over the number of dep vars in the list
for (i in seq_along(io_list_interactions)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(io_list_interactions[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(io_list_interactions[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  io_interactions_df &lt;- rbind(io_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
}

# Merge the results
io_results_df &lt;- left_join(io_empty_df, io_preds_df)
io_results_df &lt;- left_join(io_results_df, io_interactions_df)
io_results_df$first_year &lt;- 2020
io_results_df$mean_year &lt;- 2021
io_results_df$waveset &lt;- 2
io_results_df$data &lt;- &quot;IO&quot;

save(io_results_df, file=&quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/io_results_df2_new.RData&quot;)</code></pre>
</div>
<div id="issp" class="section level2 unnumbered">
<h2 class="unnumbered">ISSP</h2>
<pre class="r"><code># Now for ISSP, and then only for the first part bc the second part already consists of 2 waves
rm(list=ls())
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;issp_list_empty1.RData&quot;))

# Store the results in a new dataframe
issp_empty_df &lt;- data.frame(dep_var = character())

# Loop over the list for all the dep vars
for (i in seq_along(issp_list_empty)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(issp_list_empty[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(issp_list_empty[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  issp_empty_df &lt;- rbind(issp_empty_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
}

# Predictor model 
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;issp_list_preds1_new.RData&quot;))

# Store the results in a new dataframe
issp_preds_df &lt;- data.frame(dep_var = character())

# Loop over the list 
for (i in seq_along(issp_list_preds)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(issp_list_preds[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(issp_list_preds[[i]])
  
  # Extract info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results in a dataframe
  issp_preds_df &lt;- rbind(issp_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
}

# Interaction model
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;issp_list_interactions1_new.RData&quot;))

# Store the results in a new dataframe
issp_interactions_df &lt;- data.frame(dep_var = character())

# Loop over the number of dep vars in the list
for (i in seq_along(issp_list_interactions)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(issp_list_interactions[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(issp_list_interactions[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  issp_interactions_df &lt;- rbind(issp_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
}

# Merge the results
issp_results_df &lt;- left_join(issp_empty_df, issp_preds_df)
issp_results_df &lt;- left_join(issp_results_df, issp_interactions_df)
issp_results_df$first_year &lt;- 1993
issp_results_df$mean_year &lt;- 1997
issp_results_df$waveset &lt;- 1
issp_results_df$data &lt;- &quot;ISSP&quot;

save(issp_results_df, file=&quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/issp_results_df1_new.RData&quot;)</code></pre>
<pre class="r"><code># And the second set
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;issp_list_empty2.RData&quot;))

# Store the results in a new dataframe
issp_empty_df &lt;- data.frame(dep_var = character())

# Loop over the list for all the dep vars
for (i in seq_along(issp_list_empty)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(issp_list_empty[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(issp_list_empty[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  issp_empty_df &lt;- rbind(issp_empty_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
}

#Predictor model
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;issp_list_preds2_new.RData&quot;))

# Store the results in a new dataframe
issp_preds_df &lt;- data.frame(dep_var = character())

# Loop over the list 
for (i in seq_along(issp_list_preds)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(issp_list_preds[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(issp_list_preds[[i]])
  
  # Extract info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results in a dataframe
  issp_preds_df &lt;- rbind(issp_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
}

# Interaction model
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;issp_list_interactions2_new.RData&quot;))

# Store the results in a new dataframe
issp_interactions_df &lt;- data.frame(dep_var = character())

# Loop over the number of dep vars in the list
for (i in seq_along(issp_list_interactions)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(issp_list_interactions[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(issp_list_interactions[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  issp_interactions_df &lt;- rbind(issp_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
}

# Merge the results
issp_results_df &lt;- left_join(issp_empty_df, issp_preds_df)
issp_results_df &lt;- left_join(issp_results_df, issp_interactions_df)
issp_results_df$first_year &lt;- 2000
issp_results_df$mean_year &lt;- 2005
issp_results_df$waveset &lt;- 2
issp_results_df$data &lt;- &quot;ISSP&quot;

save(issp_results_df, file=&quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/issp_results_df2_new.RData&quot;)</code></pre>
</div>
<div id="eb" class="section level2 unnumbered">
<h2 class="unnumbered">EB</h2>
<pre class="r"><code># For all the eurobarometer waves, exactly the same needs to be done each time. Therefore I want to loop over these different lists. 

# First load all the eurobarometer lists with empty models in my environment
rm(list=ls())
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_list_empty_1986_1.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_2007_1.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_2009_1.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_2011_w.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_buyprod1.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_cchange2_1.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_doprot1.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_eff_daily1.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_pers_imp1.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_prsaction1.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_list_empty_quallife1.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_doprot_city_w.RData&quot;))

# Store the results in a new dataframe
eb_results_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the list for all the dep vars
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  eb_results_df &lt;- rbind(eb_results_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
    }
  } 
} 

# It produces an error, but actually everything has worked as i wish
eb_results_empty_df &lt;- eb_results_df
eb_results_empty_df$waveset &lt;- 1

# Save it
save(eb_results_empty_df, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/eb_results_empty_df1_new.RData&quot; )</code></pre>
<pre class="r"><code># Second set
# First load all the eurobarometer lists with empty models in my environment
rm(list=ls())
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_list_empty_1986_2.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_2007_2.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_2009_2.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_buyprod2.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_cchange2_2.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_doprot2.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_eff_daily2.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_pers_imp2.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_prsaction2.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_list_empty_quallife2.RData&quot;))


# Store the results in a new dataframe
eb_results_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the list for all the dep vars
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  eb_results_df &lt;- rbind(eb_results_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
    }
  } 
} 

# It produces an error, but actually everything has worked 
eb_results_empty_df &lt;- eb_results_df
eb_results_empty_df$waveset &lt;- 2

save(eb_results_empty_df, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/eb_results_empty_df2_new.RData&quot; )</code></pre>
<pre class="r"><code># Some of them have a third set
rm(list=ls())
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_2007_3.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_2009_3.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_cchange2_3.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_eff_daily3.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_prsaction3.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_list_empty_quallife3.RData&quot;))

# Store the results in a new dataframe
eb_results_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the list for all the dep vars
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  eb_results_df &lt;- rbind(eb_results_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
    }
  } 
} 

# It produces an error, but actually everything has worked 
eb_results_empty_df &lt;- eb_results_df
eb_results_empty_df$waveset &lt;- 3

save(eb_results_empty_df, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/eb_results_empty_df3_new.RData&quot; )</code></pre>
<pre class="r"><code># Some even a fourth time
rm(list=ls())
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_2009_4.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_cchange2_4.RData&quot;))

# Store the results in a new dataframe
eb_results_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the list for all the dep vars
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  eb_results_df &lt;- rbind(eb_results_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
    }
  } 
} 

# It produces an error, but actually everything has worked 
eb_results_empty_df &lt;- eb_results_df
eb_results_empty_df$waveset &lt;- 4

save(eb_results_empty_df, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/eb_results_empty_df4_new.RData&quot; )</code></pre>
<pre class="r"><code># And a fifth time
rm(list=ls())
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_empty_2009_5.RData&quot;))

# Store the results in a new dataframe
eb_results_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the list for all the dep vars
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  eb_results_df &lt;- rbind(eb_results_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
    }
  } 
} 

# It produces an error, but actually everything has worked 
eb_results_empty_df &lt;- eb_results_df
eb_results_empty_df$waveset &lt;- 5

save(eb_results_empty_df, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/eb_results_empty_df5_new.RData&quot; )</code></pre>
<pre class="r"><code># Now i want the same for the models with the predictors
# First clear the environment because I don&#39;t want the empty lists iterated in the predictor loop
rm(list=ls())
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_list_preds_1986_1_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_2007_1_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_2008_w_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_2009_1_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_2011_w_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_buyprod1_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_cchange2_1_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_doprot1_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_eff_daily1_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_pers_imp1_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_prsaction1_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_list_preds_quallife1_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_doprot_city_w_new.RData&quot;))

# Store the results in a new dataframe
eb_results_preds_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the list 
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results in a dataframe
  eb_results_preds_df &lt;- rbind(eb_results_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
    }
  }
} 

eb_results_preds_df$waveset &lt;- 1

# Again, an error, but the output is correct
save(eb_results_preds_df, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/eb_results_preds_df1_new.RData&quot; )</code></pre>
<pre class="r"><code># Second set
rm(list=ls())
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_list_preds_1986_2_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_2007_2_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_2009_2_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_buyprod2_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_cchange2_2_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_doprot2_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_eff_daily2_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_pers_imp2_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_prsaction2_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_list_preds_quallife2_new.RData&quot;))

# Store the results in a new dataframe
eb_results_preds_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the list 
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results in a dataframe
  eb_results_preds_df &lt;- rbind(eb_results_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
    }
  }
} 

eb_results_preds_df$waveset &lt;- 2

# Again, an error, but the output is correct
save(eb_results_preds_df, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/eb_results_preds_df2_new.RData&quot; )</code></pre>
<pre class="r"><code># Third set
rm(list=ls())

load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_2007_3_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_2009_3_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_cchange2_3_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_eff_daily3_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_prsaction3_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_list_preds_quallife3_new.RData&quot;))

# Store the results in a new dataframe
eb_results_preds_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the list 
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results in a dataframe
  eb_results_preds_df &lt;- rbind(eb_results_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
    }
  }
} 

eb_results_preds_df$waveset &lt;- 3

# Again, an error, but the output is correct
save(eb_results_preds_df, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/eb_results_preds_df3_new.RData&quot; )</code></pre>
<pre class="r"><code># Fourth set
rm(list=ls())
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_2009_4_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_cchange2_4_new.RData&quot;))

# Store the results in a new dataframe
eb_results_preds_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the list 
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results in a dataframe
  eb_results_preds_df &lt;- rbind(eb_results_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
    }
  }
} 

eb_results_preds_df$waveset &lt;- 4

# Again, an error, but the output is correct
save(eb_results_preds_df, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/eb_results_preds_df4_new.RData&quot; )</code></pre>
<pre class="r"><code># And finally the fifth 
rm(list=ls())
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_preds_2009_5_new.RData&quot;))

# Store the results in a new dataframe
eb_results_preds_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the list 
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results in a dataframe
  eb_results_preds_df &lt;- rbind(eb_results_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
    }
  }
} 

eb_results_preds_df$waveset &lt;- 5

# Again, an error, but the output is correct
save(eb_results_preds_df, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/eb_results_preds_df5_new.RData&quot; )</code></pre>
<pre class="r"><code># Lastly for the interaction models
rm(list=ls())
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_1986_1_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_2007_1_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_2008_w_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_2009_1_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_2011_w_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_buyprod1_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_cchange2_1_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_doprot1_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_eff_daily1_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_pers_imp1_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_prsaction1_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_list_interactions_quallife1_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_doprot_city_w_new.RData&quot;))

# Store the results in a new dataframe
eb_results_interactions_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the number of dep vars in the list
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  eb_results_interactions_df &lt;- rbind(eb_results_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
    }
  } 
} 

eb_results_interactions_df$waveset &lt;- 1

save(eb_results_interactions_df, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/eb_results_interactions_df1_new.RData&quot; )</code></pre>
<pre class="r"><code># Second set
rm(list=ls())
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_list_interactions_1986_2_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_2007_2_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_2009_2_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_buyprod2_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_cchange2_2_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_doprot2_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_eff_daily2_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_pers_imp2_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_prsaction2_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_list_interactions_quallife2_new.RData&quot;))

# Store the results in a new dataframe
eb_results_interactions_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the number of dep vars in the list
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  eb_results_interactions_df &lt;- rbind(eb_results_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
    }
  } 
} 

eb_results_interactions_df$waveset &lt;- 2

save(eb_results_interactions_df, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/eb_results_interactions_df2_new.RData&quot; )</code></pre>
<pre class="r"><code># Third set
rm(list=ls())
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_2007_3_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_2009_3_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_cchange2_3_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_eff_daily3_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_prsaction3_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_list_interactions_quallife3_new.RData&quot;))

# Store the results in a new dataframe
eb_results_interactions_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the number of dep vars in the list
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  eb_results_interactions_df &lt;- rbind(eb_results_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
    }
  } 
} 

eb_results_interactions_df$waveset &lt;- 3

save(eb_results_interactions_df, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/eb_results_interactions_df3_new.RData&quot; )</code></pre>
<pre class="r"><code># Fourth set
rm(list=ls())
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_2009_4_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_cchange2_4_new.RData&quot;))

# Store the results in a new dataframe
eb_results_interactions_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the number of dep vars in the list
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  eb_results_interactions_df &lt;- rbind(eb_results_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
    }
  } 
} 

eb_results_interactions_df$waveset &lt;- 4

save(eb_results_interactions_df, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/eb_results_interactions_df4_new.RData&quot; )</code></pre>
<pre class="r"><code># And the fifth 
rm(list=ls())
load(here(&quot;./data/final_data/regression_outputs&quot;, &quot;eb_list_interactions_2009_5_new.RData&quot;))

# Store the results in a new dataframe
eb_results_interactions_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the number of dep vars in the list
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  eb_results_interactions_df &lt;- rbind(eb_results_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
    }
  } 
} 

eb_results_interactions_df$waveset &lt;- 5

save(eb_results_interactions_df, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/eb_results_interactions_df5_new.RData&quot; )</code></pre>
</div>
<div id="merge-everything-into-dataset" class="section level2"
number="0.1">
<h2><span class="header-section-number">0.1</span> Merge everything into
dataset</h2>
<pre class="r"><code># Make one dataframe
# First empty lists
rm(list=ls())
# They all have the same names, so I have to assign them a new name
eb_1 &lt;- load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_results_empty_df1_new.RData&quot;))
eb_2 &lt;- load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_results_empty_df2_new.RData&quot;))
eb_3 &lt;- load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_results_empty_df3_new.RData&quot;))
eb_4 &lt;- load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_results_empty_df4_new.RData&quot;))
eb_5 &lt;- load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_results_empty_df5_new.RData&quot;))


eb_empty_df_waves &lt;- rbind (eb_1, eb_2, eb_3, eb_4, eb_5)
eb_empty_df_waves$dep_var_wave &lt;- paste(eb_empty_df_waves$dep_var, eb_empty_df_waves$waveset, sep = &quot;_&quot;)

save(eb_empty_df_waves, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/eb_empty_df_waves_new.RData&quot; )


# For the pred models
rm(list=ls())
eb_1 &lt;- load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;,&quot;eb_results_preds_df1_new.RData&quot;))
eb_2 &lt;- load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_results_preds_df2_new.RData&quot;))
eb_3 &lt;- load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_results_preds_df3_new.RData&quot;))
eb_4 &lt;- load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_results_preds_df4_new.RData&quot;))
eb_5 &lt;- load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_results_preds_df5_new.RData&quot;))

eb_preds_df_waves &lt;- rbind (eb_1, eb_2, eb_3, eb_4, eb_5)
eb_preds_df_waves$dep_var_wave &lt;- paste(eb_preds_df_waves$dep_var, eb_preds_df_waves$waveset, sep = &quot;_&quot;)

save(eb_preds_df_waves, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/eb_preds_df_waves_new.RData&quot; )

# And lastly the same for the interactions
rm(list=ls())
eb_1 &lt;- load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_results_interactions_df1_new.RData&quot;))
eb_2 &lt;- load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_results_interactions_df2_new.RData&quot;))
eb_3 &lt;- load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_results_interactions_df3_new.RData&quot;))
eb_4 &lt;- load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_results_interactions_df4_new.RData&quot;))
eb_5 &lt;- load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_results_interactions_df5_new.RData&quot;))

eb_interactions_df_waves &lt;- rbind (eb_1, eb_2, eb_3, eb_4, eb_5)
eb_interactions_df_waves$dep_var_wave &lt;- paste(eb_interactions_df_waves$dep_var, eb_interactions_df_waves$waveset, sep = &quot;_&quot;)

save(eb_interactions_df_waves, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/eb_interactions_df_waves_new.RData&quot; )

# And now one large dataframe of these three 
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_empty_df_waves_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;eb_preds_df_waves_new.RData&quot;))

# Merge the results
eb_results_df &lt;- left_join(eb_empty_df_waves, eb_preds_df_waves)
eb_results_df &lt;- left_join(eb_results_df, eb_interactions_df_waves)
eb_results_df$data &lt;- &quot;EB&quot;

# Assign year per variable
eb_results_df$first_year[eb_results_df$dep_var == &quot;role_ind&quot;] &lt;- 2007
eb_results_df$first_year[eb_results_df$dep_var == &quot;big_pol&quot;] &lt;- 2007
eb_results_df$first_year[eb_results_df$dep_var == &quot;cc_unstop&quot;] &lt;- 2008
eb_results_df$first_year[eb_results_df$dep_var == &quot;cc_exag&quot;] &lt;- 2008
eb_results_df$first_year[eb_results_df$dep_var == &quot;cc_poseu&quot;] &lt;- 2008
eb_results_df$first_year[eb_results_df$dep_var == &quot;cc_prsact&quot;] &lt;- 2008
eb_results_df$first_year[eb_results_df$dep_var == &quot;cc_poseu&quot;] &lt;- 2008
eb_results_df$first_year[eb_results_df$dep_var == &quot;ccpercept&quot;] &lt;- 2009
eb_results_df$first_year[eb_results_df$dep_var == &quot;cchange&quot;] &lt;- 2009
eb_results_df$first_year[eb_results_df$dep_var == &quot;cchange2&quot;] &lt;- 2011
eb_results_df$first_year[eb_results_df$dep_var == &quot;cchangetot&quot;] &lt;- 2011
eb_results_df$first_year[eb_results_df$dep_var == &quot;envp_eg&quot;] &lt;- 2011
eb_results_df$first_year[eb_results_df$dep_var == &quot;effr_eg&quot;] &lt;- 2011
eb_results_df$first_year[eb_results_df$dep_var == &quot;buyprod&quot;] &lt;- 2007
eb_results_df$first_year[eb_results_df$dep_var == &quot;doprot_natgov&quot;] &lt;- 2009
eb_results_df$first_year[eb_results_df$dep_var == &quot;doprot_eu&quot;] &lt;- 2009
eb_results_df$first_year[eb_results_df$dep_var == &quot;doprot_region&quot;] &lt;- 2009
eb_results_df$first_year[eb_results_df$dep_var == &quot;doprot_comp&quot;] &lt;- 2009
eb_results_df$first_year[eb_results_df$dep_var == &quot;doprot_citiz&quot;] &lt;- 2009
eb_results_df$first_year[eb_results_df$dep_var == &quot;doprot_city&quot;] &lt;- 2014
eb_results_df$first_year[eb_results_df$dep_var == &quot;eff_daily&quot;] &lt;- 2007
eb_results_df$first_year[eb_results_df$dep_var == &quot;pers_imp&quot;] &lt;- 2009
eb_results_df$first_year[eb_results_df$dep_var == &quot;env_quallife&quot;] &lt;- 2004
eb_results_df$first_year[eb_results_df$dep_var == &quot;prsaction&quot;] &lt;- 2011

# And the average year 
eb_results_df$mean_year[eb_results_df$dep_var == &quot;role_ind&quot;] &lt;- 2012
eb_results_df$mean_year[eb_results_df$dep_var == &quot;big_pol&quot;] &lt;- 2012
eb_results_df$mean_year[eb_results_df$dep_var == &quot;cc_unstop&quot;] &lt;- 2008
eb_results_df$mean_year[eb_results_df$dep_var == &quot;cc_exag&quot;] &lt;- 2008
eb_results_df$mean_year[eb_results_df$dep_var == &quot;cc_poseu&quot;] &lt;- 2008
eb_results_df$mean_year[eb_results_df$dep_var == &quot;cc_prsact&quot;] &lt;- 2008
eb_results_df$mean_year[eb_results_df$dep_var == &quot;cc_poseu&quot;] &lt;- 2008
eb_results_df$mean_year[eb_results_df$dep_var == &quot;ccpercept&quot;] &lt;- 2014
eb_results_df$mean_year[eb_results_df$dep_var == &quot;cchange&quot;] &lt;- 2015
eb_results_df$mean_year[eb_results_df$dep_var == &quot;cchange2&quot;] &lt;- 2015
eb_results_df$mean_year[eb_results_df$dep_var == &quot;cchangetot&quot;] &lt;- 2015
eb_results_df$mean_year[eb_results_df$dep_var == &quot;envp_eg&quot;] &lt;- 2013
eb_results_df$mean_year[eb_results_df$dep_var == &quot;effr_eg&quot;] &lt;- 2013
eb_results_df$mean_year[eb_results_df$dep_var == &quot;buyprod&quot;] &lt;- 2010
eb_results_df$mean_year[eb_results_df$dep_var == &quot;doprot_natgov&quot;] &lt;- 2013
eb_results_df$mean_year[eb_results_df$dep_var == &quot;doprot_eu&quot;] &lt;- 2013
eb_results_df$mean_year[eb_results_df$dep_var == &quot;doprot_region&quot;] &lt;- 2013
eb_results_df$mean_year[eb_results_df$dep_var == &quot;doprot_comp&quot;] &lt;- 2013
eb_results_df$mean_year[eb_results_df$dep_var == &quot;doprot_citiz&quot;] &lt;- 2013
eb_results_df$mean_year[eb_results_df$dep_var == &quot;doprot_city&quot;] &lt;- 2015
eb_results_df$mean_year[eb_results_df$dep_var == &quot;eff_daily&quot;] &lt;- 2012
eb_results_df$mean_year[eb_results_df$dep_var == &quot;pers_imp&quot;] &lt;- 2009
eb_results_df$mean_year[eb_results_df$dep_var == &quot;env_quallife&quot;] &lt;- 2009
eb_results_df$mean_year[eb_results_df$dep_var == &quot;prsaction&quot;] &lt;- 2014

save(eb_results_df, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/eb_results_df_waves_total_new.RData&quot; )</code></pre>
<pre class="r"><code># The same needs to be done for EVS, I&amp;O and ISSP
# EVS
rm(list=ls())
evs_1 &lt;- load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;evs_results_df1_new.RData&quot;))
evs_2 &lt;- load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;evs_results_df2_new.RData&quot;))

evs_results_df_waves &lt;- rbind (evs_1, evs_2)
evs_results_df_waves$dep_var_wave &lt;- paste(evs_results_df_waves$dep_var, evs_results_df_waves$waveset, sep = &quot;_&quot;)

save(evs_results_df_waves, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/evs_results_df_waves_new.RData&quot; )

# I&amp;O
rm(list=ls())
io_1 &lt;- load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;io_results_df1_new.RData&quot;))
io_2 &lt;- load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;io_results_df2_new.RData&quot;))

io_results_df_waves &lt;- rbind (io_1, io_2)
io_results_df_waves$dep_var_wave &lt;- paste(io_results_df_waves$dep_var, io_results_df_waves$waveset, sep = &quot;_&quot;)

save(io_results_df_waves, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/io_results_df_waves_new.RData&quot; )

# And ISSP
rm(list=ls())
issp_1 &lt;- load(here(&quot;./data/final_data/regression_outputs/regression_outputs/per_wave&quot;, &quot;issp_results_df1_new.RData&quot;))
issp_2 &lt;- load(here(&quot;./data/final_data/regression_outputs/per_wave&quot;, &quot;issp_results_df2_new.RData&quot;))

issp_results_df_waves &lt;- rbind (issp_1, issp_2)
issp_results_df_waves$dep_var_wave &lt;- paste(issp_results_df_waves$dep_var, issp_results_df_waves$waveset, sep = &quot;_&quot;)

save(issp_results_df_waves, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/final_data/regression_outputs/per_wave/issp_results_df_waves_new.RData&quot; )</code></pre>
<pre class="r"><code># The final step is to merge all results into one dataframe
rm(list=ls())
load(here(&quot;./data/final_data/regression_outputs/regression_outputs&quot;, &quot;ess_results_df_w_new.RData&quot;))
ess_results_df$waveset &lt;- 1
ess_results_df$dep_var_wave &lt;- paste(ess_results_df$dep_var, ess_results_df$waveset, sep = &quot;_&quot;)

load(here(&quot;./data/final_data/regression_outputs/regression_outputs&quot;, &quot;issp_results_2_df_new.RData&quot;))

issp_results_2_df$mean_year &lt;- 2005
issp_results_2_df$waveset &lt;- 1
issp_results_2_df$dep_var_wave &lt;- paste(issp_results_2_df$dep_var, issp_results_2_df$waveset, sep = &quot;_&quot;)

load(here(&quot;./data/final_data/regression_outputs/regression_outputs/per_wave&quot;, &quot;evs_results_df_waves_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs/regression_outputs/per_wave&quot;, &quot;io_results_df_waves_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs/regression_outputs/per_wave&quot;, &quot;issp_results_df_waves_new.RData&quot;))
load(here(&quot;./data/final_data/regression_outputs/regression_outputs/per_wave&quot;, &quot;eb_results_df_waves_total_new.RData&quot;))

total_results_waves &lt;- rbind(eb_results_df, ess_results_df, evs_results_df_waves, io_results_df_waves, issp_results_df_waves, issp_results_2_df) 

save(total_results_waves, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/meta_analysis/total_results_waves_new.RData&quot; )</code></pre>
<pre class="r"><code># I also want to add a variable that describes whether the dependent variable is mostly of affective, behavioral or cognitive nature 

# 2 variables that are called worry, not handy 
total_results_waves$dep_var[total_results_waves$dep_var == &quot;worry&quot; &amp; total_results_waves$data == &quot;ISSP&quot;] &lt;- &quot;worry_issp&quot;

total_results_waves$attitude_cat[total_results_waves$dep_var == &quot;dodiff&quot; 
                               | total_results_waves$dep_var == &quot;pers_resp&quot;
                               | total_results_waves$dep_var == &quot;worry&quot;
                               | total_results_waves$dep_var == &quot;worried&quot;
                               | total_results_waves$dep_var == &quot;worry_future&quot;
                               | total_results_waves$dep_var == &quot;frontrunner&quot;
                               | total_results_waves$dep_var == &quot;min_contr&quot;] &lt;- &quot;affective&quot;
total_results_waves$attitude_cat[total_results_waves$dep_var == &quot;willing_price&quot; 
                               | total_results_waves$dep_var == &quot;willing_tax&quot;
                               | total_results_waves$dep_var == &quot;willing_living&quot;
                               | total_results_waves$dep_var == &quot;do_right&quot;
                               | total_results_waves$dep_var == &quot;people_decide&quot;
                               | total_results_waves$dep_var == &quot;climate5&quot;
                               | total_results_waves$dep_var == &quot;prsaction&quot;
                               | total_results_waves$dep_var == &quot;cc_prsact&quot;
                               | total_results_waves$dep_var == &quot;buyprod&quot;] &lt;- &quot;behavioral&quot;
total_results_waves$attitude_cat[total_results_waves$dep_var == &quot;worry_issp&quot; 
                               | total_results_waves$dep_var == &quot;lifeharm&quot;
                               | total_results_waves$dep_var == &quot;progharm&quot;
                               | total_results_waves$dep_var == &quot;econprotect&quot;
                               | total_results_waves$dep_var == &quot;growharm&quot;
                               | total_results_waves$dep_var == &quot;bus_decide&quot;
                               | total_results_waves$dep_var == &quot;moreimp&quot;
                               | total_results_waves$dep_var == &quot;othersame&quot;
                               | total_results_waves$dep_var == &quot;exag&quot;
                               | total_results_waves$dep_var == &quot;country_effort&quot; 
                               | total_results_waves$dep_var == &quot;cause&quot;
                               | total_results_waves$dep_var == &quot;resp_citiz&quot;
                               | total_results_waves$dep_var == &quot;dk_start&quot;
                               | total_results_waves$dep_var == &quot;do_gov&quot;
                               | total_results_waves$dep_var == &quot;buss_help&quot;
                               | total_results_waves$dep_var == &quot;human_resp&quot;
                               | total_results_waves$dep_var == &quot;env_ec_stat&quot;
                               | total_results_waves$dep_var == &quot;env_prsimp&quot;
                                | total_results_waves$dep_var == &quot;envp_eg&quot;
                               | total_results_waves$dep_var == &quot;effr_eg&quot;
                               | total_results_waves$dep_var == &quot;cchange&quot;
                               | total_results_waves$dep_var == &quot;cchange2&quot;
                               | total_results_waves$dep_var == &quot;cchangetot&quot; 
                               | total_results_waves$dep_var == &quot;ccpercept&quot;
                               | total_results_waves$dep_var == &quot;env_quallife&quot;
                               | total_results_waves$dep_var == &quot;doprot_comp&quot;
                               | total_results_waves$dep_var == &quot;doprot_region&quot;
                               | total_results_waves$dep_var == &quot;doprot_natgov&quot;
                               | total_results_waves$dep_var == &quot;doprot_city&quot;
                               | total_results_waves$dep_var == &quot;doprot_citiz&quot;
                               | total_results_waves$dep_var == &quot;doprot_eu&quot;
                              | total_results_waves$dep_var == &quot;cc_unstop&quot;
                               | total_results_waves$dep_var == &quot;cc_exag&quot;
                               | total_results_waves$dep_var == &quot;cc_poseu&quot;
                               | total_results_waves$dep_var == &quot;role_ind&quot;
                               | total_results_waves$dep_var == &quot;big_pol&quot;
                               | total_results_waves$dep_var == &quot;eff_daily&quot;
                               | total_results_waves$dep_var == &quot;pers_imp&quot;] &lt;- &quot;cognitive&quot;

#Create a variable that indicates whether the dependent variable can be interpreted in 2 ways (ambiguous)
total_results_waves$ambiguous[total_results_waves$dep_var != &quot;dodiff&quot; 
                               | total_results_waves$dep_var != &quot;frontrunner&quot;
                               | total_results_waves$dep_var != &quot;min_contr&quot;
                               | total_results_waves$dep_var != &quot;people_decide&quot;
                               | total_results_waves$dep_var != &quot;econprotect&quot;
                               | total_results_waves$dep_var != &quot;growharm&quot;
                               | total_results_waves$dep_var != &quot;bus_decide&quot;
                            | total_results_waves$dep_var != &quot;othersame&quot;
                            | total_results_waves$dep_var != &quot;resp_citiz&quot;
                            | total_results_waves$dep_var != &quot;dk_start&quot;
                            | total_results_waves$dep_var != &quot;buss_help&quot;
                            | total_results_waves$dep_var != &quot;envp_eg&quot;
                            | total_results_waves$dep_var != &quot;effr_eg&quot;
                            | total_results_waves$dep_var != &quot;env_quallife&quot;
                            | total_results_waves$dep_var != &quot;cc_unstop&quot;
                            | total_results_waves$dep_var != &quot;cc_poseu&quot;
                            | total_results_waves$dep_var != &quot;big_pol&quot;] &lt;- &quot;No&quot;
total_results_waves$ambiguous[total_results_waves$dep_var == &quot;dodiff&quot; 
                               | total_results_waves$dep_var == &quot;frontrunner&quot;
                               | total_results_waves$dep_var == &quot;min_contr&quot;
                               | total_results_waves$dep_var == &quot;people_decide&quot;
                               | total_results_waves$dep_var == &quot;econprotect&quot;
                               | total_results_waves$dep_var == &quot;growharm&quot;
                               | total_results_waves$dep_var == &quot;bus_decide&quot;
                            | total_results_waves$dep_var == &quot;othersame&quot;
                            | total_results_waves$dep_var == &quot;resp_citiz&quot;
                            | total_results_waves$dep_var == &quot;dk_start&quot;
                            | total_results_waves$dep_var == &quot;buss_help&quot;
                            | total_results_waves$dep_var == &quot;envp_eg&quot;
                            | total_results_waves$dep_var == &quot;effr_eg&quot;
                            | total_results_waves$dep_var == &quot;env_quallife&quot;
                            | total_results_waves$dep_var == &quot;cc_unstop&quot;
                            | total_results_waves$dep_var == &quot;cc_poseu&quot;
                            | total_results_waves$dep_var == &quot;big_pol&quot;] &lt;- &quot;Yes&quot;


# Create a variable about whether 2008 (financial crisis) is included in the time span of the data set/vars 
total_results_waves$fin_crisis[total_results_waves$data == &quot;EVS&quot; &amp; total_results_waves$waveset == 2] &lt;- 1
total_results_waves$fin_crisis[total_results_waves$data == &quot;EVS&quot; &amp; total_results_waves$waveset == 1] &lt;- 0
total_results_waves$fin_crisis[total_results_waves$data == &quot;ISSP&quot; &amp; total_results_waves$first_year == 2000] &lt;- 1
total_results_waves$fin_crisis[total_results_waves$data == &quot;ISSP&quot; &amp; total_results_waves$first_year == 1993] &lt;- 0
total_results_waves$fin_crisis[total_results_waves$data == &quot;ESS&quot;] &lt;- 0
total_results_waves$fin_crisis[total_results_waves$data == &quot;IO&quot;] &lt;- 0
# For the EB, this varies more
total_results_waves$fin_crisis[total_results_waves$data == &quot;EB&quot;] &lt;- 0
total_results_waves$fin_crisis[total_results_waves$dep_var_wave == &quot;env_quallife_2&quot;] &lt;- 1
total_results_waves$fin_crisis[total_results_waves$dep_var_wave == &quot;role_ind_1&quot;] &lt;- 1
total_results_waves$fin_crisis[total_results_waves$dep_var_wave == &quot;big_pol_1&quot;] &lt;- 1
total_results_waves$fin_crisis[total_results_waves$dep_var_wave == &quot;buyprod_1&quot;] &lt;- 1
total_results_waves$fin_crisis[total_results_waves$dep_var_wave == &quot;eff_daily_1&quot;] &lt;- 1
total_results_waves$fin_crisis[total_results_waves$dep_var_wave == &quot;cc_unstop_1&quot;] &lt;- 1
total_results_waves$fin_crisis[total_results_waves$dep_var_wave == &quot;cc_exag_1&quot;] &lt;- 1
total_results_waves$fin_crisis[total_results_waves$dep_var_wave == &quot;cc_prsact_1&quot;] &lt;- 1

# And the same for covid-19
total_results_waves$covid[total_results_waves$data == &quot;EVS&quot;] &lt;- 0
total_results_waves$covid[total_results_waves$data == &quot;ISSP&quot;] &lt;- 0
total_results_waves$covid[total_results_waves$data == &quot;ESS&quot;] &lt;- 1
total_results_waves$covid[total_results_waves$data == &quot;IO&quot;] &lt;- 1
total_results_waves$covid[total_results_waves$data == &quot;EB&quot;] &lt;- 0
total_results_waves$covid[total_results_waves$dep_var_wave == &quot;ccpercept_5&quot;] &lt;- 1
total_results_waves$covid[total_results_waves$dep_var_wave == &quot;cchange_5&quot;] &lt;- 1
total_results_waves$covid[total_results_waves$dep_var_wave == &quot;cchange2_5&quot;] &lt;- 1
total_results_waves$covid[total_results_waves$dep_var_wave == &quot;cchangetot_5&quot;] &lt;- 1

save(total_results_waves, file= &quot;/Users/anuschka/Documents/climatechange/climatechange/data/meta_analysis/total_results_waves_new.RData&quot; )</code></pre>
</div>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIkV4dHJhY3QgY29lZmZpY2llbnRzIG9mIGdhbWxzcyByZWdyZXNzaW9ucyBzaG9ydGVyIHRpbWUgc3BhbnMiDQphdXRob3I6ICJBbnVzY2hrYSBQZWVsZW4iDQpkYXRlOiAiYHIgU3lzLkRhdGUoKWAiDQpvdXRwdXQ6IGh0bWxfZG9jdW1lbnQNCi0tLQ0KDQpgYGB7ciwgZWNobz1GQUxTRX0NCmtuaXRyOjpvcHRzX2NodW5rJHNldChldmFsID0gRkFMU0UpDQprbml0cjo6b3B0c19jaHVuayRzZXQobnVtYmVyX3NlY3Rpb25zID0gRkFMU0UpDQpvcHRpb25zKHdpZHRoID0gMTAwKQ0KY29sb3JpemUgPC0gZnVuY3Rpb24oeCwgY29sb3IpIHtzcHJpbnRmKCI8c3BhbiBzdHlsZT0nY29sb3I6ICVzOyc+JXM8L3NwYW4+IiwgY29sb3IsIHgpIH0NCmBgYA0KDQpJbiB0aGlzIHNjcmlwdCBJIGV4dHJhY3QgdGhlIGNvZWZmaWNpZW50cyBmb3IgdGhlIHRpbWUgZWZmZWN0cyBhbmQgaW50ZXJjZXB0cyBhbmQgcHV0IHRoZW0gaW4gYSBkYXRhc2V0IHRvZ2V0aGVyLCB0byB1c2UgdGhlbSBhcyBpbnB1dCBmb3IgdGhlIG1ldGEtcmVncmVzc2lvbi4gVGhpcyBzY3JpcHQgdXNlcyB0aGUgZ2FtbHNzIHJlZ3Jlc3Npb25zIHdpdGggdGhlIHRpbWUgZWZmZWN0cyBvdmVyIHNob3J0ZXIgdGltZSBzcGFucy4gDQoNCmBgYHtyfQ0Kcm0obGlzdD1scygpKQ0KbGlicmFyeSh0aWR5dmVyc2UpDQpsaWJyYXJ5KGRwbHlyKQ0KbGlicmFyeShnYW1sc3MpDQpsaWJyYXJ5KGhlcmUpDQpoZXJlKCkNCmhlcmU6OmlfYW0oInNjcmlwdHMvYW5hbHlzaXMvcmVncmVzc2lvbl90b19tZXRhX2FuYWx5c2lzX3dnX3dhdmVzX25ldy5SbWQiKQ0KYGBgDQoNCiMjIEVWUyB7LX0NCg0KYGBge3J9DQojIE5vdyB0aGUgc2FtZSBmb3IgdGhlIEVWUw0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUiLCAiZXZzX2xpc3RfZW1wdHkxLlJEYXRhIikpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQpldnNfZW1wdHlfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCiMgTG9vcCBvdmVyIHRoZSBsaXN0IGZvciBhbGwgdGhlIGRlcCB2YXJzDQpmb3IgKGkgaW4gc2VxX2Fsb25nKGV2c19saXN0X2VtcHR5KSkgew0KDQogICMgRXh0cmFjdCB0aGUgbmFtZSBvZiB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIoZXZzX2xpc3RfZW1wdHlbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkoZXZzX2xpc3RfZW1wdHlbW2ldXSkNCiAgDQogICMgRXh0cmFjdCB0aGUgaW5mbw0KICBtdV9pbnQgPC0gc3VtW1sxXV0NCiAgbXVfc2QgPC0gc3VtW1sxLDJdXQ0KICBzaWdtYV9pbnQgPC0gc3VtW1szXV0NCiAgc2lnbWFfc2QgPC0gc3VtW1szLDJdXQ0KICBtdV90aW1lIDwtIHN1bSBbWzJdXQ0KICBtdV90aW1lX3NkIDwtIHN1bVtbMiwyXV0NCiAgc2lnX3RpbWUgPC0gc3VtW1s0XV0NCiAgc2lnX3RpbWVfc2QgPC0gc3VtW1s0LDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgZXZzX2VtcHR5X2RmIDwtIHJiaW5kKGV2c19lbXB0eV9kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0ID0gbXVfaW50LCBtdV9zZCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkID0gc2lnbWFfc2QsIG11X3RpbWUgPSBtdV90aW1lLCBtdV90aW1lX3NkID0gbXVfdGltZV9zZCwgc2lnX3RpbWUgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2QgPSBzaWdfdGltZV9zZCkpDQp9DQoNCiMgQW5kIHRoZSBwcmVkaWN0b3IgbW9kZWwNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlIiwgImV2c19saXN0X3ByZWRzMV9uZXcuUkRhdGEiKSkNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmV2c19wcmVkc19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBMb29wIG92ZXIgdGhlIGxpc3Qgb2YgbW9kZWxzDQpmb3IgKGkgaW4gc2VxX2Fsb25nKGV2c19saXN0X3ByZWRzKSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIoZXZzX2xpc3RfcHJlZHNbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkoZXZzX2xpc3RfcHJlZHNbW2ldXSkNCiAgDQogICMgRXh0cmFjdCB0aGUgaW50ZXJjZXB0IGFuZCBzdGFuZGFyZCBkZXZpYXRpb24gZm9yIG11IGFuZCBzaWdtYQ0KICBtdV9pbnQgPC0gc3VtW1sxXV0NCiAgbXVfc2QgPC0gc3VtW1sxLDJdXQ0KICBzaWdtYV9pbnQgPC0gc3VtW1s3XV0NCiAgc2lnbWFfc2QgPC0gc3VtW1s3LDJdXQ0KICBtdV90aW1lIDwtIHN1bSBbWzJdXQ0KICBtdV90aW1lX3NkIDwtIHN1bVtbMiwyXV0NCiAgc2lnX3RpbWUgPC0gc3VtW1s4XV0NCiAgc2lnX3RpbWVfc2QgPC0gc3VtW1s4LDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgDQogIGV2c19wcmVkc19kZiA8LSByYmluZChldnNfcHJlZHNfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdF9wcmVkID0gbXVfaW50LCBtdV9zZF9wcmVkID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdF9wcmVkID0gc2lnbWFfaW50LCBzaWdtYV9zZF9wcmVkID0gc2lnbWFfc2QsIG11X3RpbWVfcHJlZCA9IG11X3RpbWUsIG11X3RpbWVfc2RfcHJlZCA9IG11X3RpbWVfc2QsIHNpZ190aW1lX3ByZWQgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2RfcHJlZCA9IHNpZ190aW1lX3NkKSkNCn0NCg0KIyBBbmQgbGFzdGx5IHRoZSBpbnRlcmFjdGlvbiBtb2RlbA0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUiLCAiZXZzX2xpc3RfaW50ZXJhY3Rpb25zMV9uZXcuUkRhdGEiKSkNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmV2c19pbnRlcmFjdGlvbnNfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCiMgTG9vcCBvdmVyIHRoZSBudW1iZXIgb2YgZGVwIHZhcnMgaW4gdGhlIGxpc3QNCmZvciAoaSBpbiBzZXFfYWxvbmcoZXZzX2xpc3RfaW50ZXJhY3Rpb25zKSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIoZXZzX2xpc3RfaW50ZXJhY3Rpb25zW1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KGV2c19saXN0X2ludGVyYWN0aW9uc1tbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvIEkgbmVlZCBmcm9tIHRoZSBzdW1tYXJ5DQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzExXV0NCiAgc2lnbWFfc2QgPC0gc3VtW1sxMSwyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbMTJdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzEyLDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgZXZzX2ludGVyYWN0aW9uc19kZiA8LSByYmluZChldnNfaW50ZXJhY3Rpb25zX2RmLCBkYXRhLmZyYW1lKGRlcF92YXIgPSBkZXBfdmFyLCBtdV9pbnRlcmNlcHRfaW50ID0gbXVfaW50LCBtdV9zZF9pbnQgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0X2ludCA9IHNpZ21hX2ludCwgc2lnbWFfc2RfaW50ID0gc2lnbWFfc2QsIG11X3RpbWVfaW50ID0gbXVfdGltZSwgbXVfdGltZV9zZF9pbnQgPSBtdV90aW1lX3NkLCBzaWdfdGltZV9pbnQgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2RfaW50ID0gc2lnX3RpbWVfc2QpKQ0KfQ0KDQojIE1lcmdlIHRoZSByZXN1bHRzLCBhbmQgYWRkIHNvbWUgdmFyaWFibGVzIHdpdGggZXh0cmEgaW5mb3JtYXRpb24gDQpldnNfcmVzdWx0c19kZiA8LSBsZWZ0X2pvaW4oZXZzX2VtcHR5X2RmLCBldnNfcHJlZHNfZGYpDQpldnNfcmVzdWx0c19kZiA8LSBsZWZ0X2pvaW4oZXZzX3Jlc3VsdHNfZGYsIGV2c19pbnRlcmFjdGlvbnNfZGYpDQpldnNfcmVzdWx0c19kZiRmaXJzdF95ZWFyIDwtIDE5OTAgDQpldnNfcmVzdWx0c19kZiRtZWFuX3llYXIgPC0gMTk5NQ0KZXZzX3Jlc3VsdHNfZGYkd2F2ZXNldCA8LSAxDQpldnNfcmVzdWx0c19kZiRkYXRhIDwtICJFVlMiDQoNCnNhdmUoZXZzX3Jlc3VsdHNfZGYsIGZpbGU9Ii9Vc2Vycy9hbnVzY2hrYS9Eb2N1bWVudHMvY2xpbWF0ZWNoYW5nZS9jbGltYXRlY2hhbmdlL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZXZzX3Jlc3VsdHNfZGYxX25ldy5SRGF0YSIpDQpgYGANCg0KDQpgYGB7cn0NCiMgQW5kIHRoZSBzZWNvbmQgc2V0DQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZSIsICJldnNfbGlzdF9lbXB0eTIuUkRhdGEiKSkNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmV2c19lbXB0eV9kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBMb29wIG92ZXIgdGhlIGxpc3QgZm9yIGFsbCB0aGUgZGVwIHZhcnMNCmZvciAoaSBpbiBzZXFfYWxvbmcoZXZzX2xpc3RfZW1wdHkpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3RlcihldnNfbGlzdF9lbXB0eVtbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShldnNfbGlzdF9lbXB0eVtbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvDQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzNdXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzMsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzRdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzQsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBldnNfZW1wdHlfZGYgPC0gcmJpbmQoZXZzX2VtcHR5X2RmLCBkYXRhLmZyYW1lKGRlcF92YXIgPSBkZXBfdmFyLCBtdV9pbnRlcmNlcHQgPSBtdV9pbnQsIG11X3NkID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdCA9IHNpZ21hX2ludCwgc2lnbWFfc2QgPSBzaWdtYV9zZCwgbXVfdGltZSA9IG11X3RpbWUsIG11X3RpbWVfc2QgPSBtdV90aW1lX3NkLCBzaWdfdGltZSA9IHNpZ190aW1lLCBzaWdfdGltZV9zZCA9IHNpZ190aW1lX3NkKSkNCn0NCg0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUiLCAiZXZzX2xpc3RfcHJlZHMyX25ldy5SRGF0YSIpKQ0KDQojIFN0b3JlIHRoZSByZXN1bHRzIGluIGEgbmV3IGRhdGFmcmFtZQ0KZXZzX3ByZWRzX2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIExvb3Agb3ZlciB0aGUgbGlzdCBvZiBtb2RlbHMNCmZvciAoaSBpbiBzZXFfYWxvbmcoZXZzX2xpc3RfcHJlZHMpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3RlcihldnNfbGlzdF9wcmVkc1tbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShldnNfbGlzdF9wcmVkc1tbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbnRlcmNlcHQgYW5kIHN0YW5kYXJkIGRldmlhdGlvbiBmb3IgbXUgYW5kIHNpZ21hDQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzddXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzcsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzhdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzgsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyANCiAgZXZzX3ByZWRzX2RmIDwtIHJiaW5kKGV2c19wcmVkc19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0X3ByZWQgPSBtdV9pbnQsIG11X3NkX3ByZWQgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0X3ByZWQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkX3ByZWQgPSBzaWdtYV9zZCwgbXVfdGltZV9wcmVkID0gbXVfdGltZSwgbXVfdGltZV9zZF9wcmVkID0gbXVfdGltZV9zZCwgc2lnX3RpbWVfcHJlZCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9wcmVkID0gc2lnX3RpbWVfc2QpKQ0KfQ0KDQojIEFuZCBsYXN0bHkgdGhlIGludGVyYWN0aW9uIG1vZGVsDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZSIsICJldnNfbGlzdF9pbnRlcmFjdGlvbnMyX25ldy5SRGF0YSIpKQ0KDQojIFN0b3JlIHRoZSByZXN1bHRzIGluIGEgbmV3IGRhdGFmcmFtZQ0KZXZzX2ludGVyYWN0aW9uc19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBMb29wIG92ZXIgdGhlIG51bWJlciBvZiBkZXAgdmFycyBpbiB0aGUgbGlzdA0KZm9yIChpIGluIHNlcV9hbG9uZyhldnNfbGlzdF9pbnRlcmFjdGlvbnMpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3RlcihldnNfbGlzdF9pbnRlcmFjdGlvbnNbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkoZXZzX2xpc3RfaW50ZXJhY3Rpb25zW1tpXV0pDQogIA0KICAjIEV4dHJhY3QgdGhlIGluZm8gSSBuZWVkIGZyb20gdGhlIHN1bW1hcnkNCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbMTFdXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzExLDJdXQ0KICBtdV90aW1lIDwtIHN1bSBbWzJdXQ0KICBtdV90aW1lX3NkIDwtIHN1bVtbMiwyXV0NCiAgc2lnX3RpbWUgPC0gc3VtW1sxMl1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbMTIsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBldnNfaW50ZXJhY3Rpb25zX2RmIDwtIHJiaW5kKGV2c19pbnRlcmFjdGlvbnNfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdF9pbnQgPSBtdV9pbnQsIG11X3NkX2ludCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHRfaW50ID0gc2lnbWFfaW50LCBzaWdtYV9zZF9pbnQgPSBzaWdtYV9zZCwgbXVfdGltZV9pbnQgPSBtdV90aW1lLCBtdV90aW1lX3NkX2ludCA9IG11X3RpbWVfc2QsIHNpZ190aW1lX2ludCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9pbnQgPSBzaWdfdGltZV9zZCkpDQp9DQoNCiMgTWVyZ2UgdGhlIHJlc3VsdHMNCmV2c19yZXN1bHRzX2RmIDwtIGxlZnRfam9pbihldnNfZW1wdHlfZGYsIGV2c19wcmVkc19kZikNCmV2c19yZXN1bHRzX2RmIDwtIGxlZnRfam9pbihldnNfcmVzdWx0c19kZiwgZXZzX2ludGVyYWN0aW9uc19kZikNCmV2c19yZXN1bHRzX2RmJGZpcnN0X3llYXIgPC0gMTk5OQ0KZXZzX3Jlc3VsdHNfZGYkbWVhbl95ZWFyIDwtIDIwMDQNCmV2c19yZXN1bHRzX2RmJHdhdmVzZXQgPC0gMg0KZXZzX3Jlc3VsdHNfZGYkZGF0YSA8LSAiRVZTIg0KDQpzYXZlKGV2c19yZXN1bHRzX2RmLCBmaWxlPSIvVXNlcnMvYW51c2Noa2EvRG9jdW1lbnRzL2NsaW1hdGVjaGFuZ2UvY2xpbWF0ZWNoYW5nZS9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2V2c19yZXN1bHRzX2RmMl9uZXcuUkRhdGEiKQ0KYGBgDQoNCiMjIEkmTyBSZXNlYXJjaCB7LX0NCg0KYGBge3J9DQpybShsaXN0PWxzKCkpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZSIsICJpb19saXN0X2VtcHR5MS5SRGF0YSIpKQ0KDQojIFN0b3JlIHRoZSByZXN1bHRzIGluIGEgbmV3IGRhdGFmcmFtZQ0KaW9fZW1wdHlfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCmZvciAoaSBpbiBzZXFfYWxvbmcoaW9fbGlzdF9lbXB0eSkpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKGlvX2xpc3RfZW1wdHlbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkoaW9fbGlzdF9lbXB0eVtbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvDQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzNdXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzMsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzRdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzQsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBpb19lbXB0eV9kZiA8LSByYmluZChpb19lbXB0eV9kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0ID0gbXVfaW50LCBtdV9zZCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkID0gc2lnbWFfc2QsIG11X3RpbWUgPSBtdV90aW1lLCBtdV90aW1lX3NkID0gbXVfdGltZV9zZCwgc2lnX3RpbWUgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2QgPSBzaWdfdGltZV9zZCkpDQp9DQoNCiMgUHJlZGljdG9yIG1vZGVsDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZSIsICJpb19saXN0X3ByZWRzMV9uZXcuUkRhdGEiKSkNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmlvX3ByZWRzX2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIExvb3Agb3ZlciB0aGUgbGlzdCANCmZvciAoaSBpbiBzZXFfYWxvbmcoaW9fbGlzdF9wcmVkcykpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKGlvX2xpc3RfcHJlZHNbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkoaW9fbGlzdF9wcmVkc1tbaV1dKQ0KICANCiAgIyBFeHRyYWN0IGluZm8NCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbN11dDQogIHNpZ21hX3NkIDwtIHN1bVtbNywyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbOF1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbOCwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIGluIGEgZGF0YWZyYW1lDQogIGlvX3ByZWRzX2RmIDwtIHJiaW5kKGlvX3ByZWRzX2RmLCBkYXRhLmZyYW1lKGRlcF92YXIgPSBkZXBfdmFyLCBtdV9pbnRlcmNlcHRfcHJlZCA9IG11X2ludCwgbXVfc2RfcHJlZCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHRfcHJlZCA9IHNpZ21hX2ludCwgc2lnbWFfc2RfcHJlZCA9IHNpZ21hX3NkLCBtdV90aW1lX3ByZWQgPSBtdV90aW1lLCBtdV90aW1lX3NkX3ByZWQgPSBtdV90aW1lX3NkLCBzaWdfdGltZV9wcmVkID0gc2lnX3RpbWUsIHNpZ190aW1lX3NkX3ByZWQgPSBzaWdfdGltZV9zZCkpDQp9DQoNCiMgSW50ZXJhY3Rpb24gbW9kZWwNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlIiwgImlvX2xpc3RfaW50ZXJhY3Rpb25zMV9uZXcuUkRhdGEiKSkNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmlvX2ludGVyYWN0aW9uc19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBMb29wIG92ZXIgdGhlIG51bWJlciBvZiBkZXAgdmFycyBpbiB0aGUgbGlzdA0KZm9yIChpIGluIHNlcV9hbG9uZyhpb19saXN0X2ludGVyYWN0aW9ucykpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKGlvX2xpc3RfaW50ZXJhY3Rpb25zW1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KGlvX2xpc3RfaW50ZXJhY3Rpb25zW1tpXV0pDQogIA0KICAjIEV4dHJhY3QgdGhlIGluZm8gSSBuZWVkIGZyb20gdGhlIHN1bW1hcnkNCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbMTFdXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzExLDJdXQ0KICBtdV90aW1lIDwtIHN1bSBbWzJdXQ0KICBtdV90aW1lX3NkIDwtIHN1bVtbMiwyXV0NCiAgc2lnX3RpbWUgPC0gc3VtW1sxMl1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbMTIsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBpb19pbnRlcmFjdGlvbnNfZGYgPC0gcmJpbmQoaW9faW50ZXJhY3Rpb25zX2RmLCBkYXRhLmZyYW1lKGRlcF92YXIgPSBkZXBfdmFyLCBtdV9pbnRlcmNlcHRfaW50ID0gbXVfaW50LCBtdV9zZF9pbnQgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0X2ludCA9IHNpZ21hX2ludCwgc2lnbWFfc2RfaW50ID0gc2lnbWFfc2QsIG11X3RpbWVfaW50ID0gbXVfdGltZSwgbXVfdGltZV9zZF9pbnQgPSBtdV90aW1lX3NkLCBzaWdfdGltZV9pbnQgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2RfaW50ID0gc2lnX3RpbWVfc2QpKQ0KfQ0KDQojIE1lcmdlIHRoZSByZXN1bHRzDQppb19yZXN1bHRzX2RmIDwtIGxlZnRfam9pbihpb19lbXB0eV9kZiwgaW9fcHJlZHNfZGYpDQppb19yZXN1bHRzX2RmIDwtIGxlZnRfam9pbihpb19yZXN1bHRzX2RmLCBpb19pbnRlcmFjdGlvbnNfZGYpDQppb19yZXN1bHRzX2RmJGZpcnN0X3llYXIgPC0gMjAxOQ0KaW9fcmVzdWx0c19kZiRtZWFuX3llYXIgPC0gMjAyMA0KaW9fcmVzdWx0c19kZiR3YXZlc2V0IDwtIDENCmlvX3Jlc3VsdHNfZGYkZGF0YSA8LSAiSU8iDQoNCnNhdmUoaW9fcmVzdWx0c19kZiwgZmlsZT0iL1VzZXJzL2FudXNjaGthL0RvY3VtZW50cy9jbGltYXRlY2hhbmdlL2NsaW1hdGVjaGFuZ2UvZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9pb19yZXN1bHRzX2RmMV9uZXcuUkRhdGEiKQ0KYGBgDQoNCg0KYGBge3J9DQojIFNlY29uZCBzZXQNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlIiwgImlvX2xpc3RfZW1wdHkyLlJEYXRhIikpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQppb19lbXB0eV9kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KZm9yIChpIGluIHNlcV9hbG9uZyhpb19saXN0X2VtcHR5KSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIoaW9fbGlzdF9lbXB0eVtbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShpb19saXN0X2VtcHR5W1tpXV0pDQogIA0KICAjIEV4dHJhY3QgdGhlIGluZm8NCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbM11dDQogIHNpZ21hX3NkIDwtIHN1bVtbMywyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbNF1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbNCwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIGluIGEgZGF0YWZyYW1lDQogIGlvX2VtcHR5X2RmIDwtIHJiaW5kKGlvX2VtcHR5X2RmLCBkYXRhLmZyYW1lKGRlcF92YXIgPSBkZXBfdmFyLCBtdV9pbnRlcmNlcHQgPSBtdV9pbnQsIG11X3NkID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdCA9IHNpZ21hX2ludCwgc2lnbWFfc2QgPSBzaWdtYV9zZCwgbXVfdGltZSA9IG11X3RpbWUsIG11X3RpbWVfc2QgPSBtdV90aW1lX3NkLCBzaWdfdGltZSA9IHNpZ190aW1lLCBzaWdfdGltZV9zZCA9IHNpZ190aW1lX3NkKSkNCn0NCg0KIyBQcmVkaWN0b3IgbW9kZWwNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlIiwgImlvX2xpc3RfcHJlZHMyX25ldy5SRGF0YSIpKQ0KDQojIFN0b3JlIHRoZSByZXN1bHRzIGluIGEgbmV3IGRhdGFmcmFtZQ0KaW9fcHJlZHNfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCiMgTG9vcCBvdmVyIHRoZSBsaXN0IA0KZm9yIChpIGluIHNlcV9hbG9uZyhpb19saXN0X3ByZWRzKSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIoaW9fbGlzdF9wcmVkc1tbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShpb19saXN0X3ByZWRzW1tpXV0pDQogIA0KICAjIEV4dHJhY3QgaW5mbw0KICBtdV9pbnQgPC0gc3VtW1sxXV0NCiAgbXVfc2QgPC0gc3VtW1sxLDJdXQ0KICBzaWdtYV9pbnQgPC0gc3VtW1s3XV0NCiAgc2lnbWFfc2QgPC0gc3VtW1s3LDJdXQ0KICBtdV90aW1lIDwtIHN1bSBbWzJdXQ0KICBtdV90aW1lX3NkIDwtIHN1bVtbMiwyXV0NCiAgc2lnX3RpbWUgPC0gc3VtW1s4XV0NCiAgc2lnX3RpbWVfc2QgPC0gc3VtW1s4LDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgaW9fcHJlZHNfZGYgPC0gcmJpbmQoaW9fcHJlZHNfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdF9wcmVkID0gbXVfaW50LCBtdV9zZF9wcmVkID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdF9wcmVkID0gc2lnbWFfaW50LCBzaWdtYV9zZF9wcmVkID0gc2lnbWFfc2QsIG11X3RpbWVfcHJlZCA9IG11X3RpbWUsIG11X3RpbWVfc2RfcHJlZCA9IG11X3RpbWVfc2QsIHNpZ190aW1lX3ByZWQgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2RfcHJlZCA9IHNpZ190aW1lX3NkKSkNCn0NCg0KIyBJbnRlcmFjdGlvbiBtb2RlbA0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUiLCAiaW9fbGlzdF9pbnRlcmFjdGlvbnMyX25ldy5SRGF0YSIpKQ0KDQojIFN0b3JlIHRoZSByZXN1bHRzIGluIGEgbmV3IGRhdGFmcmFtZQ0KaW9faW50ZXJhY3Rpb25zX2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIExvb3Agb3ZlciB0aGUgbnVtYmVyIG9mIGRlcCB2YXJzIGluIHRoZSBsaXN0DQpmb3IgKGkgaW4gc2VxX2Fsb25nKGlvX2xpc3RfaW50ZXJhY3Rpb25zKSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIoaW9fbGlzdF9pbnRlcmFjdGlvbnNbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkoaW9fbGlzdF9pbnRlcmFjdGlvbnNbW2ldXSkNCiAgDQogICMgRXh0cmFjdCB0aGUgaW5mbyBJIG5lZWQgZnJvbSB0aGUgc3VtbWFyeQ0KICBtdV9pbnQgPC0gc3VtW1sxXV0NCiAgbXVfc2QgPC0gc3VtW1sxLDJdXQ0KICBzaWdtYV9pbnQgPC0gc3VtW1sxMV1dDQogIHNpZ21hX3NkIDwtIHN1bVtbMTEsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzEyXV0NCiAgc2lnX3RpbWVfc2QgPC0gc3VtW1sxMiwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIGluIGEgZGF0YWZyYW1lDQogIGlvX2ludGVyYWN0aW9uc19kZiA8LSByYmluZChpb19pbnRlcmFjdGlvbnNfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdF9pbnQgPSBtdV9pbnQsIG11X3NkX2ludCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHRfaW50ID0gc2lnbWFfaW50LCBzaWdtYV9zZF9pbnQgPSBzaWdtYV9zZCwgbXVfdGltZV9pbnQgPSBtdV90aW1lLCBtdV90aW1lX3NkX2ludCA9IG11X3RpbWVfc2QsIHNpZ190aW1lX2ludCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9pbnQgPSBzaWdfdGltZV9zZCkpDQp9DQoNCiMgTWVyZ2UgdGhlIHJlc3VsdHMNCmlvX3Jlc3VsdHNfZGYgPC0gbGVmdF9qb2luKGlvX2VtcHR5X2RmLCBpb19wcmVkc19kZikNCmlvX3Jlc3VsdHNfZGYgPC0gbGVmdF9qb2luKGlvX3Jlc3VsdHNfZGYsIGlvX2ludGVyYWN0aW9uc19kZikNCmlvX3Jlc3VsdHNfZGYkZmlyc3RfeWVhciA8LSAyMDIwDQppb19yZXN1bHRzX2RmJG1lYW5feWVhciA8LSAyMDIxDQppb19yZXN1bHRzX2RmJHdhdmVzZXQgPC0gMg0KaW9fcmVzdWx0c19kZiRkYXRhIDwtICJJTyINCg0Kc2F2ZShpb19yZXN1bHRzX2RmLCBmaWxlPSIvVXNlcnMvYW51c2Noa2EvRG9jdW1lbnRzL2NsaW1hdGVjaGFuZ2UvY2xpbWF0ZWNoYW5nZS9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2lvX3Jlc3VsdHNfZGYyX25ldy5SRGF0YSIpDQpgYGANCg0KIyMgSVNTUCB7LX0NCg0KYGBge3J9DQojIE5vdyBmb3IgSVNTUCwgYW5kIHRoZW4gb25seSBmb3IgdGhlIGZpcnN0IHBhcnQgYmMgdGhlIHNlY29uZCBwYXJ0IGFscmVhZHkgY29uc2lzdHMgb2YgMiB3YXZlcw0Kcm0obGlzdD1scygpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUiLCAiaXNzcF9saXN0X2VtcHR5MS5SRGF0YSIpKQ0KDQojIFN0b3JlIHRoZSByZXN1bHRzIGluIGEgbmV3IGRhdGFmcmFtZQ0KaXNzcF9lbXB0eV9kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBMb29wIG92ZXIgdGhlIGxpc3QgZm9yIGFsbCB0aGUgZGVwIHZhcnMNCmZvciAoaSBpbiBzZXFfYWxvbmcoaXNzcF9saXN0X2VtcHR5KSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIoaXNzcF9saXN0X2VtcHR5W1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KGlzc3BfbGlzdF9lbXB0eVtbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvDQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzNdXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzMsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzRdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzQsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBpc3NwX2VtcHR5X2RmIDwtIHJiaW5kKGlzc3BfZW1wdHlfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdCA9IG11X2ludCwgbXVfc2QgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0ID0gc2lnbWFfaW50LCBzaWdtYV9zZCA9IHNpZ21hX3NkLCBtdV90aW1lID0gbXVfdGltZSwgbXVfdGltZV9zZCA9IG11X3RpbWVfc2QsIHNpZ190aW1lID0gc2lnX3RpbWUsIHNpZ190aW1lX3NkID0gc2lnX3RpbWVfc2QpKQ0KfQ0KDQojIFByZWRpY3RvciBtb2RlbCANCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlIiwgImlzc3BfbGlzdF9wcmVkczFfbmV3LlJEYXRhIikpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQppc3NwX3ByZWRzX2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIExvb3Agb3ZlciB0aGUgbGlzdCANCmZvciAoaSBpbiBzZXFfYWxvbmcoaXNzcF9saXN0X3ByZWRzKSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIoaXNzcF9saXN0X3ByZWRzW1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KGlzc3BfbGlzdF9wcmVkc1tbaV1dKQ0KICANCiAgIyBFeHRyYWN0IGluZm8NCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbN11dDQogIHNpZ21hX3NkIDwtIHN1bVtbNywyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbOF1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbOCwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIGluIGEgZGF0YWZyYW1lDQogIGlzc3BfcHJlZHNfZGYgPC0gcmJpbmQoaXNzcF9wcmVkc19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0X3ByZWQgPSBtdV9pbnQsIG11X3NkX3ByZWQgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0X3ByZWQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkX3ByZWQgPSBzaWdtYV9zZCwgbXVfdGltZV9wcmVkID0gbXVfdGltZSwgbXVfdGltZV9zZF9wcmVkID0gbXVfdGltZV9zZCwgc2lnX3RpbWVfcHJlZCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9wcmVkID0gc2lnX3RpbWVfc2QpKQ0KfQ0KDQojIEludGVyYWN0aW9uIG1vZGVsDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZSIsICJpc3NwX2xpc3RfaW50ZXJhY3Rpb25zMV9uZXcuUkRhdGEiKSkNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmlzc3BfaW50ZXJhY3Rpb25zX2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIExvb3Agb3ZlciB0aGUgbnVtYmVyIG9mIGRlcCB2YXJzIGluIHRoZSBsaXN0DQpmb3IgKGkgaW4gc2VxX2Fsb25nKGlzc3BfbGlzdF9pbnRlcmFjdGlvbnMpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3Rlcihpc3NwX2xpc3RfaW50ZXJhY3Rpb25zW1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KGlzc3BfbGlzdF9pbnRlcmFjdGlvbnNbW2ldXSkNCiAgDQogICMgRXh0cmFjdCB0aGUgaW5mbyBJIG5lZWQgZnJvbSB0aGUgc3VtbWFyeQ0KICBtdV9pbnQgPC0gc3VtW1sxXV0NCiAgbXVfc2QgPC0gc3VtW1sxLDJdXQ0KICBzaWdtYV9pbnQgPC0gc3VtW1sxMV1dDQogIHNpZ21hX3NkIDwtIHN1bVtbMTEsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzEyXV0NCiAgc2lnX3RpbWVfc2QgPC0gc3VtW1sxMiwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIGluIGEgZGF0YWZyYW1lDQogIGlzc3BfaW50ZXJhY3Rpb25zX2RmIDwtIHJiaW5kKGlzc3BfaW50ZXJhY3Rpb25zX2RmLCBkYXRhLmZyYW1lKGRlcF92YXIgPSBkZXBfdmFyLCBtdV9pbnRlcmNlcHRfaW50ID0gbXVfaW50LCBtdV9zZF9pbnQgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0X2ludCA9IHNpZ21hX2ludCwgc2lnbWFfc2RfaW50ID0gc2lnbWFfc2QsIG11X3RpbWVfaW50ID0gbXVfdGltZSwgbXVfdGltZV9zZF9pbnQgPSBtdV90aW1lX3NkLCBzaWdfdGltZV9pbnQgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2RfaW50ID0gc2lnX3RpbWVfc2QpKQ0KfQ0KDQojIE1lcmdlIHRoZSByZXN1bHRzDQppc3NwX3Jlc3VsdHNfZGYgPC0gbGVmdF9qb2luKGlzc3BfZW1wdHlfZGYsIGlzc3BfcHJlZHNfZGYpDQppc3NwX3Jlc3VsdHNfZGYgPC0gbGVmdF9qb2luKGlzc3BfcmVzdWx0c19kZiwgaXNzcF9pbnRlcmFjdGlvbnNfZGYpDQppc3NwX3Jlc3VsdHNfZGYkZmlyc3RfeWVhciA8LSAxOTkzDQppc3NwX3Jlc3VsdHNfZGYkbWVhbl95ZWFyIDwtIDE5OTcNCmlzc3BfcmVzdWx0c19kZiR3YXZlc2V0IDwtIDENCmlzc3BfcmVzdWx0c19kZiRkYXRhIDwtICJJU1NQIg0KDQpzYXZlKGlzc3BfcmVzdWx0c19kZiwgZmlsZT0iL1VzZXJzL2FudXNjaGthL0RvY3VtZW50cy9jbGltYXRlY2hhbmdlL2NsaW1hdGVjaGFuZ2UvZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9pc3NwX3Jlc3VsdHNfZGYxX25ldy5SRGF0YSIpDQpgYGANCg0KDQpgYGB7cn0NCiMgQW5kIHRoZSBzZWNvbmQgc2V0DQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZSIsICJpc3NwX2xpc3RfZW1wdHkyLlJEYXRhIikpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQppc3NwX2VtcHR5X2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIExvb3Agb3ZlciB0aGUgbGlzdCBmb3IgYWxsIHRoZSBkZXAgdmFycw0KZm9yIChpIGluIHNlcV9hbG9uZyhpc3NwX2xpc3RfZW1wdHkpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3Rlcihpc3NwX2xpc3RfZW1wdHlbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkoaXNzcF9saXN0X2VtcHR5W1tpXV0pDQogIA0KICAjIEV4dHJhY3QgdGhlIGluZm8NCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbM11dDQogIHNpZ21hX3NkIDwtIHN1bVtbMywyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbNF1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbNCwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIGluIGEgZGF0YWZyYW1lDQogIGlzc3BfZW1wdHlfZGYgPC0gcmJpbmQoaXNzcF9lbXB0eV9kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0ID0gbXVfaW50LCBtdV9zZCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkID0gc2lnbWFfc2QsIG11X3RpbWUgPSBtdV90aW1lLCBtdV90aW1lX3NkID0gbXVfdGltZV9zZCwgc2lnX3RpbWUgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2QgPSBzaWdfdGltZV9zZCkpDQp9DQoNCiNQcmVkaWN0b3IgbW9kZWwNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlIiwgImlzc3BfbGlzdF9wcmVkczJfbmV3LlJEYXRhIikpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQppc3NwX3ByZWRzX2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIExvb3Agb3ZlciB0aGUgbGlzdCANCmZvciAoaSBpbiBzZXFfYWxvbmcoaXNzcF9saXN0X3ByZWRzKSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIoaXNzcF9saXN0X3ByZWRzW1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KGlzc3BfbGlzdF9wcmVkc1tbaV1dKQ0KICANCiAgIyBFeHRyYWN0IGluZm8NCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbN11dDQogIHNpZ21hX3NkIDwtIHN1bVtbNywyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbOF1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbOCwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIGluIGEgZGF0YWZyYW1lDQogIGlzc3BfcHJlZHNfZGYgPC0gcmJpbmQoaXNzcF9wcmVkc19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0X3ByZWQgPSBtdV9pbnQsIG11X3NkX3ByZWQgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0X3ByZWQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkX3ByZWQgPSBzaWdtYV9zZCwgbXVfdGltZV9wcmVkID0gbXVfdGltZSwgbXVfdGltZV9zZF9wcmVkID0gbXVfdGltZV9zZCwgc2lnX3RpbWVfcHJlZCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9wcmVkID0gc2lnX3RpbWVfc2QpKQ0KfQ0KDQojIEludGVyYWN0aW9uIG1vZGVsDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZSIsICJpc3NwX2xpc3RfaW50ZXJhY3Rpb25zMl9uZXcuUkRhdGEiKSkNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmlzc3BfaW50ZXJhY3Rpb25zX2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIExvb3Agb3ZlciB0aGUgbnVtYmVyIG9mIGRlcCB2YXJzIGluIHRoZSBsaXN0DQpmb3IgKGkgaW4gc2VxX2Fsb25nKGlzc3BfbGlzdF9pbnRlcmFjdGlvbnMpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3Rlcihpc3NwX2xpc3RfaW50ZXJhY3Rpb25zW1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KGlzc3BfbGlzdF9pbnRlcmFjdGlvbnNbW2ldXSkNCiAgDQogICMgRXh0cmFjdCB0aGUgaW5mbyBJIG5lZWQgZnJvbSB0aGUgc3VtbWFyeQ0KICBtdV9pbnQgPC0gc3VtW1sxXV0NCiAgbXVfc2QgPC0gc3VtW1sxLDJdXQ0KICBzaWdtYV9pbnQgPC0gc3VtW1sxMV1dDQogIHNpZ21hX3NkIDwtIHN1bVtbMTEsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzEyXV0NCiAgc2lnX3RpbWVfc2QgPC0gc3VtW1sxMiwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIGluIGEgZGF0YWZyYW1lDQogIGlzc3BfaW50ZXJhY3Rpb25zX2RmIDwtIHJiaW5kKGlzc3BfaW50ZXJhY3Rpb25zX2RmLCBkYXRhLmZyYW1lKGRlcF92YXIgPSBkZXBfdmFyLCBtdV9pbnRlcmNlcHRfaW50ID0gbXVfaW50LCBtdV9zZF9pbnQgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0X2ludCA9IHNpZ21hX2ludCwgc2lnbWFfc2RfaW50ID0gc2lnbWFfc2QsIG11X3RpbWVfaW50ID0gbXVfdGltZSwgbXVfdGltZV9zZF9pbnQgPSBtdV90aW1lX3NkLCBzaWdfdGltZV9pbnQgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2RfaW50ID0gc2lnX3RpbWVfc2QpKQ0KfQ0KDQojIE1lcmdlIHRoZSByZXN1bHRzDQppc3NwX3Jlc3VsdHNfZGYgPC0gbGVmdF9qb2luKGlzc3BfZW1wdHlfZGYsIGlzc3BfcHJlZHNfZGYpDQppc3NwX3Jlc3VsdHNfZGYgPC0gbGVmdF9qb2luKGlzc3BfcmVzdWx0c19kZiwgaXNzcF9pbnRlcmFjdGlvbnNfZGYpDQppc3NwX3Jlc3VsdHNfZGYkZmlyc3RfeWVhciA8LSAyMDAwDQppc3NwX3Jlc3VsdHNfZGYkbWVhbl95ZWFyIDwtIDIwMDUNCmlzc3BfcmVzdWx0c19kZiR3YXZlc2V0IDwtIDINCmlzc3BfcmVzdWx0c19kZiRkYXRhIDwtICJJU1NQIg0KDQpzYXZlKGlzc3BfcmVzdWx0c19kZiwgZmlsZT0iL1VzZXJzL2FudXNjaGthL0RvY3VtZW50cy9jbGltYXRlY2hhbmdlL2NsaW1hdGVjaGFuZ2UvZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9pc3NwX3Jlc3VsdHNfZGYyX25ldy5SRGF0YSIpDQpgYGANCg0KIyMgRUIgey19DQoNCmBgYHtyfQ0KIyBGb3IgYWxsIHRoZSBldXJvYmFyb21ldGVyIHdhdmVzLCBleGFjdGx5IHRoZSBzYW1lIG5lZWRzIHRvIGJlIGRvbmUgZWFjaCB0aW1lLiBUaGVyZWZvcmUgSSB3YW50IHRvIGxvb3Agb3ZlciB0aGVzZSBkaWZmZXJlbnQgbGlzdHMuIA0KDQojIEZpcnN0IGxvYWQgYWxsIHRoZSBldXJvYmFyb21ldGVyIGxpc3RzIHdpdGggZW1wdHkgbW9kZWxzIGluIG15IGVudmlyb25tZW50DQpybShsaXN0PWxzKCkpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZSIsICJlYl9saXN0X2VtcHR5XzE5ODZfMS5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9lbXB0eV8yMDA3XzEuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfZW1wdHlfMjAwOV8xLlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X2VtcHR5XzIwMTFfdy5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9lbXB0eV9idXlwcm9kMS5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9lbXB0eV9jY2hhbmdlMl8xLlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X2VtcHR5X2RvcHJvdDEuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfZW1wdHlfZWZmX2RhaWx5MS5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9lbXB0eV9wZXJzX2ltcDEuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfZW1wdHlfcHJzYWN0aW9uMS5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUiLCAiZWJfbGlzdF9lbXB0eV9xdWFsbGlmZTEuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfZW1wdHlfZG9wcm90X2NpdHlfdy5SRGF0YSIpKQ0KDQojIFN0b3JlIHRoZSByZXN1bHRzIGluIGEgbmV3IGRhdGFmcmFtZQ0KZWJfcmVzdWx0c19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBHZXQgdGhlIGxpc3RzIGZyb20gdGhlIGVudmlyb25tZW50DQpsaXN0cyA8LSBscygpDQoNCmZvciAoaiBpbiBsaXN0cykgeyANCiAgaWYoaXMubGlzdChnZXQoaikpKSB7IA0KICAgIG15X2xpc3QgPC0gZ2V0KGopDQoNCiMgTG9vcCBvdmVyIHRoZSBsaXN0IGZvciBhbGwgdGhlIGRlcCB2YXJzDQpmb3IgKGkgaW4gc2VxX2Fsb25nKG15X2xpc3QpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3RlcihteV9saXN0W1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KG15X2xpc3RbW2ldXSkNCiAgDQogICMgRXh0cmFjdCB0aGUgaW5mbw0KICBtdV9pbnQgPC0gc3VtW1sxXV0NCiAgbXVfc2QgPC0gc3VtW1sxLDJdXQ0KICBzaWdtYV9pbnQgPC0gc3VtW1szXV0NCiAgc2lnbWFfc2QgPC0gc3VtW1szLDJdXQ0KICBtdV90aW1lIDwtIHN1bSBbWzJdXQ0KICBtdV90aW1lX3NkIDwtIHN1bVtbMiwyXV0NCiAgc2lnX3RpbWUgPC0gc3VtW1s0XV0NCiAgc2lnX3RpbWVfc2QgPC0gc3VtW1s0LDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgZWJfcmVzdWx0c19kZiA8LSByYmluZChlYl9yZXN1bHRzX2RmLCBkYXRhLmZyYW1lKGRlcF92YXIgPSBkZXBfdmFyLCBtdV9pbnRlcmNlcHQgPSBtdV9pbnQsIG11X3NkID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdCA9IHNpZ21hX2ludCwgc2lnbWFfc2QgPSBzaWdtYV9zZCwgbXVfdGltZSA9IG11X3RpbWUsIG11X3RpbWVfc2QgPSBtdV90aW1lX3NkLCBzaWdfdGltZSA9IHNpZ190aW1lLCBzaWdfdGltZV9zZCA9IHNpZ190aW1lX3NkKSkNCiAgICB9DQogIH0gDQp9IA0KDQojIEl0IHByb2R1Y2VzIGFuIGVycm9yLCBidXQgYWN0dWFsbHkgZXZlcnl0aGluZyBoYXMgd29ya2VkIGFzIGkgd2lzaA0KZWJfcmVzdWx0c19lbXB0eV9kZiA8LSBlYl9yZXN1bHRzX2RmDQplYl9yZXN1bHRzX2VtcHR5X2RmJHdhdmVzZXQgPC0gMQ0KDQojIFNhdmUgaXQNCnNhdmUoZWJfcmVzdWx0c19lbXB0eV9kZiwgZmlsZT0gIi9Vc2Vycy9hbnVzY2hrYS9Eb2N1bWVudHMvY2xpbWF0ZWNoYW5nZS9jbGltYXRlY2hhbmdlL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZWJfcmVzdWx0c19lbXB0eV9kZjFfbmV3LlJEYXRhIiApDQpgYGANCg0KDQpgYGB7cn0NCiMgU2Vjb25kIHNldA0KIyBGaXJzdCBsb2FkIGFsbCB0aGUgZXVyb2Jhcm9tZXRlciBsaXN0cyB3aXRoIGVtcHR5IG1vZGVscyBpbiBteSBlbnZpcm9ubWVudA0Kcm0obGlzdD1scygpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUiLCAiZWJfbGlzdF9lbXB0eV8xOTg2XzIuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfZW1wdHlfMjAwN18yLlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X2VtcHR5XzIwMDlfMi5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9lbXB0eV9idXlwcm9kMi5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9lbXB0eV9jY2hhbmdlMl8yLlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X2VtcHR5X2RvcHJvdDIuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfZW1wdHlfZWZmX2RhaWx5Mi5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9lbXB0eV9wZXJzX2ltcDIuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfZW1wdHlfcHJzYWN0aW9uMi5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUiLCAiZWJfbGlzdF9lbXB0eV9xdWFsbGlmZTIuUkRhdGEiKSkNCg0KDQojIFN0b3JlIHRoZSByZXN1bHRzIGluIGEgbmV3IGRhdGFmcmFtZQ0KZWJfcmVzdWx0c19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBHZXQgdGhlIGxpc3RzIGZyb20gdGhlIGVudmlyb25tZW50DQpsaXN0cyA8LSBscygpDQoNCmZvciAoaiBpbiBsaXN0cykgeyANCiAgaWYoaXMubGlzdChnZXQoaikpKSB7IA0KICAgIG15X2xpc3QgPC0gZ2V0KGopDQoNCiMgTG9vcCBvdmVyIHRoZSBsaXN0IGZvciBhbGwgdGhlIGRlcCB2YXJzDQpmb3IgKGkgaW4gc2VxX2Fsb25nKG15X2xpc3QpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3RlcihteV9saXN0W1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KG15X2xpc3RbW2ldXSkNCiAgDQogICMgRXh0cmFjdCB0aGUgaW5mbw0KICBtdV9pbnQgPC0gc3VtW1sxXV0NCiAgbXVfc2QgPC0gc3VtW1sxLDJdXQ0KICBzaWdtYV9pbnQgPC0gc3VtW1szXV0NCiAgc2lnbWFfc2QgPC0gc3VtW1szLDJdXQ0KICBtdV90aW1lIDwtIHN1bSBbWzJdXQ0KICBtdV90aW1lX3NkIDwtIHN1bVtbMiwyXV0NCiAgc2lnX3RpbWUgPC0gc3VtW1s0XV0NCiAgc2lnX3RpbWVfc2QgPC0gc3VtW1s0LDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgZWJfcmVzdWx0c19kZiA8LSByYmluZChlYl9yZXN1bHRzX2RmLCBkYXRhLmZyYW1lKGRlcF92YXIgPSBkZXBfdmFyLCBtdV9pbnRlcmNlcHQgPSBtdV9pbnQsIG11X3NkID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdCA9IHNpZ21hX2ludCwgc2lnbWFfc2QgPSBzaWdtYV9zZCwgbXVfdGltZSA9IG11X3RpbWUsIG11X3RpbWVfc2QgPSBtdV90aW1lX3NkLCBzaWdfdGltZSA9IHNpZ190aW1lLCBzaWdfdGltZV9zZCA9IHNpZ190aW1lX3NkKSkNCiAgICB9DQogIH0gDQp9IA0KDQojIEl0IHByb2R1Y2VzIGFuIGVycm9yLCBidXQgYWN0dWFsbHkgZXZlcnl0aGluZyBoYXMgd29ya2VkIA0KZWJfcmVzdWx0c19lbXB0eV9kZiA8LSBlYl9yZXN1bHRzX2RmDQplYl9yZXN1bHRzX2VtcHR5X2RmJHdhdmVzZXQgPC0gMg0KDQpzYXZlKGViX3Jlc3VsdHNfZW1wdHlfZGYsIGZpbGU9ICIvVXNlcnMvYW51c2Noa2EvRG9jdW1lbnRzL2NsaW1hdGVjaGFuZ2UvY2xpbWF0ZWNoYW5nZS9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2ViX3Jlc3VsdHNfZW1wdHlfZGYyX25ldy5SRGF0YSIgKQ0KYGBgDQoNCg0KYGBge3J9DQojIFNvbWUgb2YgdGhlbSBoYXZlIGEgdGhpcmQgc2V0DQpybShsaXN0PWxzKCkpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X2VtcHR5XzIwMDdfMy5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9lbXB0eV8yMDA5XzMuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfZW1wdHlfY2NoYW5nZTJfMy5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9lbXB0eV9lZmZfZGFpbHkzLlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X2VtcHR5X3Byc2FjdGlvbjMuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlIiwgImViX2xpc3RfZW1wdHlfcXVhbGxpZmUzLlJEYXRhIikpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQplYl9yZXN1bHRzX2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIEdldCB0aGUgbGlzdHMgZnJvbSB0aGUgZW52aXJvbm1lbnQNCmxpc3RzIDwtIGxzKCkNCg0KZm9yIChqIGluIGxpc3RzKSB7IA0KICBpZihpcy5saXN0KGdldChqKSkpIHsgDQogICAgbXlfbGlzdCA8LSBnZXQoaikNCg0KIyBMb29wIG92ZXIgdGhlIGxpc3QgZm9yIGFsbCB0aGUgZGVwIHZhcnMNCmZvciAoaSBpbiBzZXFfYWxvbmcobXlfbGlzdCkpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKG15X2xpc3RbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkobXlfbGlzdFtbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvDQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzNdXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzMsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzRdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzQsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBlYl9yZXN1bHRzX2RmIDwtIHJiaW5kKGViX3Jlc3VsdHNfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdCA9IG11X2ludCwgbXVfc2QgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0ID0gc2lnbWFfaW50LCBzaWdtYV9zZCA9IHNpZ21hX3NkLCBtdV90aW1lID0gbXVfdGltZSwgbXVfdGltZV9zZCA9IG11X3RpbWVfc2QsIHNpZ190aW1lID0gc2lnX3RpbWUsIHNpZ190aW1lX3NkID0gc2lnX3RpbWVfc2QpKQ0KICAgIH0NCiAgfSANCn0gDQoNCiMgSXQgcHJvZHVjZXMgYW4gZXJyb3IsIGJ1dCBhY3R1YWxseSBldmVyeXRoaW5nIGhhcyB3b3JrZWQgDQplYl9yZXN1bHRzX2VtcHR5X2RmIDwtIGViX3Jlc3VsdHNfZGYNCmViX3Jlc3VsdHNfZW1wdHlfZGYkd2F2ZXNldCA8LSAzDQoNCnNhdmUoZWJfcmVzdWx0c19lbXB0eV9kZiwgZmlsZT0gIi9Vc2Vycy9hbnVzY2hrYS9Eb2N1bWVudHMvY2xpbWF0ZWNoYW5nZS9jbGltYXRlY2hhbmdlL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZWJfcmVzdWx0c19lbXB0eV9kZjNfbmV3LlJEYXRhIiApDQpgYGANCg0KDQpgYGB7cn0NCiMgU29tZSBldmVuIGEgZm91cnRoIHRpbWUNCnJtKGxpc3Q9bHMoKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfZW1wdHlfMjAwOV80LlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X2VtcHR5X2NjaGFuZ2UyXzQuUkRhdGEiKSkNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmViX3Jlc3VsdHNfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCiMgR2V0IHRoZSBsaXN0cyBmcm9tIHRoZSBlbnZpcm9ubWVudA0KbGlzdHMgPC0gbHMoKQ0KDQpmb3IgKGogaW4gbGlzdHMpIHsgDQogIGlmKGlzLmxpc3QoZ2V0KGopKSkgeyANCiAgICBteV9saXN0IDwtIGdldChqKQ0KDQojIExvb3Agb3ZlciB0aGUgbGlzdCBmb3IgYWxsIHRoZSBkZXAgdmFycw0KZm9yIChpIGluIHNlcV9hbG9uZyhteV9saXN0KSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIobXlfbGlzdFtbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShteV9saXN0W1tpXV0pDQogIA0KICAjIEV4dHJhY3QgdGhlIGluZm8NCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbM11dDQogIHNpZ21hX3NkIDwtIHN1bVtbMywyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbNF1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbNCwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIGluIGEgZGF0YWZyYW1lDQogIGViX3Jlc3VsdHNfZGYgPC0gcmJpbmQoZWJfcmVzdWx0c19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0ID0gbXVfaW50LCBtdV9zZCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkID0gc2lnbWFfc2QsIG11X3RpbWUgPSBtdV90aW1lLCBtdV90aW1lX3NkID0gbXVfdGltZV9zZCwgc2lnX3RpbWUgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2QgPSBzaWdfdGltZV9zZCkpDQogICAgfQ0KICB9IA0KfSANCg0KIyBJdCBwcm9kdWNlcyBhbiBlcnJvciwgYnV0IGFjdHVhbGx5IGV2ZXJ5dGhpbmcgaGFzIHdvcmtlZCANCmViX3Jlc3VsdHNfZW1wdHlfZGYgPC0gZWJfcmVzdWx0c19kZg0KZWJfcmVzdWx0c19lbXB0eV9kZiR3YXZlc2V0IDwtIDQNCg0Kc2F2ZShlYl9yZXN1bHRzX2VtcHR5X2RmLCBmaWxlPSAiL1VzZXJzL2FudXNjaGthL0RvY3VtZW50cy9jbGltYXRlY2hhbmdlL2NsaW1hdGVjaGFuZ2UvZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9lYl9yZXN1bHRzX2VtcHR5X2RmNF9uZXcuUkRhdGEiICkNCmBgYA0KDQoNCmBgYHtyfQ0KIyBBbmQgYSBmaWZ0aCB0aW1lDQpybShsaXN0PWxzKCkpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X2VtcHR5XzIwMDlfNS5SRGF0YSIpKQ0KDQojIFN0b3JlIHRoZSByZXN1bHRzIGluIGEgbmV3IGRhdGFmcmFtZQ0KZWJfcmVzdWx0c19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBHZXQgdGhlIGxpc3RzIGZyb20gdGhlIGVudmlyb25tZW50DQpsaXN0cyA8LSBscygpDQoNCmZvciAoaiBpbiBsaXN0cykgeyANCiAgaWYoaXMubGlzdChnZXQoaikpKSB7IA0KICAgIG15X2xpc3QgPC0gZ2V0KGopDQoNCiMgTG9vcCBvdmVyIHRoZSBsaXN0IGZvciBhbGwgdGhlIGRlcCB2YXJzDQpmb3IgKGkgaW4gc2VxX2Fsb25nKG15X2xpc3QpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3RlcihteV9saXN0W1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KG15X2xpc3RbW2ldXSkNCiAgDQogICMgRXh0cmFjdCB0aGUgaW5mbw0KICBtdV9pbnQgPC0gc3VtW1sxXV0NCiAgbXVfc2QgPC0gc3VtW1sxLDJdXQ0KICBzaWdtYV9pbnQgPC0gc3VtW1szXV0NCiAgc2lnbWFfc2QgPC0gc3VtW1szLDJdXQ0KICBtdV90aW1lIDwtIHN1bSBbWzJdXQ0KICBtdV90aW1lX3NkIDwtIHN1bVtbMiwyXV0NCiAgc2lnX3RpbWUgPC0gc3VtW1s0XV0NCiAgc2lnX3RpbWVfc2QgPC0gc3VtW1s0LDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgZWJfcmVzdWx0c19kZiA8LSByYmluZChlYl9yZXN1bHRzX2RmLCBkYXRhLmZyYW1lKGRlcF92YXIgPSBkZXBfdmFyLCBtdV9pbnRlcmNlcHQgPSBtdV9pbnQsIG11X3NkID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdCA9IHNpZ21hX2ludCwgc2lnbWFfc2QgPSBzaWdtYV9zZCwgbXVfdGltZSA9IG11X3RpbWUsIG11X3RpbWVfc2QgPSBtdV90aW1lX3NkLCBzaWdfdGltZSA9IHNpZ190aW1lLCBzaWdfdGltZV9zZCA9IHNpZ190aW1lX3NkKSkNCiAgICB9DQogIH0gDQp9IA0KDQojIEl0IHByb2R1Y2VzIGFuIGVycm9yLCBidXQgYWN0dWFsbHkgZXZlcnl0aGluZyBoYXMgd29ya2VkIA0KZWJfcmVzdWx0c19lbXB0eV9kZiA8LSBlYl9yZXN1bHRzX2RmDQplYl9yZXN1bHRzX2VtcHR5X2RmJHdhdmVzZXQgPC0gNQ0KDQpzYXZlKGViX3Jlc3VsdHNfZW1wdHlfZGYsIGZpbGU9ICIvVXNlcnMvYW51c2Noa2EvRG9jdW1lbnRzL2NsaW1hdGVjaGFuZ2UvY2xpbWF0ZWNoYW5nZS9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2ViX3Jlc3VsdHNfZW1wdHlfZGY1X25ldy5SRGF0YSIgKQ0KYGBgDQoNCg0KYGBge3J9DQojIE5vdyBpIHdhbnQgdGhlIHNhbWUgZm9yIHRoZSBtb2RlbHMgd2l0aCB0aGUgcHJlZGljdG9ycw0KIyBGaXJzdCBjbGVhciB0aGUgZW52aXJvbm1lbnQgYmVjYXVzZSBJIGRvbid0IHdhbnQgdGhlIGVtcHR5IGxpc3RzIGl0ZXJhdGVkIGluIHRoZSBwcmVkaWN0b3IgbG9vcA0Kcm0obGlzdD1scygpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUiLCAiZWJfbGlzdF9wcmVkc18xOTg2XzFfbmV3LlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X3ByZWRzXzIwMDdfMV9uZXcuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfcHJlZHNfMjAwOF93X25ldy5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9wcmVkc18yMDA5XzFfbmV3LlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X3ByZWRzXzIwMTFfd19uZXcuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfcHJlZHNfYnV5cHJvZDFfbmV3LlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X3ByZWRzX2NjaGFuZ2UyXzFfbmV3LlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X3ByZWRzX2RvcHJvdDFfbmV3LlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X3ByZWRzX2VmZl9kYWlseTFfbmV3LlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X3ByZWRzX3BlcnNfaW1wMV9uZXcuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfcHJlZHNfcHJzYWN0aW9uMV9uZXcuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlIiwgImViX2xpc3RfcHJlZHNfcXVhbGxpZmUxX25ldy5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9wcmVkc19kb3Byb3RfY2l0eV93X25ldy5SRGF0YSIpKQ0KDQojIFN0b3JlIHRoZSByZXN1bHRzIGluIGEgbmV3IGRhdGFmcmFtZQ0KZWJfcmVzdWx0c19wcmVkc19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBHZXQgdGhlIGxpc3RzIGZyb20gdGhlIGVudmlyb25tZW50DQpsaXN0cyA8LSBscygpDQoNCmZvciAoaiBpbiBsaXN0cykgeyANCiAgaWYoaXMubGlzdChnZXQoaikpKSB7IA0KICAgIG15X2xpc3QgPC0gZ2V0KGopDQoNCiMgTG9vcCBvdmVyIHRoZSBsaXN0IA0KZm9yIChpIGluIHNlcV9hbG9uZyhteV9saXN0KSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIobXlfbGlzdFtbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShteV9saXN0W1tpXV0pDQogIA0KICAjIEV4dHJhY3QgaW5mbw0KICBtdV9pbnQgPC0gc3VtW1sxXV0NCiAgbXVfc2QgPC0gc3VtW1sxLDJdXQ0KICBzaWdtYV9pbnQgPC0gc3VtW1s3XV0NCiAgc2lnbWFfc2QgPC0gc3VtW1s3LDJdXQ0KICBtdV90aW1lIDwtIHN1bSBbWzJdXQ0KICBtdV90aW1lX3NkIDwtIHN1bVtbMiwyXV0NCiAgc2lnX3RpbWUgPC0gc3VtW1s4XV0NCiAgc2lnX3RpbWVfc2QgPC0gc3VtW1s4LDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgZWJfcmVzdWx0c19wcmVkc19kZiA8LSByYmluZChlYl9yZXN1bHRzX3ByZWRzX2RmLCBkYXRhLmZyYW1lKGRlcF92YXIgPSBkZXBfdmFyLCBtdV9pbnRlcmNlcHRfcHJlZCA9IG11X2ludCwgbXVfc2RfcHJlZCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHRfcHJlZCA9IHNpZ21hX2ludCwgc2lnbWFfc2RfcHJlZCA9IHNpZ21hX3NkLCBtdV90aW1lX3ByZWQgPSBtdV90aW1lLCBtdV90aW1lX3NkX3ByZWQgPSBtdV90aW1lX3NkLCBzaWdfdGltZV9wcmVkID0gc2lnX3RpbWUsIHNpZ190aW1lX3NkX3ByZWQgPSBzaWdfdGltZV9zZCkpDQogICAgfQ0KICB9DQp9IA0KDQplYl9yZXN1bHRzX3ByZWRzX2RmJHdhdmVzZXQgPC0gMQ0KDQojIEFnYWluLCBhbiBlcnJvciwgYnV0IHRoZSBvdXRwdXQgaXMgY29ycmVjdA0Kc2F2ZShlYl9yZXN1bHRzX3ByZWRzX2RmLCBmaWxlPSAiL1VzZXJzL2FudXNjaGthL0RvY3VtZW50cy9jbGltYXRlY2hhbmdlL2NsaW1hdGVjaGFuZ2UvZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9lYl9yZXN1bHRzX3ByZWRzX2RmMV9uZXcuUkRhdGEiICkNCmBgYA0KDQoNCmBgYHtyfQ0KIyBTZWNvbmQgc2V0DQpybShsaXN0PWxzKCkpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZSIsICJlYl9saXN0X3ByZWRzXzE5ODZfMl9uZXcuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfcHJlZHNfMjAwN18yX25ldy5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9wcmVkc18yMDA5XzJfbmV3LlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X3ByZWRzX2J1eXByb2QyX25ldy5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9wcmVkc19jY2hhbmdlMl8yX25ldy5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9wcmVkc19kb3Byb3QyX25ldy5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9wcmVkc19lZmZfZGFpbHkyX25ldy5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9wcmVkc19wZXJzX2ltcDJfbmV3LlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X3ByZWRzX3Byc2FjdGlvbjJfbmV3LlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZSIsICJlYl9saXN0X3ByZWRzX3F1YWxsaWZlMl9uZXcuUkRhdGEiKSkNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmViX3Jlc3VsdHNfcHJlZHNfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCiMgR2V0IHRoZSBsaXN0cyBmcm9tIHRoZSBlbnZpcm9ubWVudA0KbGlzdHMgPC0gbHMoKQ0KDQpmb3IgKGogaW4gbGlzdHMpIHsgDQogIGlmKGlzLmxpc3QoZ2V0KGopKSkgeyANCiAgICBteV9saXN0IDwtIGdldChqKQ0KDQojIExvb3Agb3ZlciB0aGUgbGlzdCANCmZvciAoaSBpbiBzZXFfYWxvbmcobXlfbGlzdCkpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKG15X2xpc3RbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkobXlfbGlzdFtbaV1dKQ0KICANCiAgIyBFeHRyYWN0IGluZm8NCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbN11dDQogIHNpZ21hX3NkIDwtIHN1bVtbNywyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbOF1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbOCwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIGluIGEgZGF0YWZyYW1lDQogIGViX3Jlc3VsdHNfcHJlZHNfZGYgPC0gcmJpbmQoZWJfcmVzdWx0c19wcmVkc19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0X3ByZWQgPSBtdV9pbnQsIG11X3NkX3ByZWQgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0X3ByZWQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkX3ByZWQgPSBzaWdtYV9zZCwgbXVfdGltZV9wcmVkID0gbXVfdGltZSwgbXVfdGltZV9zZF9wcmVkID0gbXVfdGltZV9zZCwgc2lnX3RpbWVfcHJlZCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9wcmVkID0gc2lnX3RpbWVfc2QpKQ0KICAgIH0NCiAgfQ0KfSANCg0KZWJfcmVzdWx0c19wcmVkc19kZiR3YXZlc2V0IDwtIDINCg0KIyBBZ2FpbiwgYW4gZXJyb3IsIGJ1dCB0aGUgb3V0cHV0IGlzIGNvcnJlY3QNCnNhdmUoZWJfcmVzdWx0c19wcmVkc19kZiwgZmlsZT0gIi9Vc2Vycy9hbnVzY2hrYS9Eb2N1bWVudHMvY2xpbWF0ZWNoYW5nZS9jbGltYXRlY2hhbmdlL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZWJfcmVzdWx0c19wcmVkc19kZjJfbmV3LlJEYXRhIiApDQpgYGANCg0KDQpgYGB7cn0NCiMgVGhpcmQgc2V0DQpybShsaXN0PWxzKCkpDQoNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfcHJlZHNfMjAwN18zX25ldy5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9wcmVkc18yMDA5XzNfbmV3LlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X3ByZWRzX2NjaGFuZ2UyXzNfbmV3LlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X3ByZWRzX2VmZl9kYWlseTNfbmV3LlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X3ByZWRzX3Byc2FjdGlvbjNfbmV3LlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZSIsICJlYl9saXN0X3ByZWRzX3F1YWxsaWZlM19uZXcuUkRhdGEiKSkNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmViX3Jlc3VsdHNfcHJlZHNfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCiMgR2V0IHRoZSBsaXN0cyBmcm9tIHRoZSBlbnZpcm9ubWVudA0KbGlzdHMgPC0gbHMoKQ0KDQpmb3IgKGogaW4gbGlzdHMpIHsgDQogIGlmKGlzLmxpc3QoZ2V0KGopKSkgeyANCiAgICBteV9saXN0IDwtIGdldChqKQ0KDQojIExvb3Agb3ZlciB0aGUgbGlzdCANCmZvciAoaSBpbiBzZXFfYWxvbmcobXlfbGlzdCkpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKG15X2xpc3RbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkobXlfbGlzdFtbaV1dKQ0KICANCiAgIyBFeHRyYWN0IGluZm8NCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbN11dDQogIHNpZ21hX3NkIDwtIHN1bVtbNywyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbOF1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbOCwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIGluIGEgZGF0YWZyYW1lDQogIGViX3Jlc3VsdHNfcHJlZHNfZGYgPC0gcmJpbmQoZWJfcmVzdWx0c19wcmVkc19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0X3ByZWQgPSBtdV9pbnQsIG11X3NkX3ByZWQgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0X3ByZWQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkX3ByZWQgPSBzaWdtYV9zZCwgbXVfdGltZV9wcmVkID0gbXVfdGltZSwgbXVfdGltZV9zZF9wcmVkID0gbXVfdGltZV9zZCwgc2lnX3RpbWVfcHJlZCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9wcmVkID0gc2lnX3RpbWVfc2QpKQ0KICAgIH0NCiAgfQ0KfSANCg0KZWJfcmVzdWx0c19wcmVkc19kZiR3YXZlc2V0IDwtIDMNCg0KIyBBZ2FpbiwgYW4gZXJyb3IsIGJ1dCB0aGUgb3V0cHV0IGlzIGNvcnJlY3QNCnNhdmUoZWJfcmVzdWx0c19wcmVkc19kZiwgZmlsZT0gIi9Vc2Vycy9hbnVzY2hrYS9Eb2N1bWVudHMvY2xpbWF0ZWNoYW5nZS9jbGltYXRlY2hhbmdlL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZWJfcmVzdWx0c19wcmVkc19kZjNfbmV3LlJEYXRhIiApDQpgYGANCg0KDQpgYGB7cn0NCiMgRm91cnRoIHNldA0Kcm0obGlzdD1scygpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9wcmVkc18yMDA5XzRfbmV3LlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X3ByZWRzX2NjaGFuZ2UyXzRfbmV3LlJEYXRhIikpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQplYl9yZXN1bHRzX3ByZWRzX2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIEdldCB0aGUgbGlzdHMgZnJvbSB0aGUgZW52aXJvbm1lbnQNCmxpc3RzIDwtIGxzKCkNCg0KZm9yIChqIGluIGxpc3RzKSB7IA0KICBpZihpcy5saXN0KGdldChqKSkpIHsgDQogICAgbXlfbGlzdCA8LSBnZXQoaikNCg0KIyBMb29wIG92ZXIgdGhlIGxpc3QgDQpmb3IgKGkgaW4gc2VxX2Fsb25nKG15X2xpc3QpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3RlcihteV9saXN0W1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KG15X2xpc3RbW2ldXSkNCiAgDQogICMgRXh0cmFjdCBpbmZvDQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzddXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzcsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzhdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzgsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBlYl9yZXN1bHRzX3ByZWRzX2RmIDwtIHJiaW5kKGViX3Jlc3VsdHNfcHJlZHNfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdF9wcmVkID0gbXVfaW50LCBtdV9zZF9wcmVkID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdF9wcmVkID0gc2lnbWFfaW50LCBzaWdtYV9zZF9wcmVkID0gc2lnbWFfc2QsIG11X3RpbWVfcHJlZCA9IG11X3RpbWUsIG11X3RpbWVfc2RfcHJlZCA9IG11X3RpbWVfc2QsIHNpZ190aW1lX3ByZWQgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2RfcHJlZCA9IHNpZ190aW1lX3NkKSkNCiAgICB9DQogIH0NCn0gDQoNCmViX3Jlc3VsdHNfcHJlZHNfZGYkd2F2ZXNldCA8LSA0DQoNCiMgQWdhaW4sIGFuIGVycm9yLCBidXQgdGhlIG91dHB1dCBpcyBjb3JyZWN0DQpzYXZlKGViX3Jlc3VsdHNfcHJlZHNfZGYsIGZpbGU9ICIvVXNlcnMvYW51c2Noa2EvRG9jdW1lbnRzL2NsaW1hdGVjaGFuZ2UvY2xpbWF0ZWNoYW5nZS9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2ViX3Jlc3VsdHNfcHJlZHNfZGY0X25ldy5SRGF0YSIgKQ0KYGBgDQoNCg0KYGBge3J9DQojIEFuZCBmaW5hbGx5IHRoZSBmaWZ0aCANCnJtKGxpc3Q9bHMoKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfcHJlZHNfMjAwOV81X25ldy5SRGF0YSIpKQ0KDQojIFN0b3JlIHRoZSByZXN1bHRzIGluIGEgbmV3IGRhdGFmcmFtZQ0KZWJfcmVzdWx0c19wcmVkc19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBHZXQgdGhlIGxpc3RzIGZyb20gdGhlIGVudmlyb25tZW50DQpsaXN0cyA8LSBscygpDQoNCmZvciAoaiBpbiBsaXN0cykgeyANCiAgaWYoaXMubGlzdChnZXQoaikpKSB7IA0KICAgIG15X2xpc3QgPC0gZ2V0KGopDQoNCiMgTG9vcCBvdmVyIHRoZSBsaXN0IA0KZm9yIChpIGluIHNlcV9hbG9uZyhteV9saXN0KSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIobXlfbGlzdFtbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShteV9saXN0W1tpXV0pDQogIA0KICAjIEV4dHJhY3QgaW5mbw0KICBtdV9pbnQgPC0gc3VtW1sxXV0NCiAgbXVfc2QgPC0gc3VtW1sxLDJdXQ0KICBzaWdtYV9pbnQgPC0gc3VtW1s3XV0NCiAgc2lnbWFfc2QgPC0gc3VtW1s3LDJdXQ0KICBtdV90aW1lIDwtIHN1bSBbWzJdXQ0KICBtdV90aW1lX3NkIDwtIHN1bVtbMiwyXV0NCiAgc2lnX3RpbWUgPC0gc3VtW1s4XV0NCiAgc2lnX3RpbWVfc2QgPC0gc3VtW1s4LDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgZWJfcmVzdWx0c19wcmVkc19kZiA8LSByYmluZChlYl9yZXN1bHRzX3ByZWRzX2RmLCBkYXRhLmZyYW1lKGRlcF92YXIgPSBkZXBfdmFyLCBtdV9pbnRlcmNlcHRfcHJlZCA9IG11X2ludCwgbXVfc2RfcHJlZCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHRfcHJlZCA9IHNpZ21hX2ludCwgc2lnbWFfc2RfcHJlZCA9IHNpZ21hX3NkLCBtdV90aW1lX3ByZWQgPSBtdV90aW1lLCBtdV90aW1lX3NkX3ByZWQgPSBtdV90aW1lX3NkLCBzaWdfdGltZV9wcmVkID0gc2lnX3RpbWUsIHNpZ190aW1lX3NkX3ByZWQgPSBzaWdfdGltZV9zZCkpDQogICAgfQ0KICB9DQp9IA0KDQplYl9yZXN1bHRzX3ByZWRzX2RmJHdhdmVzZXQgPC0gNQ0KDQojIEFnYWluLCBhbiBlcnJvciwgYnV0IHRoZSBvdXRwdXQgaXMgY29ycmVjdA0Kc2F2ZShlYl9yZXN1bHRzX3ByZWRzX2RmLCBmaWxlPSAiL1VzZXJzL2FudXNjaGthL0RvY3VtZW50cy9jbGltYXRlY2hhbmdlL2NsaW1hdGVjaGFuZ2UvZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9lYl9yZXN1bHRzX3ByZWRzX2RmNV9uZXcuUkRhdGEiICkNCmBgYA0KDQoNCmBgYHtyfQ0KIyBMYXN0bHkgZm9yIHRoZSBpbnRlcmFjdGlvbiBtb2RlbHMNCnJtKGxpc3Q9bHMoKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfaW50ZXJhY3Rpb25zXzE5ODZfMV9uZXcuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfaW50ZXJhY3Rpb25zXzIwMDdfMV9uZXcuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfaW50ZXJhY3Rpb25zXzIwMDhfd19uZXcuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfaW50ZXJhY3Rpb25zXzIwMDlfMV9uZXcuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfaW50ZXJhY3Rpb25zXzIwMTFfd19uZXcuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfaW50ZXJhY3Rpb25zX2J1eXByb2QxX25ldy5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9pbnRlcmFjdGlvbnNfY2NoYW5nZTJfMV9uZXcuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfaW50ZXJhY3Rpb25zX2RvcHJvdDFfbmV3LlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X2ludGVyYWN0aW9uc19lZmZfZGFpbHkxX25ldy5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9pbnRlcmFjdGlvbnNfcGVyc19pbXAxX25ldy5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9pbnRlcmFjdGlvbnNfcHJzYWN0aW9uMV9uZXcuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlIiwgImViX2xpc3RfaW50ZXJhY3Rpb25zX3F1YWxsaWZlMV9uZXcuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfaW50ZXJhY3Rpb25zX2RvcHJvdF9jaXR5X3dfbmV3LlJEYXRhIikpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQplYl9yZXN1bHRzX2ludGVyYWN0aW9uc19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBHZXQgdGhlIGxpc3RzIGZyb20gdGhlIGVudmlyb25tZW50DQpsaXN0cyA8LSBscygpDQoNCmZvciAoaiBpbiBsaXN0cykgeyANCiAgaWYoaXMubGlzdChnZXQoaikpKSB7IA0KICAgIG15X2xpc3QgPC0gZ2V0KGopDQoNCiMgTG9vcCBvdmVyIHRoZSBudW1iZXIgb2YgZGVwIHZhcnMgaW4gdGhlIGxpc3QNCmZvciAoaSBpbiBzZXFfYWxvbmcobXlfbGlzdCkpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKG15X2xpc3RbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkobXlfbGlzdFtbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvIEkgbmVlZCBmcm9tIHRoZSBzdW1tYXJ5DQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzExXV0NCiAgc2lnbWFfc2QgPC0gc3VtW1sxMSwyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbMTJdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzEyLDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYgPC0gcmJpbmQoZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdF9pbnQgPSBtdV9pbnQsIG11X3NkX2ludCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHRfaW50ID0gc2lnbWFfaW50LCBzaWdtYV9zZF9pbnQgPSBzaWdtYV9zZCwgbXVfdGltZV9pbnQgPSBtdV90aW1lLCBtdV90aW1lX3NkX2ludCA9IG11X3RpbWVfc2QsIHNpZ190aW1lX2ludCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9pbnQgPSBzaWdfdGltZV9zZCkpDQogICAgfQ0KICB9IA0KfSANCg0KZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYkd2F2ZXNldCA8LSAxDQoNCnNhdmUoZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYsIGZpbGU9ICIvVXNlcnMvYW51c2Noa2EvRG9jdW1lbnRzL2NsaW1hdGVjaGFuZ2UvY2xpbWF0ZWNoYW5nZS9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2ViX3Jlc3VsdHNfaW50ZXJhY3Rpb25zX2RmMV9uZXcuUkRhdGEiICkNCmBgYA0KDQoNCmBgYHtyfQ0KIyBTZWNvbmQgc2V0DQpybShsaXN0PWxzKCkpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZSIsICJlYl9saXN0X2ludGVyYWN0aW9uc18xOTg2XzJfbmV3LlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X2ludGVyYWN0aW9uc18yMDA3XzJfbmV3LlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X2ludGVyYWN0aW9uc18yMDA5XzJfbmV3LlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X2ludGVyYWN0aW9uc19idXlwcm9kMl9uZXcuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfaW50ZXJhY3Rpb25zX2NjaGFuZ2UyXzJfbmV3LlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X2ludGVyYWN0aW9uc19kb3Byb3QyX25ldy5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9pbnRlcmFjdGlvbnNfZWZmX2RhaWx5Ml9uZXcuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfaW50ZXJhY3Rpb25zX3BlcnNfaW1wMl9uZXcuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfaW50ZXJhY3Rpb25zX3Byc2FjdGlvbjJfbmV3LlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZSIsICJlYl9saXN0X2ludGVyYWN0aW9uc19xdWFsbGlmZTJfbmV3LlJEYXRhIikpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQplYl9yZXN1bHRzX2ludGVyYWN0aW9uc19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBHZXQgdGhlIGxpc3RzIGZyb20gdGhlIGVudmlyb25tZW50DQpsaXN0cyA8LSBscygpDQoNCmZvciAoaiBpbiBsaXN0cykgeyANCiAgaWYoaXMubGlzdChnZXQoaikpKSB7IA0KICAgIG15X2xpc3QgPC0gZ2V0KGopDQoNCiMgTG9vcCBvdmVyIHRoZSBudW1iZXIgb2YgZGVwIHZhcnMgaW4gdGhlIGxpc3QNCmZvciAoaSBpbiBzZXFfYWxvbmcobXlfbGlzdCkpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKG15X2xpc3RbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkobXlfbGlzdFtbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvIEkgbmVlZCBmcm9tIHRoZSBzdW1tYXJ5DQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzExXV0NCiAgc2lnbWFfc2QgPC0gc3VtW1sxMSwyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbMTJdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzEyLDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYgPC0gcmJpbmQoZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdF9pbnQgPSBtdV9pbnQsIG11X3NkX2ludCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHRfaW50ID0gc2lnbWFfaW50LCBzaWdtYV9zZF9pbnQgPSBzaWdtYV9zZCwgbXVfdGltZV9pbnQgPSBtdV90aW1lLCBtdV90aW1lX3NkX2ludCA9IG11X3RpbWVfc2QsIHNpZ190aW1lX2ludCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9pbnQgPSBzaWdfdGltZV9zZCkpDQogICAgfQ0KICB9IA0KfSANCg0KZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYkd2F2ZXNldCA8LSAyDQoNCnNhdmUoZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYsIGZpbGU9ICIvVXNlcnMvYW51c2Noa2EvRG9jdW1lbnRzL2NsaW1hdGVjaGFuZ2UvY2xpbWF0ZWNoYW5nZS9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2ViX3Jlc3VsdHNfaW50ZXJhY3Rpb25zX2RmMl9uZXcuUkRhdGEiICkNCmBgYA0KDQoNCmBgYHtyfQ0KIyBUaGlyZCBzZXQNCnJtKGxpc3Q9bHMoKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfaW50ZXJhY3Rpb25zXzIwMDdfM19uZXcuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfaW50ZXJhY3Rpb25zXzIwMDlfM19uZXcuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfaW50ZXJhY3Rpb25zX2NjaGFuZ2UyXzNfbmV3LlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJlYl9saXN0X2ludGVyYWN0aW9uc19lZmZfZGFpbHkzX25ldy5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9pbnRlcmFjdGlvbnNfcHJzYWN0aW9uM19uZXcuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlIiwgImViX2xpc3RfaW50ZXJhY3Rpb25zX3F1YWxsaWZlM19uZXcuUkRhdGEiKSkNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmViX3Jlc3VsdHNfaW50ZXJhY3Rpb25zX2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIEdldCB0aGUgbGlzdHMgZnJvbSB0aGUgZW52aXJvbm1lbnQNCmxpc3RzIDwtIGxzKCkNCg0KZm9yIChqIGluIGxpc3RzKSB7IA0KICBpZihpcy5saXN0KGdldChqKSkpIHsgDQogICAgbXlfbGlzdCA8LSBnZXQoaikNCg0KIyBMb29wIG92ZXIgdGhlIG51bWJlciBvZiBkZXAgdmFycyBpbiB0aGUgbGlzdA0KZm9yIChpIGluIHNlcV9hbG9uZyhteV9saXN0KSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIobXlfbGlzdFtbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShteV9saXN0W1tpXV0pDQogIA0KICAjIEV4dHJhY3QgdGhlIGluZm8gSSBuZWVkIGZyb20gdGhlIHN1bW1hcnkNCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbMTFdXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzExLDJdXQ0KICBtdV90aW1lIDwtIHN1bSBbWzJdXQ0KICBtdV90aW1lX3NkIDwtIHN1bVtbMiwyXV0NCiAgc2lnX3RpbWUgPC0gc3VtW1sxMl1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbMTIsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBlYl9yZXN1bHRzX2ludGVyYWN0aW9uc19kZiA8LSByYmluZChlYl9yZXN1bHRzX2ludGVyYWN0aW9uc19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0X2ludCA9IG11X2ludCwgbXVfc2RfaW50ID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdF9pbnQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkX2ludCA9IHNpZ21hX3NkLCBtdV90aW1lX2ludCA9IG11X3RpbWUsIG11X3RpbWVfc2RfaW50ID0gbXVfdGltZV9zZCwgc2lnX3RpbWVfaW50ID0gc2lnX3RpbWUsIHNpZ190aW1lX3NkX2ludCA9IHNpZ190aW1lX3NkKSkNCiAgICB9DQogIH0gDQp9IA0KDQplYl9yZXN1bHRzX2ludGVyYWN0aW9uc19kZiR3YXZlc2V0IDwtIDMNCg0Kc2F2ZShlYl9yZXN1bHRzX2ludGVyYWN0aW9uc19kZiwgZmlsZT0gIi9Vc2Vycy9hbnVzY2hrYS9Eb2N1bWVudHMvY2xpbWF0ZWNoYW5nZS9jbGltYXRlY2hhbmdlL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYzX25ldy5SRGF0YSIgKQ0KYGBgDQoNCg0KYGBge3J9DQojIEZvdXJ0aCBzZXQNCnJtKGxpc3Q9bHMoKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfaW50ZXJhY3Rpb25zXzIwMDlfNF9uZXcuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzIiwgImViX2xpc3RfaW50ZXJhY3Rpb25zX2NjaGFuZ2UyXzRfbmV3LlJEYXRhIikpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQplYl9yZXN1bHRzX2ludGVyYWN0aW9uc19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBHZXQgdGhlIGxpc3RzIGZyb20gdGhlIGVudmlyb25tZW50DQpsaXN0cyA8LSBscygpDQoNCmZvciAoaiBpbiBsaXN0cykgeyANCiAgaWYoaXMubGlzdChnZXQoaikpKSB7IA0KICAgIG15X2xpc3QgPC0gZ2V0KGopDQoNCiMgTG9vcCBvdmVyIHRoZSBudW1iZXIgb2YgZGVwIHZhcnMgaW4gdGhlIGxpc3QNCmZvciAoaSBpbiBzZXFfYWxvbmcobXlfbGlzdCkpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKG15X2xpc3RbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkobXlfbGlzdFtbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvIEkgbmVlZCBmcm9tIHRoZSBzdW1tYXJ5DQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzExXV0NCiAgc2lnbWFfc2QgPC0gc3VtW1sxMSwyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbMTJdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzEyLDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYgPC0gcmJpbmQoZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdF9pbnQgPSBtdV9pbnQsIG11X3NkX2ludCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHRfaW50ID0gc2lnbWFfaW50LCBzaWdtYV9zZF9pbnQgPSBzaWdtYV9zZCwgbXVfdGltZV9pbnQgPSBtdV90aW1lLCBtdV90aW1lX3NkX2ludCA9IG11X3RpbWVfc2QsIHNpZ190aW1lX2ludCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9pbnQgPSBzaWdfdGltZV9zZCkpDQogICAgfQ0KICB9IA0KfSANCg0KZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYkd2F2ZXNldCA8LSA0DQoNCnNhdmUoZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYsIGZpbGU9ICIvVXNlcnMvYW51c2Noa2EvRG9jdW1lbnRzL2NsaW1hdGVjaGFuZ2UvY2xpbWF0ZWNoYW5nZS9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2ViX3Jlc3VsdHNfaW50ZXJhY3Rpb25zX2RmNF9uZXcuUkRhdGEiICkNCmBgYA0KDQoNCmBgYHtyfQ0KIyBBbmQgdGhlIGZpZnRoIA0Kcm0obGlzdD1scygpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMiLCAiZWJfbGlzdF9pbnRlcmFjdGlvbnNfMjAwOV81X25ldy5SRGF0YSIpKQ0KDQojIFN0b3JlIHRoZSByZXN1bHRzIGluIGEgbmV3IGRhdGFmcmFtZQ0KZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCiMgR2V0IHRoZSBsaXN0cyBmcm9tIHRoZSBlbnZpcm9ubWVudA0KbGlzdHMgPC0gbHMoKQ0KDQpmb3IgKGogaW4gbGlzdHMpIHsgDQogIGlmKGlzLmxpc3QoZ2V0KGopKSkgeyANCiAgICBteV9saXN0IDwtIGdldChqKQ0KDQojIExvb3Agb3ZlciB0aGUgbnVtYmVyIG9mIGRlcCB2YXJzIGluIHRoZSBsaXN0DQpmb3IgKGkgaW4gc2VxX2Fsb25nKG15X2xpc3QpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3RlcihteV9saXN0W1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KG15X2xpc3RbW2ldXSkNCiAgDQogICMgRXh0cmFjdCB0aGUgaW5mbyBJIG5lZWQgZnJvbSB0aGUgc3VtbWFyeQ0KICBtdV9pbnQgPC0gc3VtW1sxXV0NCiAgbXVfc2QgPC0gc3VtW1sxLDJdXQ0KICBzaWdtYV9pbnQgPC0gc3VtW1sxMV1dDQogIHNpZ21hX3NkIDwtIHN1bVtbMTEsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzEyXV0NCiAgc2lnX3RpbWVfc2QgPC0gc3VtW1sxMiwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIGluIGEgZGF0YWZyYW1lDQogIGViX3Jlc3VsdHNfaW50ZXJhY3Rpb25zX2RmIDwtIHJiaW5kKGViX3Jlc3VsdHNfaW50ZXJhY3Rpb25zX2RmLCBkYXRhLmZyYW1lKGRlcF92YXIgPSBkZXBfdmFyLCBtdV9pbnRlcmNlcHRfaW50ID0gbXVfaW50LCBtdV9zZF9pbnQgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0X2ludCA9IHNpZ21hX2ludCwgc2lnbWFfc2RfaW50ID0gc2lnbWFfc2QsIG11X3RpbWVfaW50ID0gbXVfdGltZSwgbXVfdGltZV9zZF9pbnQgPSBtdV90aW1lX3NkLCBzaWdfdGltZV9pbnQgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2RfaW50ID0gc2lnX3RpbWVfc2QpKQ0KICAgIH0NCiAgfSANCn0gDQoNCmViX3Jlc3VsdHNfaW50ZXJhY3Rpb25zX2RmJHdhdmVzZXQgPC0gNQ0KDQpzYXZlKGViX3Jlc3VsdHNfaW50ZXJhY3Rpb25zX2RmLCBmaWxlPSAiL1VzZXJzL2FudXNjaGthL0RvY3VtZW50cy9jbGltYXRlY2hhbmdlL2NsaW1hdGVjaGFuZ2UvZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9lYl9yZXN1bHRzX2ludGVyYWN0aW9uc19kZjVfbmV3LlJEYXRhIiApDQpgYGANCg0KIyMgTWVyZ2UgZXZlcnl0aGluZyBpbnRvIGRhdGFzZXQNCg0KYGBge3J9DQojIE1ha2Ugb25lIGRhdGFmcmFtZQ0KIyBGaXJzdCBlbXB0eSBsaXN0cw0Kcm0obGlzdD1scygpKQ0KIyBUaGV5IGFsbCBoYXZlIHRoZSBzYW1lIG5hbWVzLCBzbyBJIGhhdmUgdG8gYXNzaWduIHRoZW0gYSBuZXcgbmFtZQ0KZWJfMSA8LSBsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZSIsICJlYl9yZXN1bHRzX2VtcHR5X2RmMV9uZXcuUkRhdGEiKSkNCmViXzIgPC0gbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUiLCAiZWJfcmVzdWx0c19lbXB0eV9kZjJfbmV3LlJEYXRhIikpDQplYl8zIDwtIGxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlIiwgImViX3Jlc3VsdHNfZW1wdHlfZGYzX25ldy5SRGF0YSIpKQ0KZWJfNCA8LSBsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZSIsICJlYl9yZXN1bHRzX2VtcHR5X2RmNF9uZXcuUkRhdGEiKSkNCmViXzUgPC0gbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUiLCAiZWJfcmVzdWx0c19lbXB0eV9kZjVfbmV3LlJEYXRhIikpDQoNCg0KZWJfZW1wdHlfZGZfd2F2ZXMgPC0gcmJpbmQgKGViXzEsIGViXzIsIGViXzMsIGViXzQsIGViXzUpDQplYl9lbXB0eV9kZl93YXZlcyRkZXBfdmFyX3dhdmUgPC0gcGFzdGUoZWJfZW1wdHlfZGZfd2F2ZXMkZGVwX3ZhciwgZWJfZW1wdHlfZGZfd2F2ZXMkd2F2ZXNldCwgc2VwID0gIl8iKQ0KDQpzYXZlKGViX2VtcHR5X2RmX3dhdmVzLCBmaWxlPSAiL1VzZXJzL2FudXNjaGthL0RvY3VtZW50cy9jbGltYXRlY2hhbmdlL2NsaW1hdGVjaGFuZ2UvZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9lYl9lbXB0eV9kZl93YXZlc19uZXcuUkRhdGEiICkNCg0KDQojIEZvciB0aGUgcHJlZCBtb2RlbHMNCnJtKGxpc3Q9bHMoKSkNCmViXzEgPC0gbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUiLCJlYl9yZXN1bHRzX3ByZWRzX2RmMV9uZXcuUkRhdGEiKSkNCmViXzIgPC0gbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUiLCAiZWJfcmVzdWx0c19wcmVkc19kZjJfbmV3LlJEYXRhIikpDQplYl8zIDwtIGxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlIiwgImViX3Jlc3VsdHNfcHJlZHNfZGYzX25ldy5SRGF0YSIpKQ0KZWJfNCA8LSBsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZSIsICJlYl9yZXN1bHRzX3ByZWRzX2RmNF9uZXcuUkRhdGEiKSkNCmViXzUgPC0gbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUiLCAiZWJfcmVzdWx0c19wcmVkc19kZjVfbmV3LlJEYXRhIikpDQoNCmViX3ByZWRzX2RmX3dhdmVzIDwtIHJiaW5kIChlYl8xLCBlYl8yLCBlYl8zLCBlYl80LCBlYl81KQ0KZWJfcHJlZHNfZGZfd2F2ZXMkZGVwX3Zhcl93YXZlIDwtIHBhc3RlKGViX3ByZWRzX2RmX3dhdmVzJGRlcF92YXIsIGViX3ByZWRzX2RmX3dhdmVzJHdhdmVzZXQsIHNlcCA9ICJfIikNCg0Kc2F2ZShlYl9wcmVkc19kZl93YXZlcywgZmlsZT0gIi9Vc2Vycy9hbnVzY2hrYS9Eb2N1bWVudHMvY2xpbWF0ZWNoYW5nZS9jbGltYXRlY2hhbmdlL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZWJfcHJlZHNfZGZfd2F2ZXNfbmV3LlJEYXRhIiApDQoNCiMgQW5kIGxhc3RseSB0aGUgc2FtZSBmb3IgdGhlIGludGVyYWN0aW9ucw0Kcm0obGlzdD1scygpKQ0KZWJfMSA8LSBsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZSIsICJlYl9yZXN1bHRzX2ludGVyYWN0aW9uc19kZjFfbmV3LlJEYXRhIikpDQplYl8yIDwtIGxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlIiwgImViX3Jlc3VsdHNfaW50ZXJhY3Rpb25zX2RmMl9uZXcuUkRhdGEiKSkNCmViXzMgPC0gbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUiLCAiZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYzX25ldy5SRGF0YSIpKQ0KZWJfNCA8LSBsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZSIsICJlYl9yZXN1bHRzX2ludGVyYWN0aW9uc19kZjRfbmV3LlJEYXRhIikpDQplYl81IDwtIGxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlIiwgImViX3Jlc3VsdHNfaW50ZXJhY3Rpb25zX2RmNV9uZXcuUkRhdGEiKSkNCg0KZWJfaW50ZXJhY3Rpb25zX2RmX3dhdmVzIDwtIHJiaW5kIChlYl8xLCBlYl8yLCBlYl8zLCBlYl80LCBlYl81KQ0KZWJfaW50ZXJhY3Rpb25zX2RmX3dhdmVzJGRlcF92YXJfd2F2ZSA8LSBwYXN0ZShlYl9pbnRlcmFjdGlvbnNfZGZfd2F2ZXMkZGVwX3ZhciwgZWJfaW50ZXJhY3Rpb25zX2RmX3dhdmVzJHdhdmVzZXQsIHNlcCA9ICJfIikNCg0Kc2F2ZShlYl9pbnRlcmFjdGlvbnNfZGZfd2F2ZXMsIGZpbGU9ICIvVXNlcnMvYW51c2Noa2EvRG9jdW1lbnRzL2NsaW1hdGVjaGFuZ2UvY2xpbWF0ZWNoYW5nZS9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2ViX2ludGVyYWN0aW9uc19kZl93YXZlc19uZXcuUkRhdGEiICkNCg0KIyBBbmQgbm93IG9uZSBsYXJnZSBkYXRhZnJhbWUgb2YgdGhlc2UgdGhyZWUgDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZSIsICJlYl9lbXB0eV9kZl93YXZlc19uZXcuUkRhdGEiKSkNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlIiwgImViX3ByZWRzX2RmX3dhdmVzX25ldy5SRGF0YSIpKQ0KDQojIE1lcmdlIHRoZSByZXN1bHRzDQplYl9yZXN1bHRzX2RmIDwtIGxlZnRfam9pbihlYl9lbXB0eV9kZl93YXZlcywgZWJfcHJlZHNfZGZfd2F2ZXMpDQplYl9yZXN1bHRzX2RmIDwtIGxlZnRfam9pbihlYl9yZXN1bHRzX2RmLCBlYl9pbnRlcmFjdGlvbnNfZGZfd2F2ZXMpDQplYl9yZXN1bHRzX2RmJGRhdGEgPC0gIkVCIg0KDQojIEFzc2lnbiB5ZWFyIHBlciB2YXJpYWJsZQ0KZWJfcmVzdWx0c19kZiRmaXJzdF95ZWFyW2ViX3Jlc3VsdHNfZGYkZGVwX3ZhciA9PSAicm9sZV9pbmQiXSA8LSAyMDA3DQplYl9yZXN1bHRzX2RmJGZpcnN0X3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJiaWdfcG9sIl0gPC0gMjAwNw0KZWJfcmVzdWx0c19kZiRmaXJzdF95ZWFyW2ViX3Jlc3VsdHNfZGYkZGVwX3ZhciA9PSAiY2NfdW5zdG9wIl0gPC0gMjAwOA0KZWJfcmVzdWx0c19kZiRmaXJzdF95ZWFyW2ViX3Jlc3VsdHNfZGYkZGVwX3ZhciA9PSAiY2NfZXhhZyJdIDwtIDIwMDgNCmViX3Jlc3VsdHNfZGYkZmlyc3RfeWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImNjX3Bvc2V1Il0gPC0gMjAwOA0KZWJfcmVzdWx0c19kZiRmaXJzdF95ZWFyW2ViX3Jlc3VsdHNfZGYkZGVwX3ZhciA9PSAiY2NfcHJzYWN0Il0gPC0gMjAwOA0KZWJfcmVzdWx0c19kZiRmaXJzdF95ZWFyW2ViX3Jlc3VsdHNfZGYkZGVwX3ZhciA9PSAiY2NfcG9zZXUiXSA8LSAyMDA4DQplYl9yZXN1bHRzX2RmJGZpcnN0X3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJjY3BlcmNlcHQiXSA8LSAyMDA5DQplYl9yZXN1bHRzX2RmJGZpcnN0X3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJjY2hhbmdlIl0gPC0gMjAwOQ0KZWJfcmVzdWx0c19kZiRmaXJzdF95ZWFyW2ViX3Jlc3VsdHNfZGYkZGVwX3ZhciA9PSAiY2NoYW5nZTIiXSA8LSAyMDExDQplYl9yZXN1bHRzX2RmJGZpcnN0X3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJjY2hhbmdldG90Il0gPC0gMjAxMQ0KZWJfcmVzdWx0c19kZiRmaXJzdF95ZWFyW2ViX3Jlc3VsdHNfZGYkZGVwX3ZhciA9PSAiZW52cF9lZyJdIDwtIDIwMTENCmViX3Jlc3VsdHNfZGYkZmlyc3RfeWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImVmZnJfZWciXSA8LSAyMDExDQplYl9yZXN1bHRzX2RmJGZpcnN0X3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJidXlwcm9kIl0gPC0gMjAwNw0KZWJfcmVzdWx0c19kZiRmaXJzdF95ZWFyW2ViX3Jlc3VsdHNfZGYkZGVwX3ZhciA9PSAiZG9wcm90X25hdGdvdiJdIDwtIDIwMDkNCmViX3Jlc3VsdHNfZGYkZmlyc3RfeWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImRvcHJvdF9ldSJdIDwtIDIwMDkNCmViX3Jlc3VsdHNfZGYkZmlyc3RfeWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImRvcHJvdF9yZWdpb24iXSA8LSAyMDA5DQplYl9yZXN1bHRzX2RmJGZpcnN0X3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJkb3Byb3RfY29tcCJdIDwtIDIwMDkNCmViX3Jlc3VsdHNfZGYkZmlyc3RfeWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImRvcHJvdF9jaXRpeiJdIDwtIDIwMDkNCmViX3Jlc3VsdHNfZGYkZmlyc3RfeWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImRvcHJvdF9jaXR5Il0gPC0gMjAxNA0KZWJfcmVzdWx0c19kZiRmaXJzdF95ZWFyW2ViX3Jlc3VsdHNfZGYkZGVwX3ZhciA9PSAiZWZmX2RhaWx5Il0gPC0gMjAwNw0KZWJfcmVzdWx0c19kZiRmaXJzdF95ZWFyW2ViX3Jlc3VsdHNfZGYkZGVwX3ZhciA9PSAicGVyc19pbXAiXSA8LSAyMDA5DQplYl9yZXN1bHRzX2RmJGZpcnN0X3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJlbnZfcXVhbGxpZmUiXSA8LSAyMDA0DQplYl9yZXN1bHRzX2RmJGZpcnN0X3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJwcnNhY3Rpb24iXSA8LSAyMDExDQoNCiMgQW5kIHRoZSBhdmVyYWdlIHllYXIgDQplYl9yZXN1bHRzX2RmJG1lYW5feWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gInJvbGVfaW5kIl0gPC0gMjAxMg0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJiaWdfcG9sIl0gPC0gMjAxMg0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJjY191bnN0b3AiXSA8LSAyMDA4DQplYl9yZXN1bHRzX2RmJG1lYW5feWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImNjX2V4YWciXSA8LSAyMDA4DQplYl9yZXN1bHRzX2RmJG1lYW5feWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImNjX3Bvc2V1Il0gPC0gMjAwOA0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJjY19wcnNhY3QiXSA8LSAyMDA4DQplYl9yZXN1bHRzX2RmJG1lYW5feWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImNjX3Bvc2V1Il0gPC0gMjAwOA0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJjY3BlcmNlcHQiXSA8LSAyMDE0DQplYl9yZXN1bHRzX2RmJG1lYW5feWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImNjaGFuZ2UiXSA8LSAyMDE1DQplYl9yZXN1bHRzX2RmJG1lYW5feWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImNjaGFuZ2UyIl0gPC0gMjAxNQ0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJjY2hhbmdldG90Il0gPC0gMjAxNQ0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJlbnZwX2VnIl0gPC0gMjAxMw0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJlZmZyX2VnIl0gPC0gMjAxMw0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJidXlwcm9kIl0gPC0gMjAxMA0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJkb3Byb3RfbmF0Z292Il0gPC0gMjAxMw0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJkb3Byb3RfZXUiXSA8LSAyMDEzDQplYl9yZXN1bHRzX2RmJG1lYW5feWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImRvcHJvdF9yZWdpb24iXSA8LSAyMDEzDQplYl9yZXN1bHRzX2RmJG1lYW5feWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImRvcHJvdF9jb21wIl0gPC0gMjAxMw0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJkb3Byb3RfY2l0aXoiXSA8LSAyMDEzDQplYl9yZXN1bHRzX2RmJG1lYW5feWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImRvcHJvdF9jaXR5Il0gPC0gMjAxNQ0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJlZmZfZGFpbHkiXSA8LSAyMDEyDQplYl9yZXN1bHRzX2RmJG1lYW5feWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gInBlcnNfaW1wIl0gPC0gMjAwOQ0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJlbnZfcXVhbGxpZmUiXSA8LSAyMDA5DQplYl9yZXN1bHRzX2RmJG1lYW5feWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gInByc2FjdGlvbiJdIDwtIDIwMTQNCg0Kc2F2ZShlYl9yZXN1bHRzX2RmLCBmaWxlPSAiL1VzZXJzL2FudXNjaGthL0RvY3VtZW50cy9jbGltYXRlY2hhbmdlL2NsaW1hdGVjaGFuZ2UvZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9lYl9yZXN1bHRzX2RmX3dhdmVzX3RvdGFsX25ldy5SRGF0YSIgKQ0KYGBgDQoNCg0KYGBge3J9DQojIFRoZSBzYW1lIG5lZWRzIHRvIGJlIGRvbmUgZm9yIEVWUywgSSZPIGFuZCBJU1NQDQojIEVWUw0Kcm0obGlzdD1scygpKQ0KZXZzXzEgPC0gbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUiLCAiZXZzX3Jlc3VsdHNfZGYxX25ldy5SRGF0YSIpKQ0KZXZzXzIgPC0gbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUiLCAiZXZzX3Jlc3VsdHNfZGYyX25ldy5SRGF0YSIpKQ0KDQpldnNfcmVzdWx0c19kZl93YXZlcyA8LSByYmluZCAoZXZzXzEsIGV2c18yKQ0KZXZzX3Jlc3VsdHNfZGZfd2F2ZXMkZGVwX3Zhcl93YXZlIDwtIHBhc3RlKGV2c19yZXN1bHRzX2RmX3dhdmVzJGRlcF92YXIsIGV2c19yZXN1bHRzX2RmX3dhdmVzJHdhdmVzZXQsIHNlcCA9ICJfIikNCg0Kc2F2ZShldnNfcmVzdWx0c19kZl93YXZlcywgZmlsZT0gIi9Vc2Vycy9hbnVzY2hrYS9Eb2N1bWVudHMvY2xpbWF0ZWNoYW5nZS9jbGltYXRlY2hhbmdlL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZXZzX3Jlc3VsdHNfZGZfd2F2ZXNfbmV3LlJEYXRhIiApDQoNCiMgSSZPDQpybShsaXN0PWxzKCkpDQppb18xIDwtIGxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlIiwgImlvX3Jlc3VsdHNfZGYxX25ldy5SRGF0YSIpKQ0KaW9fMiA8LSBsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZSIsICJpb19yZXN1bHRzX2RmMl9uZXcuUkRhdGEiKSkNCg0KaW9fcmVzdWx0c19kZl93YXZlcyA8LSByYmluZCAoaW9fMSwgaW9fMikNCmlvX3Jlc3VsdHNfZGZfd2F2ZXMkZGVwX3Zhcl93YXZlIDwtIHBhc3RlKGlvX3Jlc3VsdHNfZGZfd2F2ZXMkZGVwX3ZhciwgaW9fcmVzdWx0c19kZl93YXZlcyR3YXZlc2V0LCBzZXAgPSAiXyIpDQoNCnNhdmUoaW9fcmVzdWx0c19kZl93YXZlcywgZmlsZT0gIi9Vc2Vycy9hbnVzY2hrYS9Eb2N1bWVudHMvY2xpbWF0ZWNoYW5nZS9jbGltYXRlY2hhbmdlL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvaW9fcmVzdWx0c19kZl93YXZlc19uZXcuUkRhdGEiICkNCg0KIyBBbmQgSVNTUA0Kcm0obGlzdD1scygpKQ0KaXNzcF8xIDwtIGxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZSIsICJpc3NwX3Jlc3VsdHNfZGYxX25ldy5SRGF0YSIpKQ0KaXNzcF8yIDwtIGxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlIiwgImlzc3BfcmVzdWx0c19kZjJfbmV3LlJEYXRhIikpDQoNCmlzc3BfcmVzdWx0c19kZl93YXZlcyA8LSByYmluZCAoaXNzcF8xLCBpc3NwXzIpDQppc3NwX3Jlc3VsdHNfZGZfd2F2ZXMkZGVwX3Zhcl93YXZlIDwtIHBhc3RlKGlzc3BfcmVzdWx0c19kZl93YXZlcyRkZXBfdmFyLCBpc3NwX3Jlc3VsdHNfZGZfd2F2ZXMkd2F2ZXNldCwgc2VwID0gIl8iKQ0KDQpzYXZlKGlzc3BfcmVzdWx0c19kZl93YXZlcywgZmlsZT0gIi9Vc2Vycy9hbnVzY2hrYS9Eb2N1bWVudHMvY2xpbWF0ZWNoYW5nZS9jbGltYXRlY2hhbmdlL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvaXNzcF9yZXN1bHRzX2RmX3dhdmVzX25ldy5SRGF0YSIgKQ0KYGBgDQoNCg0KYGBge3J9DQojIFRoZSBmaW5hbCBzdGVwIGlzIHRvIG1lcmdlIGFsbCByZXN1bHRzIGludG8gb25lIGRhdGFmcmFtZQ0Kcm0obGlzdD1scygpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcmVncmVzc2lvbl9vdXRwdXRzIiwgImVzc19yZXN1bHRzX2RmX3dfbmV3LlJEYXRhIikpDQplc3NfcmVzdWx0c19kZiR3YXZlc2V0IDwtIDENCmVzc19yZXN1bHRzX2RmJGRlcF92YXJfd2F2ZSA8LSBwYXN0ZShlc3NfcmVzdWx0c19kZiRkZXBfdmFyLCBlc3NfcmVzdWx0c19kZiR3YXZlc2V0LCBzZXAgPSAiXyIpDQoNCmxvYWQoaGVyZSgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3JlZ3Jlc3Npb25fb3V0cHV0cyIsICJpc3NwX3Jlc3VsdHNfMl9kZl9uZXcuUkRhdGEiKSkNCg0KaXNzcF9yZXN1bHRzXzJfZGYkbWVhbl95ZWFyIDwtIDIwMDUNCmlzc3BfcmVzdWx0c18yX2RmJHdhdmVzZXQgPC0gMQ0KaXNzcF9yZXN1bHRzXzJfZGYkZGVwX3Zhcl93YXZlIDwtIHBhc3RlKGlzc3BfcmVzdWx0c18yX2RmJGRlcF92YXIsIGlzc3BfcmVzdWx0c18yX2RmJHdhdmVzZXQsIHNlcCA9ICJfIikNCg0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlIiwgImV2c19yZXN1bHRzX2RmX3dhdmVzX25ldy5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlIiwgImlvX3Jlc3VsdHNfZGZfd2F2ZXNfbmV3LlJEYXRhIikpDQpsb2FkKGhlcmUoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUiLCAiaXNzcF9yZXN1bHRzX2RmX3dhdmVzX25ldy5SRGF0YSIpKQ0KbG9hZChoZXJlKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlIiwgImViX3Jlc3VsdHNfZGZfd2F2ZXNfdG90YWxfbmV3LlJEYXRhIikpDQoNCnRvdGFsX3Jlc3VsdHNfd2F2ZXMgPC0gcmJpbmQoZWJfcmVzdWx0c19kZiwgZXNzX3Jlc3VsdHNfZGYsIGV2c19yZXN1bHRzX2RmX3dhdmVzLCBpb19yZXN1bHRzX2RmX3dhdmVzLCBpc3NwX3Jlc3VsdHNfZGZfd2F2ZXMsIGlzc3BfcmVzdWx0c18yX2RmKSANCg0Kc2F2ZSh0b3RhbF9yZXN1bHRzX3dhdmVzLCBmaWxlPSAiL1VzZXJzL2FudXNjaGthL0RvY3VtZW50cy9jbGltYXRlY2hhbmdlL2NsaW1hdGVjaGFuZ2UvZGF0YS9tZXRhX2FuYWx5c2lzL3RvdGFsX3Jlc3VsdHNfd2F2ZXNfbmV3LlJEYXRhIiApDQpgYGANCg0KYGBge3J9DQojIEkgYWxzbyB3YW50IHRvIGFkZCBhIHZhcmlhYmxlIHRoYXQgZGVzY3JpYmVzIHdoZXRoZXIgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBpcyBtb3N0bHkgb2YgYWZmZWN0aXZlLCBiZWhhdmlvcmFsIG9yIGNvZ25pdGl2ZSBuYXR1cmUgDQoNCiMgMiB2YXJpYWJsZXMgdGhhdCBhcmUgY2FsbGVkIHdvcnJ5LCBub3QgaGFuZHkgDQp0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXJbdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJ3b3JyeSIgJiB0b3RhbF9yZXN1bHRzX3dhdmVzJGRhdGEgPT0gIklTU1AiXSA8LSAid29ycnlfaXNzcCINCg0KdG90YWxfcmVzdWx0c193YXZlcyRhdHRpdHVkZV9jYXRbdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJkb2RpZmYiIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJwZXJzX3Jlc3AiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gIndvcnJ5Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJ3b3JyaWVkIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJ3b3JyeV9mdXR1cmUiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImZyb250cnVubmVyIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJtaW5fY29udHIiXSA8LSAiYWZmZWN0aXZlIg0KdG90YWxfcmVzdWx0c193YXZlcyRhdHRpdHVkZV9jYXRbdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJ3aWxsaW5nX3ByaWNlIiANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAid2lsbGluZ190YXgiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gIndpbGxpbmdfbGl2aW5nIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJkb19yaWdodCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAicGVvcGxlX2RlY2lkZSINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiY2xpbWF0ZTUiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gInByc2FjdGlvbiINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiY2NfcHJzYWN0Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJidXlwcm9kIl0gPC0gImJlaGF2aW9yYWwiDQp0b3RhbF9yZXN1bHRzX3dhdmVzJGF0dGl0dWRlX2NhdFt0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gIndvcnJ5X2lzc3AiIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJsaWZlaGFybSINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAicHJvZ2hhcm0iDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImVjb25wcm90ZWN0Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJncm93aGFybSINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiYnVzX2RlY2lkZSINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAibW9yZWltcCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAib3RoZXJzYW1lIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJleGFnIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJjb3VudHJ5X2VmZm9ydCIgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImNhdXNlIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJyZXNwX2NpdGl6Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJka19zdGFydCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiZG9fZ292Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJidXNzX2hlbHAiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImh1bWFuX3Jlc3AiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImVudl9lY19zdGF0Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJlbnZfcHJzaW1wIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiZW52cF9lZyINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiZWZmcl9lZyINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiY2NoYW5nZSINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiY2NoYW5nZTIiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImNjaGFuZ2V0b3QiIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJjY3BlcmNlcHQiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImVudl9xdWFsbGlmZSINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiZG9wcm90X2NvbXAiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImRvcHJvdF9yZWdpb24iDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImRvcHJvdF9uYXRnb3YiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImRvcHJvdF9jaXR5Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJkb3Byb3RfY2l0aXoiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImRvcHJvdF9ldSINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJjY191bnN0b3AiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImNjX2V4YWciDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImNjX3Bvc2V1Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJyb2xlX2luZCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiYmlnX3BvbCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiZWZmX2RhaWx5Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJwZXJzX2ltcCJdIDwtICJjb2duaXRpdmUiDQoNCiNDcmVhdGUgYSB2YXJpYWJsZSB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgY2FuIGJlIGludGVycHJldGVkIGluIDIgd2F5cyAoYW1iaWd1b3VzKQ0KdG90YWxfcmVzdWx0c193YXZlcyRhbWJpZ3VvdXNbdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyICE9ICJkb2RpZmYiIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyICE9ICJmcm9udHJ1bm5lciINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciAhPSAibWluX2NvbnRyIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyICE9ICJwZW9wbGVfZGVjaWRlIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyICE9ICJlY29ucHJvdGVjdCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciAhPSAiZ3Jvd2hhcm0iDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgIT0gImJ1c19kZWNpZGUiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgIT0gIm90aGVyc2FtZSINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciAhPSAicmVzcF9jaXRpeiINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciAhPSAiZGtfc3RhcnQiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgIT0gImJ1c3NfaGVscCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciAhPSAiZW52cF9lZyINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciAhPSAiZWZmcl9lZyINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciAhPSAiZW52X3F1YWxsaWZlIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyICE9ICJjY191bnN0b3AiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgIT0gImNjX3Bvc2V1Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyICE9ICJiaWdfcG9sIl0gPC0gIk5vIg0KdG90YWxfcmVzdWx0c193YXZlcyRhbWJpZ3VvdXNbdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJkb2RpZmYiIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJmcm9udHJ1bm5lciINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAibWluX2NvbnRyIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJwZW9wbGVfZGVjaWRlIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJlY29ucHJvdGVjdCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiZ3Jvd2hhcm0iDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImJ1c19kZWNpZGUiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gIm90aGVyc2FtZSINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAicmVzcF9jaXRpeiINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiZGtfc3RhcnQiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImJ1c3NfaGVscCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiZW52cF9lZyINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiZWZmcl9lZyINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiZW52X3F1YWxsaWZlIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJjY191bnN0b3AiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImNjX3Bvc2V1Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJiaWdfcG9sIl0gPC0gIlllcyINCg0KDQojIENyZWF0ZSBhIHZhcmlhYmxlIGFib3V0IHdoZXRoZXIgMjAwOCAoZmluYW5jaWFsIGNyaXNpcykgaXMgaW5jbHVkZWQgaW4gdGhlIHRpbWUgc3BhbiBvZiB0aGUgZGF0YSBzZXQvdmFycyANCnRvdGFsX3Jlc3VsdHNfd2F2ZXMkZmluX2NyaXNpc1t0b3RhbF9yZXN1bHRzX3dhdmVzJGRhdGEgPT0gIkVWUyIgJiB0b3RhbF9yZXN1bHRzX3dhdmVzJHdhdmVzZXQgPT0gMl0gPC0gMQ0KdG90YWxfcmVzdWx0c193YXZlcyRmaW5fY3Jpc2lzW3RvdGFsX3Jlc3VsdHNfd2F2ZXMkZGF0YSA9PSAiRVZTIiAmIHRvdGFsX3Jlc3VsdHNfd2F2ZXMkd2F2ZXNldCA9PSAxXSA8LSAwDQp0b3RhbF9yZXN1bHRzX3dhdmVzJGZpbl9jcmlzaXNbdG90YWxfcmVzdWx0c193YXZlcyRkYXRhID09ICJJU1NQIiAmIHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZmlyc3RfeWVhciA9PSAyMDAwXSA8LSAxDQp0b3RhbF9yZXN1bHRzX3dhdmVzJGZpbl9jcmlzaXNbdG90YWxfcmVzdWx0c193YXZlcyRkYXRhID09ICJJU1NQIiAmIHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZmlyc3RfeWVhciA9PSAxOTkzXSA8LSAwDQp0b3RhbF9yZXN1bHRzX3dhdmVzJGZpbl9jcmlzaXNbdG90YWxfcmVzdWx0c193YXZlcyRkYXRhID09ICJFU1MiXSA8LSAwDQp0b3RhbF9yZXN1bHRzX3dhdmVzJGZpbl9jcmlzaXNbdG90YWxfcmVzdWx0c193YXZlcyRkYXRhID09ICJJTyJdIDwtIDANCiMgRm9yIHRoZSBFQiwgdGhpcyB2YXJpZXMgbW9yZQ0KdG90YWxfcmVzdWx0c193YXZlcyRmaW5fY3Jpc2lzW3RvdGFsX3Jlc3VsdHNfd2F2ZXMkZGF0YSA9PSAiRUIiXSA8LSAwDQp0b3RhbF9yZXN1bHRzX3dhdmVzJGZpbl9jcmlzaXNbdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyX3dhdmUgPT0gImVudl9xdWFsbGlmZV8yIl0gPC0gMQ0KdG90YWxfcmVzdWx0c193YXZlcyRmaW5fY3Jpc2lzW3RvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3Zhcl93YXZlID09ICJyb2xlX2luZF8xIl0gPC0gMQ0KdG90YWxfcmVzdWx0c193YXZlcyRmaW5fY3Jpc2lzW3RvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3Zhcl93YXZlID09ICJiaWdfcG9sXzEiXSA8LSAxDQp0b3RhbF9yZXN1bHRzX3dhdmVzJGZpbl9jcmlzaXNbdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyX3dhdmUgPT0gImJ1eXByb2RfMSJdIDwtIDENCnRvdGFsX3Jlc3VsdHNfd2F2ZXMkZmluX2NyaXNpc1t0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXJfd2F2ZSA9PSAiZWZmX2RhaWx5XzEiXSA8LSAxDQp0b3RhbF9yZXN1bHRzX3dhdmVzJGZpbl9jcmlzaXNbdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyX3dhdmUgPT0gImNjX3Vuc3RvcF8xIl0gPC0gMQ0KdG90YWxfcmVzdWx0c193YXZlcyRmaW5fY3Jpc2lzW3RvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3Zhcl93YXZlID09ICJjY19leGFnXzEiXSA8LSAxDQp0b3RhbF9yZXN1bHRzX3dhdmVzJGZpbl9jcmlzaXNbdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyX3dhdmUgPT0gImNjX3Byc2FjdF8xIl0gPC0gMQ0KDQojIEFuZCB0aGUgc2FtZSBmb3IgY292aWQtMTkNCnRvdGFsX3Jlc3VsdHNfd2F2ZXMkY292aWRbdG90YWxfcmVzdWx0c193YXZlcyRkYXRhID09ICJFVlMiXSA8LSAwDQp0b3RhbF9yZXN1bHRzX3dhdmVzJGNvdmlkW3RvdGFsX3Jlc3VsdHNfd2F2ZXMkZGF0YSA9PSAiSVNTUCJdIDwtIDANCnRvdGFsX3Jlc3VsdHNfd2F2ZXMkY292aWRbdG90YWxfcmVzdWx0c193YXZlcyRkYXRhID09ICJFU1MiXSA8LSAxDQp0b3RhbF9yZXN1bHRzX3dhdmVzJGNvdmlkW3RvdGFsX3Jlc3VsdHNfd2F2ZXMkZGF0YSA9PSAiSU8iXSA8LSAxDQp0b3RhbF9yZXN1bHRzX3dhdmVzJGNvdmlkW3RvdGFsX3Jlc3VsdHNfd2F2ZXMkZGF0YSA9PSAiRUIiXSA8LSAwDQp0b3RhbF9yZXN1bHRzX3dhdmVzJGNvdmlkW3RvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3Zhcl93YXZlID09ICJjY3BlcmNlcHRfNSJdIDwtIDENCnRvdGFsX3Jlc3VsdHNfd2F2ZXMkY292aWRbdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyX3dhdmUgPT0gImNjaGFuZ2VfNSJdIDwtIDENCnRvdGFsX3Jlc3VsdHNfd2F2ZXMkY292aWRbdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyX3dhdmUgPT0gImNjaGFuZ2UyXzUiXSA8LSAxDQp0b3RhbF9yZXN1bHRzX3dhdmVzJGNvdmlkW3RvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3Zhcl93YXZlID09ICJjY2hhbmdldG90XzUiXSA8LSAxDQoNCnNhdmUodG90YWxfcmVzdWx0c193YXZlcywgZmlsZT0gIi9Vc2Vycy9hbnVzY2hrYS9Eb2N1bWVudHMvY2xpbWF0ZWNoYW5nZS9jbGltYXRlY2hhbmdlL2RhdGEvbWV0YV9hbmFseXNpcy90b3RhbF9yZXN1bHRzX3dhdmVzX25ldy5SRGF0YSIgKQ0KYGBgDQoNCg==</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("regression_to_meta_analysis_wg_waves_new.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
