<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Anuschka Peelen" />

<meta name="date" content="2024-01-12" />

<title>Extract coefficients of gamlss regressions shorter time spans</title>

<script src="site_libs/header-attrs-2.25/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.4.2/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>


<link rel="stylesheet" href="tweaks.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Scripts data preparation
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="dataprep_EB.html">Data preparation Eurobarometer</a>
    </li>
    <li>
      <a href="dataprep_EVS_ESS_ISSP.html">Data preparation EVS, ESS, ISSP</a>
    </li>
    <li>
      <a href="dataprep_I-O.html">Data preparation I&amp;O Research</a>
    </li>
    <li>
      <a href="dataprep_motivaction_LISS_socon.html">Data preparation Motivaction, LISS, Socon</a>
    </li>
    <li>
      <a href="weights.html">Weighing data</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Scripts descriptives and analysis
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="descriptives.html">Descriptives and pooled table</a>
    </li>
    <li>
      <a href="single_regression_gamlss_weigh_new.html">Gamlss regressions weighted</a>
    </li>
    <li>
      <a href="regression_to_meta_analysis_weight_gamlss_new.html">Extract coefficients gamlss regressions</a>
    </li>
    <li>
      <a href="regression_to_indep_var_analysis_weight_gamlss_new.html">Extract coefficients independent var model</a>
    </li>
    <li>
      <a href="regression_to_interact_analysis_weight_gamlss_new.html">Extract coefficients interaction model</a>
    </li>
    <li>
      <a href="DEC23_meta_analysis_gamlss_weigh.html">Meta-analysis weighted gamlss</a>
    </li>
    <li>
      <a href="meta_analysis_indep_var.html">Meta-analysis independent variables</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Appendix
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="single_regression_gw_py_new.html">Gamlss regression shorter time spans</a>
    </li>
    <li>
      <a href="regression_to_meta_analysis_wg_waves_new.html">Extract coefficients shorter time spans</a>
    </li>
    <li>
      <a href="meta_analysis_gw_waves.html">Meta-analysis shorter time spans</a>
    </li>
    <li>
      <a></a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/apeelen/climatechange">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
<li role="separator" class="divider"></li>
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Extract coefficients of gamlss regressions
shorter time spans</h1>
<h4 class="author">Anuschka Peelen</h4>
<h4 class="date">2024-01-12</h4>

</div>


<p>In this script I extract the coefficients for the time effects and
intercepts and put them in a dataset together, to use them as input for
the meta-regression. This script uses the gamlss regressions with the
time effects over shorter time spans.</p>
<pre class="r"><code>rm(list=ls())
library(tidyverse)
library(dplyr)
library(gamlss)</code></pre>
<div id="evs" class="section level2 unnumbered">
<h2 class="unnumbered">EVS</h2>
<pre class="r"><code># Now the same for the EVS
load(&quot;./data/final_data/regression_outputs/per_wave/evs_list_empty1.RData&quot;)

# Store the results in a new dataframe
evs_empty_df &lt;- data.frame(dep_var = character())

# Loop over the list for all the dep vars
for (i in seq_along(evs_list_empty)) {

  # Extract the name of the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(evs_list_empty[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(evs_list_empty[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  evs_empty_df &lt;- rbind(evs_empty_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
}

# And the predictor model
load(&quot;./data/final_data/regression_outputs/per_wave/evs_list_preds1_new.RData&quot;)

# Store the results in a new dataframe
evs_preds_df &lt;- data.frame(dep_var = character())

# Loop over the list of models
for (i in seq_along(evs_list_preds)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(evs_list_preds[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(evs_list_preds[[i]])
  
  # Extract the intercept and standard deviation for mu and sigma
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results 
  evs_preds_df &lt;- rbind(evs_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
}

# And lastly the interaction model
load(&quot;./data/final_data/regression_outputs/per_wave/evs_list_interactions1_new.RData&quot;)

# Store the results in a new dataframe
evs_interactions_df &lt;- data.frame(dep_var = character())

# Loop over the number of dep vars in the list
for (i in seq_along(evs_list_interactions)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(evs_list_interactions[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(evs_list_interactions[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  evs_interactions_df &lt;- rbind(evs_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
}

# Merge the results, and add some variables with extra information 
evs_results_df &lt;- left_join(evs_empty_df, evs_preds_df)
evs_results_df &lt;- left_join(evs_results_df, evs_interactions_df)
evs_results_df$first_year &lt;- 1990 
evs_results_df$mean_year &lt;- 1995
evs_results_df$waveset &lt;- 1
evs_results_df$data &lt;- &quot;EVS&quot;

save(evs_results_df, file=&quot;./data/final_data/regression_outputs/per_wave/evs_results_df1_new.RData&quot;)</code></pre>
<pre class="r"><code># And the second set
load(&quot;./data/final_data/regression_outputs/per_wave/evs_list_empty2.RData&quot;)

# Store the results in a new dataframe
evs_empty_df &lt;- data.frame(dep_var = character())

# Loop over the list for all the dep vars
for (i in seq_along(evs_list_empty)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(evs_list_empty[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(evs_list_empty[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  evs_empty_df &lt;- rbind(evs_empty_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
}

load(&quot;./data/final_data/regression_outputs/per_wave/evs_list_preds2_new.RData&quot;)

# Store the results in a new dataframe
evs_preds_df &lt;- data.frame(dep_var = character())

# Loop over the list of models
for (i in seq_along(evs_list_preds)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(evs_list_preds[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(evs_list_preds[[i]])
  
  # Extract the intercept and standard deviation for mu and sigma
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results 
  evs_preds_df &lt;- rbind(evs_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
}

# And lastly the interaction model
load(&quot;./data/final_data/regression_outputs/per_wave/evs_list_interactions2_new.RData&quot;)

# Store the results in a new dataframe
evs_interactions_df &lt;- data.frame(dep_var = character())

# Loop over the number of dep vars in the list
for (i in seq_along(evs_list_interactions)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(evs_list_interactions[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(evs_list_interactions[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  evs_interactions_df &lt;- rbind(evs_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
}

# Merge the results
evs_results_df &lt;- left_join(evs_empty_df, evs_preds_df)
evs_results_df &lt;- left_join(evs_results_df, evs_interactions_df)
evs_results_df$first_year &lt;- 1999
evs_results_df$mean_year &lt;- 2004
evs_results_df$waveset &lt;- 2
evs_results_df$data &lt;- &quot;EVS&quot;

save(evs_results_df, file=&quot;./data/final_data/regression_outputs/per_wave/evs_results_df2_new.RData&quot;)</code></pre>
</div>
<div id="io-research" class="section level2 unnumbered">
<h2 class="unnumbered">I&amp;O Research</h2>
<pre class="r"><code>rm(list=ls())
load(&quot;./data/final_data/regression_outputs/per_wave/io_list_empty1.RData&quot;)

# Store the results in a new dataframe
io_empty_df &lt;- data.frame(dep_var = character())

for (i in seq_along(io_list_empty)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(io_list_empty[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(io_list_empty[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  io_empty_df &lt;- rbind(io_empty_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
}

# Predictor model
load(&quot;./data/final_data/regression_outputs/per_wave/io_list_preds1_new.RData&quot;)

# Store the results in a new dataframe
io_preds_df &lt;- data.frame(dep_var = character())

# Loop over the list 
for (i in seq_along(io_list_preds)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(io_list_preds[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(io_list_preds[[i]])
  
  # Extract info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results in a dataframe
  io_preds_df &lt;- rbind(io_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
}

# Interaction model
load(&quot;./data/final_data/regression_outputs/per_wave/io_list_interactions1_new.RData&quot;)

# Store the results in a new dataframe
io_interactions_df &lt;- data.frame(dep_var = character())

# Loop over the number of dep vars in the list
for (i in seq_along(io_list_interactions)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(io_list_interactions[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(io_list_interactions[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  io_interactions_df &lt;- rbind(io_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
}

# Merge the results
io_results_df &lt;- left_join(io_empty_df, io_preds_df)
io_results_df &lt;- left_join(io_results_df, io_interactions_df)
io_results_df$first_year &lt;- 2019
io_results_df$mean_year &lt;- 2020
io_results_df$waveset &lt;- 1
io_results_df$data &lt;- &quot;IO&quot;

save(io_results_df, file=&quot;./data/final_data/regression_outputs/per_wave/io_results_df1_new.RData&quot;)</code></pre>
<pre class="r"><code># Second set
load(&quot;./data/final_data/regression_outputs/per_wave/io_list_empty2.RData&quot;)

# Store the results in a new dataframe
io_empty_df &lt;- data.frame(dep_var = character())

for (i in seq_along(io_list_empty)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(io_list_empty[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(io_list_empty[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  io_empty_df &lt;- rbind(io_empty_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
}

# Predictor model
load(&quot;./data/final_data/regression_outputs/per_wave/io_list_preds2_new.RData&quot;)

# Store the results in a new dataframe
io_preds_df &lt;- data.frame(dep_var = character())

# Loop over the list 
for (i in seq_along(io_list_preds)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(io_list_preds[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(io_list_preds[[i]])
  
  # Extract info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results in a dataframe
  io_preds_df &lt;- rbind(io_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
}

# Interaction model
load(&quot;./data/final_data/regression_outputs/per_wave/io_list_interactions2_new.RData&quot;)

# Store the results in a new dataframe
io_interactions_df &lt;- data.frame(dep_var = character())

# Loop over the number of dep vars in the list
for (i in seq_along(io_list_interactions)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(io_list_interactions[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(io_list_interactions[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  io_interactions_df &lt;- rbind(io_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
}

# Merge the results
io_results_df &lt;- left_join(io_empty_df, io_preds_df)
io_results_df &lt;- left_join(io_results_df, io_interactions_df)
io_results_df$first_year &lt;- 2020
io_results_df$mean_year &lt;- 2021
io_results_df$waveset &lt;- 2
io_results_df$data &lt;- &quot;IO&quot;

save(io_results_df, file=&quot;./data/final_data/regression_outputs/per_wave/io_results_df2_new.RData&quot;)</code></pre>
</div>
<div id="issp" class="section level2 unnumbered">
<h2 class="unnumbered">ISSP</h2>
<pre class="r"><code># Now for ISSP, and then only for the first part bc the second part already consists of 2 waves
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/per_wave/issp_list_empty1.RData&quot;)

# Store the results in a new dataframe
issp_empty_df &lt;- data.frame(dep_var = character())

# Loop over the list for all the dep vars
for (i in seq_along(issp_list_empty)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(issp_list_empty[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(issp_list_empty[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  issp_empty_df &lt;- rbind(issp_empty_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
}

# Predictor model 
load(&quot;./data/final_data/regression_outputs/per_wave/issp_list_preds1_new.RData&quot;)

# Store the results in a new dataframe
issp_preds_df &lt;- data.frame(dep_var = character())

# Loop over the list 
for (i in seq_along(issp_list_preds)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(issp_list_preds[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(issp_list_preds[[i]])
  
  # Extract info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results in a dataframe
  issp_preds_df &lt;- rbind(issp_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
}

# Interaction model
load(&quot;./data/final_data/regression_outputs/per_wave/issp_list_interactions1_new.RData&quot;)

# Store the results in a new dataframe
issp_interactions_df &lt;- data.frame(dep_var = character())

# Loop over the number of dep vars in the list
for (i in seq_along(issp_list_interactions)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(issp_list_interactions[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(issp_list_interactions[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  issp_interactions_df &lt;- rbind(issp_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
}

# Merge the results
issp_results_df &lt;- left_join(issp_empty_df, issp_preds_df)
issp_results_df &lt;- left_join(issp_results_df, issp_interactions_df)
issp_results_df$first_year &lt;- 1993
issp_results_df$mean_year &lt;- 1997
issp_results_df$waveset &lt;- 1
issp_results_df$data &lt;- &quot;ISSP&quot;

save(issp_results_df, file=&quot;./data/final_data/regression_outputs/per_wave/issp_results_df1_new.RData&quot;)</code></pre>
<pre class="r"><code># And the second set
load(&quot;./data/final_data/regression_outputs/per_wave/issp_list_empty2.RData&quot;)

# Store the results in a new dataframe
issp_empty_df &lt;- data.frame(dep_var = character())

# Loop over the list for all the dep vars
for (i in seq_along(issp_list_empty)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(issp_list_empty[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(issp_list_empty[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  issp_empty_df &lt;- rbind(issp_empty_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
}

#Predictor model
load(&quot;./data/final_data/regression_outputs/per_wave/issp_list_preds2_new.RData&quot;)

# Store the results in a new dataframe
issp_preds_df &lt;- data.frame(dep_var = character())

# Loop over the list 
for (i in seq_along(issp_list_preds)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(issp_list_preds[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(issp_list_preds[[i]])
  
  # Extract info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results in a dataframe
  issp_preds_df &lt;- rbind(issp_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
}

# Interaction model
load(&quot;./data/final_data/regression_outputs/per_wave/issp_list_interactions2_new.RData&quot;)

# Store the results in a new dataframe
issp_interactions_df &lt;- data.frame(dep_var = character())

# Loop over the number of dep vars in the list
for (i in seq_along(issp_list_interactions)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(issp_list_interactions[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(issp_list_interactions[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  issp_interactions_df &lt;- rbind(issp_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
}

# Merge the results
issp_results_df &lt;- left_join(issp_empty_df, issp_preds_df)
issp_results_df &lt;- left_join(issp_results_df, issp_interactions_df)
issp_results_df$first_year &lt;- 2000
issp_results_df$mean_year &lt;- 2005
issp_results_df$waveset &lt;- 2
issp_results_df$data &lt;- &quot;ISSP&quot;

save(issp_results_df, file=&quot;./data/final_data/regression_outputs/per_wave/issp_results_df2_new.RData&quot;)</code></pre>
</div>
<div id="eb" class="section level2 unnumbered">
<h2 class="unnumbered">EB</h2>
<pre class="r"><code># For all the eurobarometer waves, exactly the same needs to be done each time. Therefore I want to loop over these different lists. 

# First load all the eurobarometer lists with empty models in my environment
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/per_wave/eb_list_empty_1986_1.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_empty_2007_1.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_empty_2009_1.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_empty_2011_w.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_empty_buyprod1.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_empty_cchange2_1.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_empty_doprot1.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_empty_eff_daily1.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_empty_pers_imp1.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_empty_prsaction1.RData&quot;)
load(&quot;./data/final_data/regression_outputs/per_wave/eb_list_empty_quallife1.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_empty_doprot_city_w.RData&quot;)

# Store the results in a new dataframe
eb_results_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the list for all the dep vars
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  eb_results_df &lt;- rbind(eb_results_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
    }
  } 
} 

# It produces an error, but actually everything has worked as i wish
eb_results_empty_df &lt;- eb_results_df
eb_results_empty_df$waveset &lt;- 1

# Save it
save(eb_results_empty_df, file= &quot;./data/final_data/regression_outputs/per_wave/eb_results_empty_df1_new.RData&quot; )</code></pre>
<pre class="r"><code># Second set
# First load all the eurobarometer lists with empty models in my environment
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/per_wave/eb_list_empty_1986_2.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_empty_2007_2.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_empty_2009_2.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_empty_buyprod2.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_empty_cchange2_2.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_empty_doprot2.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_empty_eff_daily2.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_empty_pers_imp2.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_empty_prsaction2.RData&quot;)
load(&quot;./data/final_data/regression_outputs/per_wave/eb_list_empty_quallife2.RData&quot;)


# Store the results in a new dataframe
eb_results_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the list for all the dep vars
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  eb_results_df &lt;- rbind(eb_results_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
    }
  } 
} 

# It produces an error, but actually everything has worked 
eb_results_empty_df &lt;- eb_results_df
eb_results_empty_df$waveset &lt;- 2

save(eb_results_empty_df, file= &quot;./data/final_data/regression_outputs/per_wave/eb_results_empty_df2_new.RData&quot; )</code></pre>
<pre class="r"><code># Some of them have a third set
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/eb_list_empty_2007_3.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_empty_2009_3.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_empty_cchange2_3.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_empty_eff_daily3.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_empty_prsaction3.RData&quot;)
load(&quot;./data/final_data/regression_outputs/per_wave/eb_list_empty_quallife3.RData&quot;)

# Store the results in a new dataframe
eb_results_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the list for all the dep vars
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  eb_results_df &lt;- rbind(eb_results_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
    }
  } 
} 

# It produces an error, but actually everything has worked 
eb_results_empty_df &lt;- eb_results_df
eb_results_empty_df$waveset &lt;- 3

save(eb_results_empty_df, file= &quot;./data/final_data/regression_outputs/per_wave/eb_results_empty_df3_new.RData&quot; )</code></pre>
<pre class="r"><code># Some even a fourth time
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/eb_list_empty_2009_4.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_empty_cchange2_4.RData&quot;)

# Store the results in a new dataframe
eb_results_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the list for all the dep vars
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  eb_results_df &lt;- rbind(eb_results_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
    }
  } 
} 

# It produces an error, but actually everything has worked 
eb_results_empty_df &lt;- eb_results_df
eb_results_empty_df$waveset &lt;- 4

save(eb_results_empty_df, file= &quot;./data/final_data/regression_outputs/per_wave/eb_results_empty_df4_new.RData&quot; )</code></pre>
<pre class="r"><code># And a fifth time
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/eb_list_empty_2009_5.RData&quot;)

# Store the results in a new dataframe
eb_results_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the list for all the dep vars
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  eb_results_df &lt;- rbind(eb_results_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
    }
  } 
} 

# It produces an error, but actually everything has worked 
eb_results_empty_df &lt;- eb_results_df
eb_results_empty_df$waveset &lt;- 5

save(eb_results_empty_df, file= &quot;./data/final_data/regression_outputs/per_wave/eb_results_empty_df5_new.RData&quot; )</code></pre>
<pre class="r"><code># Now i want the same for the models with the predictors
# First clear the environment because I don&#39;t want the empty lists iterated in the predictor loop
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/per_wave/eb_list_preds_1986_1_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_2007_1_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_2008_w_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_2009_1_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_2011_w_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_buyprod1_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_cchange2_1_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_doprot1_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_eff_daily1_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_pers_imp1_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_prsaction1_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/per_wave/eb_list_preds_quallife1_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_doprot_city_w_new.RData&quot;)


# Store the results in a new dataframe
eb_results_preds_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the list 
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results in a dataframe
  eb_results_preds_df &lt;- rbind(eb_results_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
    }
  }
} 

eb_results_preds_df$waveset &lt;- 1

# Again, an error, but the output is correct
save(eb_results_preds_df, file= &quot;./data/final_data/regression_outputs/per_wave/eb_results_preds_df1_new.RData&quot; )</code></pre>
<pre class="r"><code># Second set
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/per_wave/eb_list_preds_1986_2_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_2007_2_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_2009_2_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_buyprod2_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_cchange2_2_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_doprot2_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_eff_daily2_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_pers_imp2_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_prsaction2_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/per_wave/eb_list_preds_quallife2_new.RData&quot;)


# Store the results in a new dataframe
eb_results_preds_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the list 
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results in a dataframe
  eb_results_preds_df &lt;- rbind(eb_results_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
    }
  }
} 

eb_results_preds_df$waveset &lt;- 2

# Again, an error, but the output is correct
save(eb_results_preds_df, file= &quot;./data/final_data/regression_outputs/per_wave/eb_results_preds_df2_new.RData&quot; )</code></pre>
<pre class="r"><code># Third set
rm(list=ls())

load(&quot;./data/final_data/regression_outputs/eb_list_preds_2007_3_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_2009_3_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_cchange2_3_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_eff_daily3_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_prsaction3_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/per_wave/eb_list_preds_quallife3_new.RData&quot;)


# Store the results in a new dataframe
eb_results_preds_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the list 
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results in a dataframe
  eb_results_preds_df &lt;- rbind(eb_results_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
    }
  }
} 

eb_results_preds_df$waveset &lt;- 3

# Again, an error, but the output is correct
save(eb_results_preds_df, file= &quot;./data/final_data/regression_outputs/per_wave/eb_results_preds_df3_new.RData&quot; )</code></pre>
<pre class="r"><code># Fourth set
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/eb_list_preds_2009_4_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_preds_cchange2_4_new.RData&quot;)


# Store the results in a new dataframe
eb_results_preds_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the list 
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results in a dataframe
  eb_results_preds_df &lt;- rbind(eb_results_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
    }
  }
} 

eb_results_preds_df$waveset &lt;- 4

# Again, an error, but the output is correct
save(eb_results_preds_df, file= &quot;./data/final_data/regression_outputs/per_wave/eb_results_preds_df4_new.RData&quot; )</code></pre>
<pre class="r"><code># And finally the fifth 
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/eb_list_preds_2009_5_new.RData&quot;)

# Store the results in a new dataframe
eb_results_preds_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the list 
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results in a dataframe
  eb_results_preds_df &lt;- rbind(eb_results_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
    }
  }
} 

eb_results_preds_df$waveset &lt;- 5

# Again, an error, but the output is correct
save(eb_results_preds_df, file= &quot;./data/final_data/regression_outputs/per_wave/eb_results_preds_df5_new.RData&quot; )</code></pre>
<pre class="r"><code># Lastly for the interaction models
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_1986_w_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_2007_1_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_2008_w_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_2009_1_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_2011_w_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_buyprod1_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_cchange2_1_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_doprot1_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_eff_daily1_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_pers_imp1_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_prsaction1_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/per_wave/eb_list_interactions_quallife1_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_doprot_city_w_new.RData&quot;)


# Store the results in a new dataframe
eb_results_interactions_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the number of dep vars in the list
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  eb_results_interactions_df &lt;- rbind(eb_results_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
    }
  } 
} 

eb_results_interactions_df$waveset &lt;- 1

save(eb_results_interactions_df, file= &quot;./data/final_data/regression_outputs/per_wave/eb_results_interactions_df1_new.RData&quot; )</code></pre>
<pre class="r"><code># Second set
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_2007_2_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_2009_2_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_buyprod2_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_cchange2_2_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_doprot2_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_eff_daily2_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_pers_imp2_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_prsaction2_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/per_wave/eb_list_interactions_quallife2_new.RData&quot;)


# Store the results in a new dataframe
eb_results_interactions_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the number of dep vars in the list
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  eb_results_interactions_df &lt;- rbind(eb_results_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
    }
  } 
} 

eb_results_interactions_df$waveset &lt;- 2

save(eb_results_interactions_df, file= &quot;./data/final_data/regression_outputs/per_wave/eb_results_interactions_df2_new.RData&quot; )</code></pre>
<pre class="r"><code># Third set
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_2007_3_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_2009_3_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_cchange2_3_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_eff_daily3_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_prsaction3_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/per_wave/eb_list_interactions_quallife3_new.RData&quot;)


# Store the results in a new dataframe
eb_results_interactions_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the number of dep vars in the list
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  eb_results_interactions_df &lt;- rbind(eb_results_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
    }
  } 
} 

eb_results_interactions_df$waveset &lt;- 3

save(eb_results_interactions_df, file= &quot;./data/final_data/regression_outputs/per_wave/eb_results_interactions_df3_new.RData&quot; )</code></pre>
<pre class="r"><code># Fourth set
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_2009_4_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_cchange2_4_new.RData&quot;)

# Store the results in a new dataframe
eb_results_interactions_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the number of dep vars in the list
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  eb_results_interactions_df &lt;- rbind(eb_results_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
    }
  } 
} 

eb_results_interactions_df$waveset &lt;- 4

save(eb_results_interactions_df, file= &quot;./data/final_data/regression_outputs/per_wave/eb_results_interactions_df4_new.RData&quot; )</code></pre>
<pre class="r"><code># And the fifth 
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/eb_list_interactions_2009_5_new.RData&quot;)

# Store the results in a new dataframe
eb_results_interactions_df &lt;- data.frame(dep_var = character())

# Get the lists from the environment
lists &lt;- ls()

for (j in lists) { 
  if(is.list(get(j))) { 
    my_list &lt;- get(j)

# Loop over the number of dep vars in the list
for (i in seq_along(my_list)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(my_list[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(my_list[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  eb_results_interactions_df &lt;- rbind(eb_results_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
    }
  } 
} 

eb_results_interactions_df$waveset &lt;- 5

save(eb_results_interactions_df, file= &quot;./data/final_data/regression_outputs/per_wave/eb_results_interactions_df5_new.RData&quot; )</code></pre>
</div>
<div id="socon" class="section level2 unnumbered">
<h2 class="unnumbered">SOCON</h2>
<pre class="r"><code># Now the same for the SOCON
rm(list = ls())
load(&quot;./data/final_data/regression_outputs/per_wave/socon_list_empty1.RData&quot;)

# Store the results in a new dataframe
socon_empty_df &lt;- data.frame(dep_var = character())

# Loop over the list for all the dep vars
for (i in seq_along(socon_list_empty)) {

  # Extract the name of the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(socon_list_empty[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(socon_list_empty[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  socon_empty_df &lt;- rbind(socon_empty_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
}

# And the predictor model
load(&quot;./data/final_data/regression_outputs/per_wave/socon_list_preds1_new.RData&quot;)

# Store the results in a new dataframe
socon_preds_df &lt;- data.frame(dep_var = character())

# Loop over the list of models
for (i in seq_along(socon_list_preds)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(socon_list_preds[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(socon_list_preds[[i]])
  
  # Extract the intercept and standard deviation for mu and sigma
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results 
  socon_preds_df &lt;- rbind(socon_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
}

# And lastly the interaction model
load(&quot;./data/final_data/regression_outputs/per_wave/socon_list_interactions1_new.RData&quot;)

# Store the results in a new dataframe
socon_interactions_df &lt;- data.frame(dep_var = character())

# Loop over the number of dep vars in the list
for (i in seq_along(socon_list_interactions)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(socon_list_interactions[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(socon_list_interactions[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  socon_interactions_df &lt;- rbind(socon_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
}

# Merge the results, and add some variables with extra information 
socon_results_df &lt;- merge(socon_empty_df, socon_preds_df)
socon_results_df &lt;- merge(socon_results_df, socon_interactions_df)
socon_results_df$first_year &lt;- 2020 
socon_results_df$mean_year &lt;- 2021
socon_results_df$waveset &lt;- 1
socon_results_df$data &lt;- &quot;SOCON&quot;

save(socon_results_df, file=&quot;./data/final_data/regression_outputs/per_wave/socon_results_df1_new.RData&quot;)</code></pre>
<pre class="r"><code># Now the same for the SOCON
rm(list = ls())
load(&quot;./data/final_data/regression_outputs/per_wave/socon_list_empty2.RData&quot;)

# Store the results in a new dataframe
socon_empty_df &lt;- data.frame(dep_var = character())

# Loop over the list for all the dep vars
for (i in seq_along(socon_list_empty)) {

  # Extract the name of the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(socon_list_empty[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(socon_list_empty[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  socon_empty_df &lt;- rbind(socon_empty_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
}

# And the predictor model
load(&quot;./data/final_data/regression_outputs/per_wave/socon_list_preds2_new.RData&quot;)

# Store the results in a new dataframe
socon_preds_df &lt;- data.frame(dep_var = character())

# Loop over the list of models
for (i in seq_along(socon_list_preds)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(socon_list_preds[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(socon_list_preds[[i]])
  
  # Extract the intercept and standard deviation for mu and sigma
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results 
  socon_preds_df &lt;- rbind(socon_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
}

# And lastly the interaction model
load(&quot;./data/final_data/regression_outputs/per_wave/socon_list_interactions2_new.RData&quot;)

# Store the results in a new dataframe
socon_interactions_df &lt;- data.frame(dep_var = character())

# Loop over the number of dep vars in the list
for (i in seq_along(socon_list_interactions)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(socon_list_interactions[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(socon_list_interactions[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  socon_interactions_df &lt;- rbind(socon_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
}

# Merge the results, and add some variables with extra information 
socon_results_df &lt;- merge(socon_empty_df, socon_preds_df)
socon_results_df &lt;- merge(socon_results_df, socon_interactions_df)
socon_results_df$first_year &lt;- 2021 
socon_results_df$mean_year &lt;- 2021
socon_results_df$waveset &lt;- 2
socon_results_df$data &lt;- &quot;SOCON&quot;

save(socon_results_df, file=&quot;./data/final_data/regression_outputs/per_wave/socon_results_df2_new.RData&quot;)</code></pre>
</div>
<div id="liss" class="section level2 unnumbered">
<h2 class="unnumbered">LISS</h2>
<pre class="r"><code># Now the same for the LISS
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/per_wave/liss_list_empty1.RData&quot;)

# Store the results in a new dataframe
liss_empty_df &lt;- data.frame(dep_var = character())

# Loop over the list for all the dep vars
for (i in seq_along(liss_list_empty)) {

  # Extract the name of the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(liss_list_empty[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(liss_list_empty[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  liss_empty_df &lt;- rbind(liss_empty_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
}

# And the predictor model
load(&quot;./data/final_data/regression_outputs/per_wave/liss_list_preds1_new.RData&quot;)

# Store the results in a new dataframe
liss_preds_df &lt;- data.frame(dep_var = character())

# Loop over the list of models
for (i in seq_along(liss_list_preds)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(liss_list_preds[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(liss_list_preds[[i]])
  
  # Extract the intercept and standard deviation for mu and sigma
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results 
  liss_preds_df &lt;- rbind(liss_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
}

# And lastly the interaction model
load(&quot;./data/final_data/regression_outputs/per_wave/liss_list_interactions1_new.RData&quot;)

# Store the results in a new dataframe
liss_interactions_df &lt;- data.frame(dep_var = character())

# Loop over the number of dep vars in the list
for (i in seq_along(liss_list_interactions)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(liss_list_interactions[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(liss_list_interactions[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  liss_interactions_df &lt;- rbind(liss_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
}

# Merge the results, and add some variables with extra information 
liss_results_df &lt;- merge(liss_empty_df, liss_preds_df)
liss_results_df &lt;- merge(liss_results_df, liss_interactions_df)
liss_results_df$first_year &lt;- 2019
liss_results_df$mean_year &lt;- 2020
liss_results_df$waveset &lt;- 1
liss_results_df$data &lt;- &quot;LISS&quot;

save(liss_results_df, file=&quot;./data/final_data/regression_outputs/per_wave/liss_results_df1_new.RData&quot;)</code></pre>
<pre class="r"><code># Now the same for the LISS
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/per_wave/liss_list_empty2.RData&quot;)

# Store the results in a new dataframe
liss_empty_df &lt;- data.frame(dep_var = character())

# Loop over the list for all the dep vars
for (i in seq_along(liss_list_empty)) {

  # Extract the name of the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(liss_list_empty[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(liss_list_empty[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  liss_empty_df &lt;- rbind(liss_empty_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
}

# And the predictor model
load(&quot;./data/final_data/regression_outputs/per_wave/liss_list_preds2_new.RData&quot;)

# Store the results in a new dataframe
liss_preds_df &lt;- data.frame(dep_var = character())

# Loop over the list of models
for (i in seq_along(liss_list_preds)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(liss_list_preds[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(liss_list_preds[[i]])
  
  # Extract the intercept and standard deviation for mu and sigma
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results 
  liss_preds_df &lt;- rbind(liss_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
}

# And lastly the interaction model
load(&quot;./data/final_data/regression_outputs/per_wave/liss_list_interactions2_new.RData&quot;)

# Store the results in a new dataframe
liss_interactions_df &lt;- data.frame(dep_var = character())

# Loop over the number of dep vars in the list
for (i in seq_along(liss_list_interactions)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(liss_list_interactions[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(liss_list_interactions[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  liss_interactions_df &lt;- rbind(liss_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
}

# Merge the results, and add some variables with extra information 
liss_results_df &lt;- merge(liss_empty_df, liss_preds_df)
liss_results_df &lt;- merge(liss_results_df, liss_interactions_df)
liss_results_df$first_year &lt;- 2020
liss_results_df$mean_year &lt;- 2020
liss_results_df$waveset &lt;- 2
liss_results_df$data &lt;- &quot;LISS&quot;

save(liss_results_df, file=&quot;./data/final_data/regression_outputs/per_wave/liss_results_df2_new.RData&quot;)</code></pre>
<pre class="r"><code># Now the same for the LISS
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/per_wave/liss_list_empty3.RData&quot;)

# Store the results in a new dataframe
liss_empty_df &lt;- data.frame(dep_var = character())

# Loop over the list for all the dep vars
for (i in seq_along(liss_list_empty)) {

  # Extract the name of the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(liss_list_empty[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(liss_list_empty[[i]])
  
  # Extract the info
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[3]]
  sigma_sd &lt;- sum[[3,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[4]]
  sig_time_sd &lt;- sum[[4,2]]
  
  # Put the results in a dataframe
  liss_empty_df &lt;- rbind(liss_empty_df, data.frame(dep_var = dep_var, mu_intercept = mu_int, mu_sd = mu_sd, sigma_intercept = sigma_int, sigma_sd = sigma_sd, mu_time = mu_time, mu_time_sd = mu_time_sd, sig_time = sig_time, sig_time_sd = sig_time_sd))
}

# And the predictor model
load(&quot;./data/final_data/regression_outputs/per_wave/liss_list_preds3_new.RData&quot;)

# Store the results in a new dataframe
liss_preds_df &lt;- data.frame(dep_var = character())

# Loop over the list of models
for (i in seq_along(liss_list_preds)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(liss_list_preds[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(liss_list_preds[[i]])
  
  # Extract the intercept and standard deviation for mu and sigma
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[7]]
  sigma_sd &lt;- sum[[7,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[8]]
  sig_time_sd &lt;- sum[[8,2]]
  
  # Put the results 
  liss_preds_df &lt;- rbind(liss_preds_df, data.frame(dep_var = dep_var, mu_intercept_pred = mu_int, mu_sd_pred = mu_sd, sigma_intercept_pred = sigma_int, sigma_sd_pred = sigma_sd, mu_time_pred = mu_time, mu_time_sd_pred = mu_time_sd, sig_time_pred = sig_time, sig_time_sd_pred = sig_time_sd))
}

# And lastly the interaction model
load(&quot;./data/final_data/regression_outputs/per_wave/liss_list_interactions3_new.RData&quot;)

# Store the results in a new dataframe
liss_interactions_df &lt;- data.frame(dep_var = character())

# Loop over the number of dep vars in the list
for (i in seq_along(liss_list_interactions)) {

  # Extract the dependent variable so that we know for which dep var the effects are
  dep_var &lt;- as.character(liss_list_interactions[[i]]$mu.terms[[2]])
  
    # Summarize the model
  sum &lt;- summary(liss_list_interactions[[i]])
  
  # Extract the info I need from the summary
  mu_int &lt;- sum[[1]]
  mu_sd &lt;- sum[[1,2]]
  sigma_int &lt;- sum[[11]]
  sigma_sd &lt;- sum[[11,2]]
  mu_time &lt;- sum [[2]]
  mu_time_sd &lt;- sum[[2,2]]
  sig_time &lt;- sum[[12]]
  sig_time_sd &lt;- sum[[12,2]]
  
  # Put the results in a dataframe
  liss_interactions_df &lt;- rbind(liss_interactions_df, data.frame(dep_var = dep_var, mu_intercept_int = mu_int, mu_sd_int = mu_sd, sigma_intercept_int = sigma_int, sigma_sd_int = sigma_sd, mu_time_int = mu_time, mu_time_sd_int = mu_time_sd, sig_time_int = sig_time, sig_time_sd_int = sig_time_sd))
}

# Merge the results, and add some variables with extra information 
liss_results_df &lt;- merge(liss_empty_df, liss_preds_df)
liss_results_df &lt;- merge(liss_results_df, liss_interactions_df)
liss_results_df$first_year &lt;- 2020
liss_results_df$mean_year &lt;- 2021
liss_results_df$waveset &lt;- 3
liss_results_df$data &lt;- &quot;LISS&quot;

save(liss_results_df, file=&quot;./data/final_data/regression_outputs/per_wave/liss_results_df3_new.RData&quot;)</code></pre>
<pre class="r"><code># Make one dataframe
# First empty lists
rm(list=ls())
# They all have the same names, so I have to assign them a new name
load(&quot;./data/final_data/regression_outputs/per_wave/eb_results_empty_df1_new.RData&quot;)
eb_1_df &lt;- eb_results_empty_df
load(&quot;./data/final_data/regression_outputs/per_wave/eb_results_empty_df2_new.RData&quot;)
eb_2_df &lt;- eb_results_empty_df
load(&quot;./data/final_data/regression_outputs/per_wave/eb_results_empty_df3_new.RData&quot;)
eb_3_df &lt;- eb_results_empty_df
load(&quot;./data/final_data/regression_outputs/per_wave/eb_results_empty_df4_new.RData&quot;)
eb_4_df &lt;- eb_results_empty_df
load(&quot;./data/final_data/regression_outputs/per_wave/eb_results_empty_df5_new.RData&quot;)
eb_5_df &lt;- eb_results_empty_df

eb_empty_df_waves &lt;- rbind (eb_1_df, eb_2_df, eb_3_df, eb_4_df, eb_5_df)
eb_empty_df_waves$dep_var_wave &lt;- paste(eb_empty_df_waves$dep_var, eb_empty_df_waves$waveset, sep = &quot;_&quot;)

save(eb_empty_df_waves, file= &quot;./data/final_data/regression_outputs/per_wave/eb_empty_df_waves_new.RData&quot; )


# For the pred models
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/per_wave/eb_results_preds_df1_new.RData&quot;)
eb_1_df &lt;- eb_results_preds_df
load(&quot;./data/final_data/regression_outputs/per_wave/eb_results_preds_df2_new.RData&quot;)
eb_2_df &lt;- eb_results_preds_df
load(&quot;./data/final_data/regression_outputs/per_wave/eb_results_preds_df3_new.RData&quot;)
eb_3_df &lt;- eb_results_preds_df
load(&quot;./data/final_data/regression_outputs/per_wave/eb_results_preds_df4_new.RData&quot;)
eb_4_df &lt;- eb_results_preds_df
load(&quot;./data/final_data/regression_outputs/per_wave/eb_results_preds_df5_new.RData&quot;)
eb_5_df &lt;- eb_results_preds_df

eb_preds_df_waves &lt;- rbind (eb_1_df, eb_2_df, eb_3_df, eb_4_df, eb_5_df)
eb_preds_df_waves$dep_var_wave &lt;- paste(eb_preds_df_waves$dep_var, eb_preds_df_waves$waveset, sep = &quot;_&quot;)

save(eb_preds_df_waves, file= &quot;./data/final_data/regression_outputs/per_wave/eb_preds_df_waves_new.RData&quot; )

# And lastly the same for the interactions
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/per_wave/eb_results_interactions_df1_new.RData&quot;)
eb_1_df &lt;- eb_results_interactions_df
load(&quot;./data/final_data/regression_outputs/per_wave/eb_results_interactions_df2_new.RData&quot;)
eb_2_df &lt;- eb_results_interactions_df
load(&quot;./data/final_data/regression_outputs/per_wave/eb_results_interactions_df3_new.RData&quot;)
eb_3_df &lt;- eb_results_interactions_df
load(&quot;./data/final_data/regression_outputs/per_wave/eb_results_interactions_df4_new.RData&quot;)
eb_4_df &lt;- eb_results_interactions_df
load(&quot;./data/final_data/regression_outputs/per_wave/eb_results_interactions_df5_new.RData&quot;)
eb_5_df &lt;- eb_results_interactions_df

eb_interactions_df_waves &lt;- rbind (eb_1_df, eb_2_df, eb_3_df, eb_4_df, eb_5_df)
eb_interactions_df_waves$dep_var_wave &lt;- paste(eb_interactions_df_waves$dep_var, eb_interactions_df_waves$waveset, sep = &quot;_&quot;)

save(eb_interactions_df_waves, file= &quot;./data/final_data/regression_outputs/per_wave/eb_interactions_df_waves_new.RData&quot; )

# And now one large dataframe of these three 
load(&quot;./data/final_data/regression_outputs/per_wave/eb_empty_df_waves_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/per_wave/eb_preds_df_waves_new.RData&quot;)

# Merge the results
eb_results_df &lt;- left_join(eb_empty_df_waves, eb_preds_df_waves)
eb_results_df &lt;- left_join(eb_results_df, eb_interactions_df_waves)
eb_results_df$data &lt;- &quot;EB&quot;

# Assign year per variable
eb_results_df$first_year[eb_results_df$dep_var == &quot;role_ind&quot;] &lt;- 2007
eb_results_df$first_year[eb_results_df$dep_var == &quot;big_pol&quot;] &lt;- 2007
eb_results_df$first_year[eb_results_df$dep_var == &quot;cc_unstop&quot;] &lt;- 2008
eb_results_df$first_year[eb_results_df$dep_var == &quot;cc_exag&quot;] &lt;- 2008
eb_results_df$first_year[eb_results_df$dep_var == &quot;cc_poseu&quot;] &lt;- 2008
eb_results_df$first_year[eb_results_df$dep_var == &quot;cc_prsact&quot;] &lt;- 2008
eb_results_df$first_year[eb_results_df$dep_var == &quot;cc_poseu&quot;] &lt;- 2008
eb_results_df$first_year[eb_results_df$dep_var == &quot;ccpercept&quot;] &lt;- 2009
eb_results_df$first_year[eb_results_df$dep_var == &quot;cchange&quot;] &lt;- 2009
eb_results_df$first_year[eb_results_df$dep_var == &quot;cchange2&quot;] &lt;- 2011
eb_results_df$first_year[eb_results_df$dep_var == &quot;cchangetot&quot;] &lt;- 2011
eb_results_df$first_year[eb_results_df$dep_var == &quot;envp_eg&quot;] &lt;- 2011
eb_results_df$first_year[eb_results_df$dep_var == &quot;effr_eg&quot;] &lt;- 2011
eb_results_df$first_year[eb_results_df$dep_var == &quot;buyprod&quot;] &lt;- 2007
eb_results_df$first_year[eb_results_df$dep_var == &quot;doprot_natgov&quot;] &lt;- 2009
eb_results_df$first_year[eb_results_df$dep_var == &quot;doprot_eu&quot;] &lt;- 2009
eb_results_df$first_year[eb_results_df$dep_var == &quot;doprot_region&quot;] &lt;- 2009
eb_results_df$first_year[eb_results_df$dep_var == &quot;doprot_comp&quot;] &lt;- 2009
eb_results_df$first_year[eb_results_df$dep_var == &quot;doprot_citiz&quot;] &lt;- 2009
eb_results_df$first_year[eb_results_df$dep_var == &quot;doprot_city&quot;] &lt;- 2014
eb_results_df$first_year[eb_results_df$dep_var == &quot;eff_daily&quot;] &lt;- 2007
eb_results_df$first_year[eb_results_df$dep_var == &quot;pers_imp&quot;] &lt;- 2009
eb_results_df$first_year[eb_results_df$dep_var == &quot;env_quallife&quot;] &lt;- 2004
eb_results_df$first_year[eb_results_df$dep_var == &quot;prsaction&quot;] &lt;- 2011

# And the average year 
eb_results_df$mean_year[eb_results_df$dep_var == &quot;role_ind&quot;] &lt;- 2012
eb_results_df$mean_year[eb_results_df$dep_var == &quot;big_pol&quot;] &lt;- 2012
eb_results_df$mean_year[eb_results_df$dep_var == &quot;cc_unstop&quot;] &lt;- 2008
eb_results_df$mean_year[eb_results_df$dep_var == &quot;cc_exag&quot;] &lt;- 2008
eb_results_df$mean_year[eb_results_df$dep_var == &quot;cc_poseu&quot;] &lt;- 2008
eb_results_df$mean_year[eb_results_df$dep_var == &quot;cc_prsact&quot;] &lt;- 2008
eb_results_df$mean_year[eb_results_df$dep_var == &quot;cc_poseu&quot;] &lt;- 2008
eb_results_df$mean_year[eb_results_df$dep_var == &quot;ccpercept&quot;] &lt;- 2014
eb_results_df$mean_year[eb_results_df$dep_var == &quot;cchange&quot;] &lt;- 2015
eb_results_df$mean_year[eb_results_df$dep_var == &quot;cchange2&quot;] &lt;- 2015
eb_results_df$mean_year[eb_results_df$dep_var == &quot;cchangetot&quot;] &lt;- 2015
eb_results_df$mean_year[eb_results_df$dep_var == &quot;envp_eg&quot;] &lt;- 2013
eb_results_df$mean_year[eb_results_df$dep_var == &quot;effr_eg&quot;] &lt;- 2013
eb_results_df$mean_year[eb_results_df$dep_var == &quot;buyprod&quot;] &lt;- 2010
eb_results_df$mean_year[eb_results_df$dep_var == &quot;doprot_natgov&quot;] &lt;- 2013
eb_results_df$mean_year[eb_results_df$dep_var == &quot;doprot_eu&quot;] &lt;- 2013
eb_results_df$mean_year[eb_results_df$dep_var == &quot;doprot_region&quot;] &lt;- 2013
eb_results_df$mean_year[eb_results_df$dep_var == &quot;doprot_comp&quot;] &lt;- 2013
eb_results_df$mean_year[eb_results_df$dep_var == &quot;doprot_citiz&quot;] &lt;- 2013
eb_results_df$mean_year[eb_results_df$dep_var == &quot;doprot_city&quot;] &lt;- 2015
eb_results_df$mean_year[eb_results_df$dep_var == &quot;eff_daily&quot;] &lt;- 2012
eb_results_df$mean_year[eb_results_df$dep_var == &quot;pers_imp&quot;] &lt;- 2009
eb_results_df$mean_year[eb_results_df$dep_var == &quot;env_quallife&quot;] &lt;- 2009
eb_results_df$mean_year[eb_results_df$dep_var == &quot;prsaction&quot;] &lt;- 2014

save(eb_results_df, file= &quot;./data/final_data/regression_outputs/per_wave/eb_results_df_waves_total_new.RData&quot; )</code></pre>
<pre class="r"><code># The same needs to be done for EVS, I&amp;O and ISSP
# EVS
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/per_wave/evs_results_df1_new.RData&quot;)
evs_1_df &lt;- evs_results_df
load(&quot;./data/final_data/regression_outputs/per_wave/evs_results_df2_new.RData&quot;)
evs_2_df &lt;- evs_results_df

evs_results_df_waves &lt;- rbind (evs_1_df, evs_2_df)
evs_results_df_waves$dep_var_wave &lt;- paste(evs_results_df_waves$dep_var, evs_results_df_waves$waveset, sep = &quot;_&quot;)

save(evs_results_df_waves, file= &quot;./data/final_data/regression_outputs/per_wave/evs_results_df_waves_new.RData&quot; )

# I&amp;O
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/per_wave/io_results_df1_new.RData&quot;)
io_1_df &lt;- io_results_df
load(&quot;./data/final_data/regression_outputs/per_wave/io_results_df2_new.RData&quot;)
io_2_df &lt;- io_results_df

io_results_df_waves &lt;- rbind (io_1_df, io_2_df)
io_results_df_waves$dep_var_wave &lt;- paste(io_results_df_waves$dep_var, io_results_df_waves$waveset, sep = &quot;_&quot;)

save(io_results_df_waves, file= &quot;./data/final_data/regression_outputs/per_wave/io_results_df_waves_new.RData&quot; )

# And ISSP
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/per_wave/issp_results_df1_new.RData&quot;)
issp_1_df &lt;- issp_results_df
load(&quot;./data/final_data/regression_outputs/per_wave/issp_results_df2_new.RData&quot;)
issp_2_df &lt;- issp_results_df

issp_results_df_waves &lt;- rbind (issp_1_df, issp_2_df)
issp_results_df_waves$dep_var_wave &lt;- paste(issp_results_df_waves$dep_var, issp_results_df_waves$waveset, sep = &quot;_&quot;)

save(issp_results_df_waves, file= &quot;./data/final_data/regression_outputs/per_wave/issp_results_df_waves_new.RData&quot; )

# SOCON
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/per_wave/socon_results_df1_new.RData&quot;)
socon_1_df &lt;- socon_results_df
load(&quot;./data/final_data/regression_outputs/per_wave/socon_results_df2_new.RData&quot;)
socon_2_df &lt;- socon_results_df

socon_results_df_waves &lt;- rbind (socon_1_df, socon_2_df)
socon_results_df_waves$dep_var_wave &lt;- paste(socon_results_df_waves$dep_var, socon_results_df_waves$waveset, sep = &quot;_&quot;)

save(socon_results_df_waves, file= &quot;./data/final_data/regression_outputs/per_wave/socon_results_df_waves_new.RData&quot; )

# LISS
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/per_wave/liss_results_df1_new.RData&quot;)
liss_1_df &lt;- liss_results_df
load(&quot;./data/final_data/regression_outputs/per_wave/liss_results_df2_new.RData&quot;)
liss_2_df &lt;- liss_results_df
load(&quot;./data/final_data/regression_outputs/per_wave/liss_results_df3_new.RData&quot;)
liss_3_df &lt;- liss_results_df

liss_results_df_waves &lt;- rbind (liss_1_df, liss_2_df, liss_3_df)
liss_results_df_waves$dep_var_wave &lt;- paste(liss_results_df_waves$dep_var, liss_results_df_waves$waveset, sep = &quot;_&quot;)

save(liss_results_df_waves, file= &quot;./data/final_data/regression_outputs/per_wave/liss_results_df_waves_new.RData&quot; )</code></pre>
<pre class="r"><code># The final step is to merge all results into one dataframe
rm(list=ls())
load(&quot;./data/final_data/regression_outputs/ess_results_df_w_new.RData&quot;)
ess_results_df$waveset &lt;- 1
ess_results_df$dep_var_wave &lt;- paste(ess_results_df$dep_var, ess_results_df$waveset, sep = &quot;_&quot;)

load(&quot;./data/final_data/regression_outputs/issp_results_2_df_new.RData&quot;)

issp_results_2_df$mean_year &lt;- 2005
issp_results_2_df$waveset &lt;- 1
issp_results_2_df$dep_var_wave &lt;- paste(issp_results_2_df$dep_var, issp_results_2_df$waveset, sep = &quot;_&quot;)

load(&quot;./data/final_data/regression_outputs/mot_results_df_w_new.RData&quot;)
mot_results_df$waveset &lt;- 1
mot_results_df$dep_var_wave &lt;- paste(mot_results_df$dep_var, mot_results_df$waveset, sep = &quot;_&quot;)


load(&quot;./data/final_data/regression_outputs/per_wave/evs_results_df_waves_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/per_wave/io_results_df_waves_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/per_wave/issp_results_df_waves_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/per_wave/eb_results_df_waves_total_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/per_wave/socon_results_df_waves_new.RData&quot;)
load(&quot;./data/final_data/regression_outputs/per_wave/liss_results_df_waves_new.RData&quot;)

total_results_waves &lt;- rbind(eb_results_df, ess_results_df, evs_results_df_waves, io_results_df_waves, issp_results_df_waves, issp_results_2_df, mot_results_df, socon_results_df_waves, liss_results_df_waves) 

save(total_results_waves, file= &quot;./data/meta_analysis/total_results_waves_new.RData&quot; )</code></pre>
<pre class="r"><code># I also want to add a variable that describes whether the dependent variable is mostly of affective, behavioral or cognitive nature 

# 2 variables that are called worry, not handy
total_results_waves$dep_var[total_results_waves$dep_var == &quot;worry&quot; &amp; total_results_waves$data == &quot;ISSP&quot;] &lt;- &quot;worry_issp&quot;

# Category
total_results_waves$attitude_cat[total_results_waves$dep_var == &quot;dodiff&quot; 
                               | total_results_waves$dep_var == &quot;pers_resp&quot;
                               | total_results_waves$dep_var == &quot;worry&quot;
                               | total_results_waves$dep_var == &quot;worried&quot;
                               | total_results_waves$dep_var == &quot;worry_future&quot;
                               | total_results_waves$dep_var == &quot;frontrunner&quot;
                               | total_results_waves$dep_var == &quot;min_contr&quot;
                               | total_results_waves$dep_var == &quot;worried_mot&quot;
                               | total_results_waves$dep_var == &quot;futuregen&quot;
                               | total_results_waves$dep_var == &quot;nowor&quot;
                               | total_results_waves$dep_var == &quot;motiv&quot;
                               | total_results_waves$dep_var == &quot;fut_gen_socon&quot;
                               | total_results_waves$dep_var == &quot;pers_resp_mot&quot;] &lt;- &quot;affective&quot;

total_results_waves$attitude_cat[total_results_waves$dep_var == &quot;willing_price&quot; 
                               | total_results_waves$dep_var == &quot;willing_tax&quot;
                               | total_results_waves$dep_var == &quot;willing_living&quot;
                               | total_results_waves$dep_var == &quot;do_right&quot;
                               | total_results_waves$dep_var == &quot;people_decide&quot;
                               | total_results_waves$dep_var == &quot;climate5&quot;
                               | total_results_waves$dep_var == &quot;prsaction&quot;
                               | total_results_waves$dep_var == &quot;cc_prsact&quot;
                               | total_results_waves$dep_var == &quot;buyprod&quot;
                                | total_results_waves$dep_var == &quot;sust_choice&quot;
                                | total_results_waves$dep_var == &quot;energy&quot;
                                | total_results_waves$dep_var == &quot;lifestyle&quot;] &lt;- &quot;behavioral&quot;

total_results_waves$attitude_cat[total_results_waves$dep_var == &quot;worry_issp&quot; 
                               | total_results_waves$dep_var == &quot;lifeharm&quot;
                               | total_results_waves$dep_var == &quot;progharm&quot;
                               | total_results_waves$dep_var == &quot;econprotect&quot;
                               | total_results_waves$dep_var == &quot;growharm&quot;
                               | total_results_waves$dep_var == &quot;bus_decide&quot;
                               | total_results_waves$dep_var == &quot;moreimp&quot;
                               | total_results_waves$dep_var == &quot;othersame&quot;
                               | total_results_waves$dep_var == &quot;exag&quot;
                               | total_results_waves$dep_var == &quot;country_effort&quot; 
                               | total_results_waves$dep_var == &quot;cause&quot;
                               | total_results_waves$dep_var == &quot;resp_citiz&quot;
                               | total_results_waves$dep_var == &quot;dk_start&quot;
                               | total_results_waves$dep_var == &quot;do_gov&quot;
                               | total_results_waves$dep_var == &quot;buss_help&quot;
                               | total_results_waves$dep_var == &quot;human_resp&quot;
                               | total_results_waves$dep_var == &quot;env_ec_stat&quot;
                               | total_results_waves$dep_var == &quot;env_prsimp&quot;
                                | total_results_waves$dep_var == &quot;envp_eg&quot;
                               | total_results_waves$dep_var == &quot;effr_eg&quot;
                               | total_results_waves$dep_var == &quot;cchange&quot;
                               | total_results_waves$dep_var == &quot;cchange2&quot;
                               | total_results_waves$dep_var == &quot;cchangetot&quot; 
                               | total_results_waves$dep_var == &quot;ccpercept&quot;
                               | total_results_waves$dep_var == &quot;env_quallife&quot;
                               | total_results_waves$dep_var == &quot;doprot_comp&quot;
                               | total_results_waves$dep_var == &quot;doprot_region&quot;
                               | total_results_waves$dep_var == &quot;doprot_natgov&quot;
                               | total_results_waves$dep_var == &quot;doprot_city&quot;
                               | total_results_waves$dep_var == &quot;doprot_citiz&quot;
                               | total_results_waves$dep_var == &quot;doprot_eu&quot;
                              | total_results_waves$dep_var == &quot;cc_unstop&quot;
                               | total_results_waves$dep_var == &quot;cc_exag&quot;
                               | total_results_waves$dep_var == &quot;cc_poseu&quot;
                               | total_results_waves$dep_var == &quot;role_ind&quot;
                               | total_results_waves$dep_var == &quot;big_pol&quot;
                               | total_results_waves$dep_var == &quot;eff_daily&quot;
                               | total_results_waves$dep_var == &quot;pers_imp&quot;
                              | total_results_waves$dep_var == &quot;cchange_mot&quot;
                              | total_results_waves$dep_var == &quot;ontime&quot;
                              | total_results_waves$dep_var == &quot;gov&quot;
                              | total_results_waves$dep_var == &quot;resp_gov&quot;
                              | total_results_waves$dep_var == &quot;resp_comp&quot;
                              | total_results_waves$dep_var == &quot;resp_mkb&quot;
                              | total_results_waves$dep_var == &quot;resp_citiz_mot&quot;
                              | total_results_waves$dep_var == &quot;resp_you&quot;
                              | total_results_waves$dep_var == &quot;contr&quot;
                              | total_results_waves$dep_var == &quot;noidea&quot;] &lt;- &quot;cognitive&quot;

#Create a variable that indicates whether the dependent variable can be interpreted in 2 ways (ambiguous)

total_results_waves$ambiguous[total_results_waves$dep_var != &quot;dodiff&quot; 
                               | total_results_waves$dep_var != &quot;frontrunner&quot;
                               | total_results_waves$dep_var != &quot;min_contr&quot;
                               | total_results_waves$dep_var != &quot;people_decide&quot;
                               | total_results_waves$dep_var != &quot;econprotect&quot;
                               | total_results_waves$dep_var != &quot;growharm&quot;
                               | total_results_waves$dep_var != &quot;bus_decide&quot;
                            | total_results_waves$dep_var != &quot;othersame&quot;
                            | total_results_waves$dep_var != &quot;resp_citiz&quot;
                            | total_results_waves$dep_var != &quot;dk_start&quot;
                            | total_results_waves$dep_var != &quot;buss_help&quot;
                            | total_results_waves$dep_var != &quot;envp_eg&quot;
                            | total_results_waves$dep_var != &quot;effr_eg&quot;
                            | total_results_waves$dep_var != &quot;env_quallife&quot;
                            | total_results_waves$dep_var != &quot;cc_unstop&quot;
                            | total_results_waves$dep_var != &quot;cc_poseu&quot;
                            | total_results_waves$dep_var != &quot;big_pol&quot;
                            | total_results_waves$dep_var == &quot;noidea&quot;] &lt;- &quot;No&quot;
total_results_waves$ambiguous[total_results_waves$dep_var == &quot;dodiff&quot; 
                               | total_results_waves$dep_var == &quot;frontrunner&quot;
                               | total_results_waves$dep_var == &quot;min_contr&quot;
                               | total_results_waves$dep_var == &quot;people_decide&quot;
                               | total_results_waves$dep_var == &quot;econprotect&quot;
                               | total_results_waves$dep_var == &quot;growharm&quot;
                               | total_results_waves$dep_var == &quot;bus_decide&quot;
                            | total_results_waves$dep_var == &quot;othersame&quot;
                            | total_results_waves$dep_var == &quot;resp_citiz&quot;
                            | total_results_waves$dep_var == &quot;dk_start&quot;
                            | total_results_waves$dep_var == &quot;buss_help&quot;
                            | total_results_waves$dep_var == &quot;envp_eg&quot;
                            | total_results_waves$dep_var == &quot;effr_eg&quot;
                            | total_results_waves$dep_var == &quot;env_quallife&quot;
                            | total_results_waves$dep_var == &quot;cc_unstop&quot;
                            | total_results_waves$dep_var == &quot;cc_poseu&quot;
                            | total_results_waves$dep_var == &quot;big_pol&quot;
                            | total_results_waves$dep_var == &quot;noidea&quot;] &lt;- &quot;Yes&quot;

# I also want an indicator for whether it is a national or international dataset. 
total_results_waves$national[total_results_waves$data == &quot;IO&quot;|
                             total_results_waves$data == &quot;MOT&quot; |
                             total_results_waves$data == &quot;LISS&quot; |
                             total_results_waves$data == &quot;SOCON&quot;] &lt;- 1
total_results_waves$national[total_results_waves$data == &quot;EB&quot;|
                             total_results_waves$data == &quot;ESS&quot; |
                             total_results_waves$data == &quot;EVS&quot; |
                             total_results_waves$data == &quot;ISSP&quot;] &lt;- 0

# I also calculated the percentage of missings per variable, in how many waves it was asked and how many categories the original scale had. I collected these data in Excel.
metavar &lt;- readxl::read_excel(&quot;./data/meta_var.xlsx&quot;)
total_results_waves &lt;- merge(total_results_waves, metavar)

save(total_results_waves, file= &quot;./data/meta_analysis/total_results_waves_new.RData&quot; )</code></pre>
</div>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIkV4dHJhY3QgY29lZmZpY2llbnRzIG9mIGdhbWxzcyByZWdyZXNzaW9ucyBzaG9ydGVyIHRpbWUgc3BhbnMiDQphdXRob3I6ICJBbnVzY2hrYSBQZWVsZW4iDQpkYXRlOiAiYHIgU3lzLkRhdGUoKWAiDQpvdXRwdXQ6IGh0bWxfZG9jdW1lbnQNCi0tLQ0KDQpgYGB7ciwgZWNobz1GQUxTRX0NCmtuaXRyOjpvcHRzX2NodW5rJHNldChldmFsID0gRkFMU0UpDQprbml0cjo6b3B0c19jaHVuayRzZXQobnVtYmVyX3NlY3Rpb25zID0gRkFMU0UpDQpvcHRpb25zKHdpZHRoID0gMTAwKQ0KY29sb3JpemUgPC0gZnVuY3Rpb24oeCwgY29sb3IpIHtzcHJpbnRmKCI8c3BhbiBzdHlsZT0nY29sb3I6ICVzOyc+JXM8L3NwYW4+IiwgY29sb3IsIHgpIH0NCmBgYA0KDQpgYGB7Y3NzLCBlY2hvPUZBTFNFfQ0KcHJlIHsNCiAgbWF4LWhlaWdodDogMzAwcHg7DQogIG92ZXJmbG93LXk6IGF1dG87DQp9DQoNCnByZVtjbGFzc10gew0KICBtYXgtaGVpZ2h0OiAxMDBweDsNCn0NCmBgYA0KDQpJbiB0aGlzIHNjcmlwdCBJIGV4dHJhY3QgdGhlIGNvZWZmaWNpZW50cyBmb3IgdGhlIHRpbWUgZWZmZWN0cyBhbmQgaW50ZXJjZXB0cyBhbmQgcHV0IHRoZW0gaW4gYSBkYXRhc2V0IHRvZ2V0aGVyLCB0byB1c2UgdGhlbSBhcyBpbnB1dCBmb3IgdGhlIG1ldGEtcmVncmVzc2lvbi4gVGhpcyBzY3JpcHQgdXNlcyB0aGUgZ2FtbHNzIHJlZ3Jlc3Npb25zIHdpdGggdGhlIHRpbWUgZWZmZWN0cyBvdmVyIHNob3J0ZXIgdGltZSBzcGFucy4gDQoNCmBgYHtyfQ0Kcm0obGlzdD1scygpKQ0KbGlicmFyeSh0aWR5dmVyc2UpDQpsaWJyYXJ5KGRwbHlyKQ0KbGlicmFyeShnYW1sc3MpDQpgYGANCg0KIyMgRVZTIHstfQ0KDQpgYGB7cn0NCiMgTm93IHRoZSBzYW1lIGZvciB0aGUgRVZTDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZXZzX2xpc3RfZW1wdHkxLlJEYXRhIikNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmV2c19lbXB0eV9kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBMb29wIG92ZXIgdGhlIGxpc3QgZm9yIGFsbCB0aGUgZGVwIHZhcnMNCmZvciAoaSBpbiBzZXFfYWxvbmcoZXZzX2xpc3RfZW1wdHkpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBuYW1lIG9mIHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3RlcihldnNfbGlzdF9lbXB0eVtbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShldnNfbGlzdF9lbXB0eVtbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvDQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzNdXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzMsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzRdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzQsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBldnNfZW1wdHlfZGYgPC0gcmJpbmQoZXZzX2VtcHR5X2RmLCBkYXRhLmZyYW1lKGRlcF92YXIgPSBkZXBfdmFyLCBtdV9pbnRlcmNlcHQgPSBtdV9pbnQsIG11X3NkID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdCA9IHNpZ21hX2ludCwgc2lnbWFfc2QgPSBzaWdtYV9zZCwgbXVfdGltZSA9IG11X3RpbWUsIG11X3RpbWVfc2QgPSBtdV90aW1lX3NkLCBzaWdfdGltZSA9IHNpZ190aW1lLCBzaWdfdGltZV9zZCA9IHNpZ190aW1lX3NkKSkNCn0NCg0KIyBBbmQgdGhlIHByZWRpY3RvciBtb2RlbA0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2V2c19saXN0X3ByZWRzMV9uZXcuUkRhdGEiKQ0KDQojIFN0b3JlIHRoZSByZXN1bHRzIGluIGEgbmV3IGRhdGFmcmFtZQ0KZXZzX3ByZWRzX2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIExvb3Agb3ZlciB0aGUgbGlzdCBvZiBtb2RlbHMNCmZvciAoaSBpbiBzZXFfYWxvbmcoZXZzX2xpc3RfcHJlZHMpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3RlcihldnNfbGlzdF9wcmVkc1tbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShldnNfbGlzdF9wcmVkc1tbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbnRlcmNlcHQgYW5kIHN0YW5kYXJkIGRldmlhdGlvbiBmb3IgbXUgYW5kIHNpZ21hDQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzddXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzcsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzhdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzgsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyANCiAgZXZzX3ByZWRzX2RmIDwtIHJiaW5kKGV2c19wcmVkc19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0X3ByZWQgPSBtdV9pbnQsIG11X3NkX3ByZWQgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0X3ByZWQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkX3ByZWQgPSBzaWdtYV9zZCwgbXVfdGltZV9wcmVkID0gbXVfdGltZSwgbXVfdGltZV9zZF9wcmVkID0gbXVfdGltZV9zZCwgc2lnX3RpbWVfcHJlZCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9wcmVkID0gc2lnX3RpbWVfc2QpKQ0KfQ0KDQojIEFuZCBsYXN0bHkgdGhlIGludGVyYWN0aW9uIG1vZGVsDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZXZzX2xpc3RfaW50ZXJhY3Rpb25zMV9uZXcuUkRhdGEiKQ0KDQojIFN0b3JlIHRoZSByZXN1bHRzIGluIGEgbmV3IGRhdGFmcmFtZQ0KZXZzX2ludGVyYWN0aW9uc19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBMb29wIG92ZXIgdGhlIG51bWJlciBvZiBkZXAgdmFycyBpbiB0aGUgbGlzdA0KZm9yIChpIGluIHNlcV9hbG9uZyhldnNfbGlzdF9pbnRlcmFjdGlvbnMpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3RlcihldnNfbGlzdF9pbnRlcmFjdGlvbnNbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkoZXZzX2xpc3RfaW50ZXJhY3Rpb25zW1tpXV0pDQogIA0KICAjIEV4dHJhY3QgdGhlIGluZm8gSSBuZWVkIGZyb20gdGhlIHN1bW1hcnkNCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbMTFdXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzExLDJdXQ0KICBtdV90aW1lIDwtIHN1bSBbWzJdXQ0KICBtdV90aW1lX3NkIDwtIHN1bVtbMiwyXV0NCiAgc2lnX3RpbWUgPC0gc3VtW1sxMl1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbMTIsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBldnNfaW50ZXJhY3Rpb25zX2RmIDwtIHJiaW5kKGV2c19pbnRlcmFjdGlvbnNfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdF9pbnQgPSBtdV9pbnQsIG11X3NkX2ludCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHRfaW50ID0gc2lnbWFfaW50LCBzaWdtYV9zZF9pbnQgPSBzaWdtYV9zZCwgbXVfdGltZV9pbnQgPSBtdV90aW1lLCBtdV90aW1lX3NkX2ludCA9IG11X3RpbWVfc2QsIHNpZ190aW1lX2ludCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9pbnQgPSBzaWdfdGltZV9zZCkpDQp9DQoNCiMgTWVyZ2UgdGhlIHJlc3VsdHMsIGFuZCBhZGQgc29tZSB2YXJpYWJsZXMgd2l0aCBleHRyYSBpbmZvcm1hdGlvbiANCmV2c19yZXN1bHRzX2RmIDwtIGxlZnRfam9pbihldnNfZW1wdHlfZGYsIGV2c19wcmVkc19kZikNCmV2c19yZXN1bHRzX2RmIDwtIGxlZnRfam9pbihldnNfcmVzdWx0c19kZiwgZXZzX2ludGVyYWN0aW9uc19kZikNCmV2c19yZXN1bHRzX2RmJGZpcnN0X3llYXIgPC0gMTk5MCANCmV2c19yZXN1bHRzX2RmJG1lYW5feWVhciA8LSAxOTk1DQpldnNfcmVzdWx0c19kZiR3YXZlc2V0IDwtIDENCmV2c19yZXN1bHRzX2RmJGRhdGEgPC0gIkVWUyINCg0Kc2F2ZShldnNfcmVzdWx0c19kZiwgZmlsZT0iLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2V2c19yZXN1bHRzX2RmMV9uZXcuUkRhdGEiKQ0KYGBgDQoNCg0KYGBge3J9DQojIEFuZCB0aGUgc2Vjb25kIHNldA0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2V2c19saXN0X2VtcHR5Mi5SRGF0YSIpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQpldnNfZW1wdHlfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCiMgTG9vcCBvdmVyIHRoZSBsaXN0IGZvciBhbGwgdGhlIGRlcCB2YXJzDQpmb3IgKGkgaW4gc2VxX2Fsb25nKGV2c19saXN0X2VtcHR5KSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIoZXZzX2xpc3RfZW1wdHlbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkoZXZzX2xpc3RfZW1wdHlbW2ldXSkNCiAgDQogICMgRXh0cmFjdCB0aGUgaW5mbw0KICBtdV9pbnQgPC0gc3VtW1sxXV0NCiAgbXVfc2QgPC0gc3VtW1sxLDJdXQ0KICBzaWdtYV9pbnQgPC0gc3VtW1szXV0NCiAgc2lnbWFfc2QgPC0gc3VtW1szLDJdXQ0KICBtdV90aW1lIDwtIHN1bSBbWzJdXQ0KICBtdV90aW1lX3NkIDwtIHN1bVtbMiwyXV0NCiAgc2lnX3RpbWUgPC0gc3VtW1s0XV0NCiAgc2lnX3RpbWVfc2QgPC0gc3VtW1s0LDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgZXZzX2VtcHR5X2RmIDwtIHJiaW5kKGV2c19lbXB0eV9kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0ID0gbXVfaW50LCBtdV9zZCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkID0gc2lnbWFfc2QsIG11X3RpbWUgPSBtdV90aW1lLCBtdV90aW1lX3NkID0gbXVfdGltZV9zZCwgc2lnX3RpbWUgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2QgPSBzaWdfdGltZV9zZCkpDQp9DQoNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9ldnNfbGlzdF9wcmVkczJfbmV3LlJEYXRhIikNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmV2c19wcmVkc19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBMb29wIG92ZXIgdGhlIGxpc3Qgb2YgbW9kZWxzDQpmb3IgKGkgaW4gc2VxX2Fsb25nKGV2c19saXN0X3ByZWRzKSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIoZXZzX2xpc3RfcHJlZHNbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkoZXZzX2xpc3RfcHJlZHNbW2ldXSkNCiAgDQogICMgRXh0cmFjdCB0aGUgaW50ZXJjZXB0IGFuZCBzdGFuZGFyZCBkZXZpYXRpb24gZm9yIG11IGFuZCBzaWdtYQ0KICBtdV9pbnQgPC0gc3VtW1sxXV0NCiAgbXVfc2QgPC0gc3VtW1sxLDJdXQ0KICBzaWdtYV9pbnQgPC0gc3VtW1s3XV0NCiAgc2lnbWFfc2QgPC0gc3VtW1s3LDJdXQ0KICBtdV90aW1lIDwtIHN1bSBbWzJdXQ0KICBtdV90aW1lX3NkIDwtIHN1bVtbMiwyXV0NCiAgc2lnX3RpbWUgPC0gc3VtW1s4XV0NCiAgc2lnX3RpbWVfc2QgPC0gc3VtW1s4LDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgDQogIGV2c19wcmVkc19kZiA8LSByYmluZChldnNfcHJlZHNfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdF9wcmVkID0gbXVfaW50LCBtdV9zZF9wcmVkID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdF9wcmVkID0gc2lnbWFfaW50LCBzaWdtYV9zZF9wcmVkID0gc2lnbWFfc2QsIG11X3RpbWVfcHJlZCA9IG11X3RpbWUsIG11X3RpbWVfc2RfcHJlZCA9IG11X3RpbWVfc2QsIHNpZ190aW1lX3ByZWQgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2RfcHJlZCA9IHNpZ190aW1lX3NkKSkNCn0NCg0KIyBBbmQgbGFzdGx5IHRoZSBpbnRlcmFjdGlvbiBtb2RlbA0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2V2c19saXN0X2ludGVyYWN0aW9uczJfbmV3LlJEYXRhIikNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmV2c19pbnRlcmFjdGlvbnNfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCiMgTG9vcCBvdmVyIHRoZSBudW1iZXIgb2YgZGVwIHZhcnMgaW4gdGhlIGxpc3QNCmZvciAoaSBpbiBzZXFfYWxvbmcoZXZzX2xpc3RfaW50ZXJhY3Rpb25zKSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIoZXZzX2xpc3RfaW50ZXJhY3Rpb25zW1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KGV2c19saXN0X2ludGVyYWN0aW9uc1tbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvIEkgbmVlZCBmcm9tIHRoZSBzdW1tYXJ5DQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzExXV0NCiAgc2lnbWFfc2QgPC0gc3VtW1sxMSwyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbMTJdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzEyLDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgZXZzX2ludGVyYWN0aW9uc19kZiA8LSByYmluZChldnNfaW50ZXJhY3Rpb25zX2RmLCBkYXRhLmZyYW1lKGRlcF92YXIgPSBkZXBfdmFyLCBtdV9pbnRlcmNlcHRfaW50ID0gbXVfaW50LCBtdV9zZF9pbnQgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0X2ludCA9IHNpZ21hX2ludCwgc2lnbWFfc2RfaW50ID0gc2lnbWFfc2QsIG11X3RpbWVfaW50ID0gbXVfdGltZSwgbXVfdGltZV9zZF9pbnQgPSBtdV90aW1lX3NkLCBzaWdfdGltZV9pbnQgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2RfaW50ID0gc2lnX3RpbWVfc2QpKQ0KfQ0KDQojIE1lcmdlIHRoZSByZXN1bHRzDQpldnNfcmVzdWx0c19kZiA8LSBsZWZ0X2pvaW4oZXZzX2VtcHR5X2RmLCBldnNfcHJlZHNfZGYpDQpldnNfcmVzdWx0c19kZiA8LSBsZWZ0X2pvaW4oZXZzX3Jlc3VsdHNfZGYsIGV2c19pbnRlcmFjdGlvbnNfZGYpDQpldnNfcmVzdWx0c19kZiRmaXJzdF95ZWFyIDwtIDE5OTkNCmV2c19yZXN1bHRzX2RmJG1lYW5feWVhciA8LSAyMDA0DQpldnNfcmVzdWx0c19kZiR3YXZlc2V0IDwtIDINCmV2c19yZXN1bHRzX2RmJGRhdGEgPC0gIkVWUyINCg0Kc2F2ZShldnNfcmVzdWx0c19kZiwgZmlsZT0iLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2V2c19yZXN1bHRzX2RmMl9uZXcuUkRhdGEiKQ0KYGBgDQoNCiMjIEkmTyBSZXNlYXJjaCB7LX0NCg0KYGBge3J9DQpybShsaXN0PWxzKCkpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvaW9fbGlzdF9lbXB0eTEuUkRhdGEiKQ0KDQojIFN0b3JlIHRoZSByZXN1bHRzIGluIGEgbmV3IGRhdGFmcmFtZQ0KaW9fZW1wdHlfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCmZvciAoaSBpbiBzZXFfYWxvbmcoaW9fbGlzdF9lbXB0eSkpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKGlvX2xpc3RfZW1wdHlbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkoaW9fbGlzdF9lbXB0eVtbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvDQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzNdXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzMsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzRdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzQsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBpb19lbXB0eV9kZiA8LSByYmluZChpb19lbXB0eV9kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0ID0gbXVfaW50LCBtdV9zZCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkID0gc2lnbWFfc2QsIG11X3RpbWUgPSBtdV90aW1lLCBtdV90aW1lX3NkID0gbXVfdGltZV9zZCwgc2lnX3RpbWUgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2QgPSBzaWdfdGltZV9zZCkpDQp9DQoNCiMgUHJlZGljdG9yIG1vZGVsDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvaW9fbGlzdF9wcmVkczFfbmV3LlJEYXRhIikNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmlvX3ByZWRzX2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIExvb3Agb3ZlciB0aGUgbGlzdCANCmZvciAoaSBpbiBzZXFfYWxvbmcoaW9fbGlzdF9wcmVkcykpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKGlvX2xpc3RfcHJlZHNbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkoaW9fbGlzdF9wcmVkc1tbaV1dKQ0KICANCiAgIyBFeHRyYWN0IGluZm8NCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbN11dDQogIHNpZ21hX3NkIDwtIHN1bVtbNywyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbOF1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbOCwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIGluIGEgZGF0YWZyYW1lDQogIGlvX3ByZWRzX2RmIDwtIHJiaW5kKGlvX3ByZWRzX2RmLCBkYXRhLmZyYW1lKGRlcF92YXIgPSBkZXBfdmFyLCBtdV9pbnRlcmNlcHRfcHJlZCA9IG11X2ludCwgbXVfc2RfcHJlZCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHRfcHJlZCA9IHNpZ21hX2ludCwgc2lnbWFfc2RfcHJlZCA9IHNpZ21hX3NkLCBtdV90aW1lX3ByZWQgPSBtdV90aW1lLCBtdV90aW1lX3NkX3ByZWQgPSBtdV90aW1lX3NkLCBzaWdfdGltZV9wcmVkID0gc2lnX3RpbWUsIHNpZ190aW1lX3NkX3ByZWQgPSBzaWdfdGltZV9zZCkpDQp9DQoNCiMgSW50ZXJhY3Rpb24gbW9kZWwNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9pb19saXN0X2ludGVyYWN0aW9uczFfbmV3LlJEYXRhIikNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmlvX2ludGVyYWN0aW9uc19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBMb29wIG92ZXIgdGhlIG51bWJlciBvZiBkZXAgdmFycyBpbiB0aGUgbGlzdA0KZm9yIChpIGluIHNlcV9hbG9uZyhpb19saXN0X2ludGVyYWN0aW9ucykpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKGlvX2xpc3RfaW50ZXJhY3Rpb25zW1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KGlvX2xpc3RfaW50ZXJhY3Rpb25zW1tpXV0pDQogIA0KICAjIEV4dHJhY3QgdGhlIGluZm8gSSBuZWVkIGZyb20gdGhlIHN1bW1hcnkNCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbMTFdXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzExLDJdXQ0KICBtdV90aW1lIDwtIHN1bSBbWzJdXQ0KICBtdV90aW1lX3NkIDwtIHN1bVtbMiwyXV0NCiAgc2lnX3RpbWUgPC0gc3VtW1sxMl1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbMTIsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBpb19pbnRlcmFjdGlvbnNfZGYgPC0gcmJpbmQoaW9faW50ZXJhY3Rpb25zX2RmLCBkYXRhLmZyYW1lKGRlcF92YXIgPSBkZXBfdmFyLCBtdV9pbnRlcmNlcHRfaW50ID0gbXVfaW50LCBtdV9zZF9pbnQgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0X2ludCA9IHNpZ21hX2ludCwgc2lnbWFfc2RfaW50ID0gc2lnbWFfc2QsIG11X3RpbWVfaW50ID0gbXVfdGltZSwgbXVfdGltZV9zZF9pbnQgPSBtdV90aW1lX3NkLCBzaWdfdGltZV9pbnQgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2RfaW50ID0gc2lnX3RpbWVfc2QpKQ0KfQ0KDQojIE1lcmdlIHRoZSByZXN1bHRzDQppb19yZXN1bHRzX2RmIDwtIGxlZnRfam9pbihpb19lbXB0eV9kZiwgaW9fcHJlZHNfZGYpDQppb19yZXN1bHRzX2RmIDwtIGxlZnRfam9pbihpb19yZXN1bHRzX2RmLCBpb19pbnRlcmFjdGlvbnNfZGYpDQppb19yZXN1bHRzX2RmJGZpcnN0X3llYXIgPC0gMjAxOQ0KaW9fcmVzdWx0c19kZiRtZWFuX3llYXIgPC0gMjAyMA0KaW9fcmVzdWx0c19kZiR3YXZlc2V0IDwtIDENCmlvX3Jlc3VsdHNfZGYkZGF0YSA8LSAiSU8iDQoNCnNhdmUoaW9fcmVzdWx0c19kZiwgZmlsZT0iLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2lvX3Jlc3VsdHNfZGYxX25ldy5SRGF0YSIpDQpgYGANCg0KDQpgYGB7cn0NCiMgU2Vjb25kIHNldA0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2lvX2xpc3RfZW1wdHkyLlJEYXRhIikNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmlvX2VtcHR5X2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQpmb3IgKGkgaW4gc2VxX2Fsb25nKGlvX2xpc3RfZW1wdHkpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3Rlcihpb19saXN0X2VtcHR5W1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KGlvX2xpc3RfZW1wdHlbW2ldXSkNCiAgDQogICMgRXh0cmFjdCB0aGUgaW5mbw0KICBtdV9pbnQgPC0gc3VtW1sxXV0NCiAgbXVfc2QgPC0gc3VtW1sxLDJdXQ0KICBzaWdtYV9pbnQgPC0gc3VtW1szXV0NCiAgc2lnbWFfc2QgPC0gc3VtW1szLDJdXQ0KICBtdV90aW1lIDwtIHN1bSBbWzJdXQ0KICBtdV90aW1lX3NkIDwtIHN1bVtbMiwyXV0NCiAgc2lnX3RpbWUgPC0gc3VtW1s0XV0NCiAgc2lnX3RpbWVfc2QgPC0gc3VtW1s0LDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgaW9fZW1wdHlfZGYgPC0gcmJpbmQoaW9fZW1wdHlfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdCA9IG11X2ludCwgbXVfc2QgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0ID0gc2lnbWFfaW50LCBzaWdtYV9zZCA9IHNpZ21hX3NkLCBtdV90aW1lID0gbXVfdGltZSwgbXVfdGltZV9zZCA9IG11X3RpbWVfc2QsIHNpZ190aW1lID0gc2lnX3RpbWUsIHNpZ190aW1lX3NkID0gc2lnX3RpbWVfc2QpKQ0KfQ0KDQojIFByZWRpY3RvciBtb2RlbA0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2lvX2xpc3RfcHJlZHMyX25ldy5SRGF0YSIpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQppb19wcmVkc19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBMb29wIG92ZXIgdGhlIGxpc3QgDQpmb3IgKGkgaW4gc2VxX2Fsb25nKGlvX2xpc3RfcHJlZHMpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3Rlcihpb19saXN0X3ByZWRzW1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KGlvX2xpc3RfcHJlZHNbW2ldXSkNCiAgDQogICMgRXh0cmFjdCBpbmZvDQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzddXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzcsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzhdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzgsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBpb19wcmVkc19kZiA8LSByYmluZChpb19wcmVkc19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0X3ByZWQgPSBtdV9pbnQsIG11X3NkX3ByZWQgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0X3ByZWQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkX3ByZWQgPSBzaWdtYV9zZCwgbXVfdGltZV9wcmVkID0gbXVfdGltZSwgbXVfdGltZV9zZF9wcmVkID0gbXVfdGltZV9zZCwgc2lnX3RpbWVfcHJlZCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9wcmVkID0gc2lnX3RpbWVfc2QpKQ0KfQ0KDQojIEludGVyYWN0aW9uIG1vZGVsDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvaW9fbGlzdF9pbnRlcmFjdGlvbnMyX25ldy5SRGF0YSIpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQppb19pbnRlcmFjdGlvbnNfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCiMgTG9vcCBvdmVyIHRoZSBudW1iZXIgb2YgZGVwIHZhcnMgaW4gdGhlIGxpc3QNCmZvciAoaSBpbiBzZXFfYWxvbmcoaW9fbGlzdF9pbnRlcmFjdGlvbnMpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3Rlcihpb19saXN0X2ludGVyYWN0aW9uc1tbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShpb19saXN0X2ludGVyYWN0aW9uc1tbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvIEkgbmVlZCBmcm9tIHRoZSBzdW1tYXJ5DQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzExXV0NCiAgc2lnbWFfc2QgPC0gc3VtW1sxMSwyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbMTJdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzEyLDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgaW9faW50ZXJhY3Rpb25zX2RmIDwtIHJiaW5kKGlvX2ludGVyYWN0aW9uc19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0X2ludCA9IG11X2ludCwgbXVfc2RfaW50ID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdF9pbnQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkX2ludCA9IHNpZ21hX3NkLCBtdV90aW1lX2ludCA9IG11X3RpbWUsIG11X3RpbWVfc2RfaW50ID0gbXVfdGltZV9zZCwgc2lnX3RpbWVfaW50ID0gc2lnX3RpbWUsIHNpZ190aW1lX3NkX2ludCA9IHNpZ190aW1lX3NkKSkNCn0NCg0KIyBNZXJnZSB0aGUgcmVzdWx0cw0KaW9fcmVzdWx0c19kZiA8LSBsZWZ0X2pvaW4oaW9fZW1wdHlfZGYsIGlvX3ByZWRzX2RmKQ0KaW9fcmVzdWx0c19kZiA8LSBsZWZ0X2pvaW4oaW9fcmVzdWx0c19kZiwgaW9faW50ZXJhY3Rpb25zX2RmKQ0KaW9fcmVzdWx0c19kZiRmaXJzdF95ZWFyIDwtIDIwMjANCmlvX3Jlc3VsdHNfZGYkbWVhbl95ZWFyIDwtIDIwMjENCmlvX3Jlc3VsdHNfZGYkd2F2ZXNldCA8LSAyDQppb19yZXN1bHRzX2RmJGRhdGEgPC0gIklPIg0KDQpzYXZlKGlvX3Jlc3VsdHNfZGYsIGZpbGU9Ii4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9pb19yZXN1bHRzX2RmMl9uZXcuUkRhdGEiKQ0KYGBgDQoNCiMjIElTU1Agey19DQoNCmBgYHtyfQ0KIyBOb3cgZm9yIElTU1AsIGFuZCB0aGVuIG9ubHkgZm9yIHRoZSBmaXJzdCBwYXJ0IGJjIHRoZSBzZWNvbmQgcGFydCBhbHJlYWR5IGNvbnNpc3RzIG9mIDIgd2F2ZXMNCnJtKGxpc3Q9bHMoKSkNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9pc3NwX2xpc3RfZW1wdHkxLlJEYXRhIikNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmlzc3BfZW1wdHlfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCiMgTG9vcCBvdmVyIHRoZSBsaXN0IGZvciBhbGwgdGhlIGRlcCB2YXJzDQpmb3IgKGkgaW4gc2VxX2Fsb25nKGlzc3BfbGlzdF9lbXB0eSkpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKGlzc3BfbGlzdF9lbXB0eVtbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShpc3NwX2xpc3RfZW1wdHlbW2ldXSkNCiAgDQogICMgRXh0cmFjdCB0aGUgaW5mbw0KICBtdV9pbnQgPC0gc3VtW1sxXV0NCiAgbXVfc2QgPC0gc3VtW1sxLDJdXQ0KICBzaWdtYV9pbnQgPC0gc3VtW1szXV0NCiAgc2lnbWFfc2QgPC0gc3VtW1szLDJdXQ0KICBtdV90aW1lIDwtIHN1bSBbWzJdXQ0KICBtdV90aW1lX3NkIDwtIHN1bVtbMiwyXV0NCiAgc2lnX3RpbWUgPC0gc3VtW1s0XV0NCiAgc2lnX3RpbWVfc2QgPC0gc3VtW1s0LDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgaXNzcF9lbXB0eV9kZiA8LSByYmluZChpc3NwX2VtcHR5X2RmLCBkYXRhLmZyYW1lKGRlcF92YXIgPSBkZXBfdmFyLCBtdV9pbnRlcmNlcHQgPSBtdV9pbnQsIG11X3NkID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdCA9IHNpZ21hX2ludCwgc2lnbWFfc2QgPSBzaWdtYV9zZCwgbXVfdGltZSA9IG11X3RpbWUsIG11X3RpbWVfc2QgPSBtdV90aW1lX3NkLCBzaWdfdGltZSA9IHNpZ190aW1lLCBzaWdfdGltZV9zZCA9IHNpZ190aW1lX3NkKSkNCn0NCg0KIyBQcmVkaWN0b3IgbW9kZWwgDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvaXNzcF9saXN0X3ByZWRzMV9uZXcuUkRhdGEiKQ0KDQojIFN0b3JlIHRoZSByZXN1bHRzIGluIGEgbmV3IGRhdGFmcmFtZQ0KaXNzcF9wcmVkc19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBMb29wIG92ZXIgdGhlIGxpc3QgDQpmb3IgKGkgaW4gc2VxX2Fsb25nKGlzc3BfbGlzdF9wcmVkcykpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKGlzc3BfbGlzdF9wcmVkc1tbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShpc3NwX2xpc3RfcHJlZHNbW2ldXSkNCiAgDQogICMgRXh0cmFjdCBpbmZvDQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzddXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzcsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzhdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzgsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBpc3NwX3ByZWRzX2RmIDwtIHJiaW5kKGlzc3BfcHJlZHNfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdF9wcmVkID0gbXVfaW50LCBtdV9zZF9wcmVkID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdF9wcmVkID0gc2lnbWFfaW50LCBzaWdtYV9zZF9wcmVkID0gc2lnbWFfc2QsIG11X3RpbWVfcHJlZCA9IG11X3RpbWUsIG11X3RpbWVfc2RfcHJlZCA9IG11X3RpbWVfc2QsIHNpZ190aW1lX3ByZWQgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2RfcHJlZCA9IHNpZ190aW1lX3NkKSkNCn0NCg0KIyBJbnRlcmFjdGlvbiBtb2RlbA0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2lzc3BfbGlzdF9pbnRlcmFjdGlvbnMxX25ldy5SRGF0YSIpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQppc3NwX2ludGVyYWN0aW9uc19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBMb29wIG92ZXIgdGhlIG51bWJlciBvZiBkZXAgdmFycyBpbiB0aGUgbGlzdA0KZm9yIChpIGluIHNlcV9hbG9uZyhpc3NwX2xpc3RfaW50ZXJhY3Rpb25zKSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIoaXNzcF9saXN0X2ludGVyYWN0aW9uc1tbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShpc3NwX2xpc3RfaW50ZXJhY3Rpb25zW1tpXV0pDQogIA0KICAjIEV4dHJhY3QgdGhlIGluZm8gSSBuZWVkIGZyb20gdGhlIHN1bW1hcnkNCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbMTFdXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzExLDJdXQ0KICBtdV90aW1lIDwtIHN1bSBbWzJdXQ0KICBtdV90aW1lX3NkIDwtIHN1bVtbMiwyXV0NCiAgc2lnX3RpbWUgPC0gc3VtW1sxMl1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbMTIsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBpc3NwX2ludGVyYWN0aW9uc19kZiA8LSByYmluZChpc3NwX2ludGVyYWN0aW9uc19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0X2ludCA9IG11X2ludCwgbXVfc2RfaW50ID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdF9pbnQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkX2ludCA9IHNpZ21hX3NkLCBtdV90aW1lX2ludCA9IG11X3RpbWUsIG11X3RpbWVfc2RfaW50ID0gbXVfdGltZV9zZCwgc2lnX3RpbWVfaW50ID0gc2lnX3RpbWUsIHNpZ190aW1lX3NkX2ludCA9IHNpZ190aW1lX3NkKSkNCn0NCg0KIyBNZXJnZSB0aGUgcmVzdWx0cw0KaXNzcF9yZXN1bHRzX2RmIDwtIGxlZnRfam9pbihpc3NwX2VtcHR5X2RmLCBpc3NwX3ByZWRzX2RmKQ0KaXNzcF9yZXN1bHRzX2RmIDwtIGxlZnRfam9pbihpc3NwX3Jlc3VsdHNfZGYsIGlzc3BfaW50ZXJhY3Rpb25zX2RmKQ0KaXNzcF9yZXN1bHRzX2RmJGZpcnN0X3llYXIgPC0gMTk5Mw0KaXNzcF9yZXN1bHRzX2RmJG1lYW5feWVhciA8LSAxOTk3DQppc3NwX3Jlc3VsdHNfZGYkd2F2ZXNldCA8LSAxDQppc3NwX3Jlc3VsdHNfZGYkZGF0YSA8LSAiSVNTUCINCg0Kc2F2ZShpc3NwX3Jlc3VsdHNfZGYsIGZpbGU9Ii4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9pc3NwX3Jlc3VsdHNfZGYxX25ldy5SRGF0YSIpDQpgYGANCg0KDQpgYGB7cn0NCiMgQW5kIHRoZSBzZWNvbmQgc2V0DQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvaXNzcF9saXN0X2VtcHR5Mi5SRGF0YSIpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQppc3NwX2VtcHR5X2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIExvb3Agb3ZlciB0aGUgbGlzdCBmb3IgYWxsIHRoZSBkZXAgdmFycw0KZm9yIChpIGluIHNlcV9hbG9uZyhpc3NwX2xpc3RfZW1wdHkpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3Rlcihpc3NwX2xpc3RfZW1wdHlbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkoaXNzcF9saXN0X2VtcHR5W1tpXV0pDQogIA0KICAjIEV4dHJhY3QgdGhlIGluZm8NCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbM11dDQogIHNpZ21hX3NkIDwtIHN1bVtbMywyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbNF1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbNCwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIGluIGEgZGF0YWZyYW1lDQogIGlzc3BfZW1wdHlfZGYgPC0gcmJpbmQoaXNzcF9lbXB0eV9kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0ID0gbXVfaW50LCBtdV9zZCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkID0gc2lnbWFfc2QsIG11X3RpbWUgPSBtdV90aW1lLCBtdV90aW1lX3NkID0gbXVfdGltZV9zZCwgc2lnX3RpbWUgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2QgPSBzaWdfdGltZV9zZCkpDQp9DQoNCiNQcmVkaWN0b3IgbW9kZWwNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9pc3NwX2xpc3RfcHJlZHMyX25ldy5SRGF0YSIpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQppc3NwX3ByZWRzX2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIExvb3Agb3ZlciB0aGUgbGlzdCANCmZvciAoaSBpbiBzZXFfYWxvbmcoaXNzcF9saXN0X3ByZWRzKSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIoaXNzcF9saXN0X3ByZWRzW1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KGlzc3BfbGlzdF9wcmVkc1tbaV1dKQ0KICANCiAgIyBFeHRyYWN0IGluZm8NCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbN11dDQogIHNpZ21hX3NkIDwtIHN1bVtbNywyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbOF1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbOCwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIGluIGEgZGF0YWZyYW1lDQogIGlzc3BfcHJlZHNfZGYgPC0gcmJpbmQoaXNzcF9wcmVkc19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0X3ByZWQgPSBtdV9pbnQsIG11X3NkX3ByZWQgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0X3ByZWQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkX3ByZWQgPSBzaWdtYV9zZCwgbXVfdGltZV9wcmVkID0gbXVfdGltZSwgbXVfdGltZV9zZF9wcmVkID0gbXVfdGltZV9zZCwgc2lnX3RpbWVfcHJlZCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9wcmVkID0gc2lnX3RpbWVfc2QpKQ0KfQ0KDQojIEludGVyYWN0aW9uIG1vZGVsDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvaXNzcF9saXN0X2ludGVyYWN0aW9uczJfbmV3LlJEYXRhIikNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmlzc3BfaW50ZXJhY3Rpb25zX2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIExvb3Agb3ZlciB0aGUgbnVtYmVyIG9mIGRlcCB2YXJzIGluIHRoZSBsaXN0DQpmb3IgKGkgaW4gc2VxX2Fsb25nKGlzc3BfbGlzdF9pbnRlcmFjdGlvbnMpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3Rlcihpc3NwX2xpc3RfaW50ZXJhY3Rpb25zW1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KGlzc3BfbGlzdF9pbnRlcmFjdGlvbnNbW2ldXSkNCiAgDQogICMgRXh0cmFjdCB0aGUgaW5mbyBJIG5lZWQgZnJvbSB0aGUgc3VtbWFyeQ0KICBtdV9pbnQgPC0gc3VtW1sxXV0NCiAgbXVfc2QgPC0gc3VtW1sxLDJdXQ0KICBzaWdtYV9pbnQgPC0gc3VtW1sxMV1dDQogIHNpZ21hX3NkIDwtIHN1bVtbMTEsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzEyXV0NCiAgc2lnX3RpbWVfc2QgPC0gc3VtW1sxMiwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIGluIGEgZGF0YWZyYW1lDQogIGlzc3BfaW50ZXJhY3Rpb25zX2RmIDwtIHJiaW5kKGlzc3BfaW50ZXJhY3Rpb25zX2RmLCBkYXRhLmZyYW1lKGRlcF92YXIgPSBkZXBfdmFyLCBtdV9pbnRlcmNlcHRfaW50ID0gbXVfaW50LCBtdV9zZF9pbnQgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0X2ludCA9IHNpZ21hX2ludCwgc2lnbWFfc2RfaW50ID0gc2lnbWFfc2QsIG11X3RpbWVfaW50ID0gbXVfdGltZSwgbXVfdGltZV9zZF9pbnQgPSBtdV90aW1lX3NkLCBzaWdfdGltZV9pbnQgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2RfaW50ID0gc2lnX3RpbWVfc2QpKQ0KfQ0KDQojIE1lcmdlIHRoZSByZXN1bHRzDQppc3NwX3Jlc3VsdHNfZGYgPC0gbGVmdF9qb2luKGlzc3BfZW1wdHlfZGYsIGlzc3BfcHJlZHNfZGYpDQppc3NwX3Jlc3VsdHNfZGYgPC0gbGVmdF9qb2luKGlzc3BfcmVzdWx0c19kZiwgaXNzcF9pbnRlcmFjdGlvbnNfZGYpDQppc3NwX3Jlc3VsdHNfZGYkZmlyc3RfeWVhciA8LSAyMDAwDQppc3NwX3Jlc3VsdHNfZGYkbWVhbl95ZWFyIDwtIDIwMDUNCmlzc3BfcmVzdWx0c19kZiR3YXZlc2V0IDwtIDINCmlzc3BfcmVzdWx0c19kZiRkYXRhIDwtICJJU1NQIg0KDQpzYXZlKGlzc3BfcmVzdWx0c19kZiwgZmlsZT0iLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2lzc3BfcmVzdWx0c19kZjJfbmV3LlJEYXRhIikNCmBgYA0KDQojIyBFQiB7LX0NCg0KYGBge3J9DQojIEZvciBhbGwgdGhlIGV1cm9iYXJvbWV0ZXIgd2F2ZXMsIGV4YWN0bHkgdGhlIHNhbWUgbmVlZHMgdG8gYmUgZG9uZSBlYWNoIHRpbWUuIFRoZXJlZm9yZSBJIHdhbnQgdG8gbG9vcCBvdmVyIHRoZXNlIGRpZmZlcmVudCBsaXN0cy4gDQoNCiMgRmlyc3QgbG9hZCBhbGwgdGhlIGV1cm9iYXJvbWV0ZXIgbGlzdHMgd2l0aCBlbXB0eSBtb2RlbHMgaW4gbXkgZW52aXJvbm1lbnQNCnJtKGxpc3Q9bHMoKSkNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9lYl9saXN0X2VtcHR5XzE5ODZfMS5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9lbXB0eV8yMDA3XzEuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfZW1wdHlfMjAwOV8xLlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X2VtcHR5XzIwMTFfdy5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9lbXB0eV9idXlwcm9kMS5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9lbXB0eV9jY2hhbmdlMl8xLlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X2VtcHR5X2RvcHJvdDEuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfZW1wdHlfZWZmX2RhaWx5MS5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9lbXB0eV9wZXJzX2ltcDEuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfZW1wdHlfcHJzYWN0aW9uMS5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZWJfbGlzdF9lbXB0eV9xdWFsbGlmZTEuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfZW1wdHlfZG9wcm90X2NpdHlfdy5SRGF0YSIpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQplYl9yZXN1bHRzX2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIEdldCB0aGUgbGlzdHMgZnJvbSB0aGUgZW52aXJvbm1lbnQNCmxpc3RzIDwtIGxzKCkNCg0KZm9yIChqIGluIGxpc3RzKSB7IA0KICBpZihpcy5saXN0KGdldChqKSkpIHsgDQogICAgbXlfbGlzdCA8LSBnZXQoaikNCg0KIyBMb29wIG92ZXIgdGhlIGxpc3QgZm9yIGFsbCB0aGUgZGVwIHZhcnMNCmZvciAoaSBpbiBzZXFfYWxvbmcobXlfbGlzdCkpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKG15X2xpc3RbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkobXlfbGlzdFtbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvDQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzNdXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzMsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzRdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzQsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBlYl9yZXN1bHRzX2RmIDwtIHJiaW5kKGViX3Jlc3VsdHNfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdCA9IG11X2ludCwgbXVfc2QgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0ID0gc2lnbWFfaW50LCBzaWdtYV9zZCA9IHNpZ21hX3NkLCBtdV90aW1lID0gbXVfdGltZSwgbXVfdGltZV9zZCA9IG11X3RpbWVfc2QsIHNpZ190aW1lID0gc2lnX3RpbWUsIHNpZ190aW1lX3NkID0gc2lnX3RpbWVfc2QpKQ0KICAgIH0NCiAgfSANCn0gDQoNCiMgSXQgcHJvZHVjZXMgYW4gZXJyb3IsIGJ1dCBhY3R1YWxseSBldmVyeXRoaW5nIGhhcyB3b3JrZWQgYXMgaSB3aXNoDQplYl9yZXN1bHRzX2VtcHR5X2RmIDwtIGViX3Jlc3VsdHNfZGYNCmViX3Jlc3VsdHNfZW1wdHlfZGYkd2F2ZXNldCA8LSAxDQoNCiMgU2F2ZSBpdA0Kc2F2ZShlYl9yZXN1bHRzX2VtcHR5X2RmLCBmaWxlPSAiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2ViX3Jlc3VsdHNfZW1wdHlfZGYxX25ldy5SRGF0YSIgKQ0KYGBgDQoNCg0KYGBge3J9DQojIFNlY29uZCBzZXQNCiMgRmlyc3QgbG9hZCBhbGwgdGhlIGV1cm9iYXJvbWV0ZXIgbGlzdHMgd2l0aCBlbXB0eSBtb2RlbHMgaW4gbXkgZW52aXJvbm1lbnQNCnJtKGxpc3Q9bHMoKSkNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9lYl9saXN0X2VtcHR5XzE5ODZfMi5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9lbXB0eV8yMDA3XzIuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfZW1wdHlfMjAwOV8yLlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X2VtcHR5X2J1eXByb2QyLlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X2VtcHR5X2NjaGFuZ2UyXzIuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfZW1wdHlfZG9wcm90Mi5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9lbXB0eV9lZmZfZGFpbHkyLlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X2VtcHR5X3BlcnNfaW1wMi5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9lbXB0eV9wcnNhY3Rpb24yLlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9lYl9saXN0X2VtcHR5X3F1YWxsaWZlMi5SRGF0YSIpDQoNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmViX3Jlc3VsdHNfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCiMgR2V0IHRoZSBsaXN0cyBmcm9tIHRoZSBlbnZpcm9ubWVudA0KbGlzdHMgPC0gbHMoKQ0KDQpmb3IgKGogaW4gbGlzdHMpIHsgDQogIGlmKGlzLmxpc3QoZ2V0KGopKSkgeyANCiAgICBteV9saXN0IDwtIGdldChqKQ0KDQojIExvb3Agb3ZlciB0aGUgbGlzdCBmb3IgYWxsIHRoZSBkZXAgdmFycw0KZm9yIChpIGluIHNlcV9hbG9uZyhteV9saXN0KSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIobXlfbGlzdFtbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShteV9saXN0W1tpXV0pDQogIA0KICAjIEV4dHJhY3QgdGhlIGluZm8NCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbM11dDQogIHNpZ21hX3NkIDwtIHN1bVtbMywyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbNF1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbNCwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIGluIGEgZGF0YWZyYW1lDQogIGViX3Jlc3VsdHNfZGYgPC0gcmJpbmQoZWJfcmVzdWx0c19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0ID0gbXVfaW50LCBtdV9zZCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkID0gc2lnbWFfc2QsIG11X3RpbWUgPSBtdV90aW1lLCBtdV90aW1lX3NkID0gbXVfdGltZV9zZCwgc2lnX3RpbWUgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2QgPSBzaWdfdGltZV9zZCkpDQogICAgfQ0KICB9IA0KfSANCg0KIyBJdCBwcm9kdWNlcyBhbiBlcnJvciwgYnV0IGFjdHVhbGx5IGV2ZXJ5dGhpbmcgaGFzIHdvcmtlZCANCmViX3Jlc3VsdHNfZW1wdHlfZGYgPC0gZWJfcmVzdWx0c19kZg0KZWJfcmVzdWx0c19lbXB0eV9kZiR3YXZlc2V0IDwtIDINCg0Kc2F2ZShlYl9yZXN1bHRzX2VtcHR5X2RmLCBmaWxlPSAiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2ViX3Jlc3VsdHNfZW1wdHlfZGYyX25ldy5SRGF0YSIgKQ0KYGBgDQoNCg0KYGBge3J9DQojIFNvbWUgb2YgdGhlbSBoYXZlIGEgdGhpcmQgc2V0DQpybShsaXN0PWxzKCkpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9lbXB0eV8yMDA3XzMuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfZW1wdHlfMjAwOV8zLlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X2VtcHR5X2NjaGFuZ2UyXzMuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfZW1wdHlfZWZmX2RhaWx5My5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9lbXB0eV9wcnNhY3Rpb24zLlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9lYl9saXN0X2VtcHR5X3F1YWxsaWZlMy5SRGF0YSIpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQplYl9yZXN1bHRzX2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIEdldCB0aGUgbGlzdHMgZnJvbSB0aGUgZW52aXJvbm1lbnQNCmxpc3RzIDwtIGxzKCkNCg0KZm9yIChqIGluIGxpc3RzKSB7IA0KICBpZihpcy5saXN0KGdldChqKSkpIHsgDQogICAgbXlfbGlzdCA8LSBnZXQoaikNCg0KIyBMb29wIG92ZXIgdGhlIGxpc3QgZm9yIGFsbCB0aGUgZGVwIHZhcnMNCmZvciAoaSBpbiBzZXFfYWxvbmcobXlfbGlzdCkpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKG15X2xpc3RbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkobXlfbGlzdFtbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvDQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzNdXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzMsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzRdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzQsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBlYl9yZXN1bHRzX2RmIDwtIHJiaW5kKGViX3Jlc3VsdHNfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdCA9IG11X2ludCwgbXVfc2QgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0ID0gc2lnbWFfaW50LCBzaWdtYV9zZCA9IHNpZ21hX3NkLCBtdV90aW1lID0gbXVfdGltZSwgbXVfdGltZV9zZCA9IG11X3RpbWVfc2QsIHNpZ190aW1lID0gc2lnX3RpbWUsIHNpZ190aW1lX3NkID0gc2lnX3RpbWVfc2QpKQ0KICAgIH0NCiAgfSANCn0gDQoNCiMgSXQgcHJvZHVjZXMgYW4gZXJyb3IsIGJ1dCBhY3R1YWxseSBldmVyeXRoaW5nIGhhcyB3b3JrZWQgDQplYl9yZXN1bHRzX2VtcHR5X2RmIDwtIGViX3Jlc3VsdHNfZGYNCmViX3Jlc3VsdHNfZW1wdHlfZGYkd2F2ZXNldCA8LSAzDQoNCnNhdmUoZWJfcmVzdWx0c19lbXB0eV9kZiwgZmlsZT0gIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9lYl9yZXN1bHRzX2VtcHR5X2RmM19uZXcuUkRhdGEiICkNCmBgYA0KDQoNCmBgYHtyfQ0KIyBTb21lIGV2ZW4gYSBmb3VydGggdGltZQ0Kcm0obGlzdD1scygpKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfZW1wdHlfMjAwOV80LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X2VtcHR5X2NjaGFuZ2UyXzQuUkRhdGEiKQ0KDQojIFN0b3JlIHRoZSByZXN1bHRzIGluIGEgbmV3IGRhdGFmcmFtZQ0KZWJfcmVzdWx0c19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBHZXQgdGhlIGxpc3RzIGZyb20gdGhlIGVudmlyb25tZW50DQpsaXN0cyA8LSBscygpDQoNCmZvciAoaiBpbiBsaXN0cykgeyANCiAgaWYoaXMubGlzdChnZXQoaikpKSB7IA0KICAgIG15X2xpc3QgPC0gZ2V0KGopDQoNCiMgTG9vcCBvdmVyIHRoZSBsaXN0IGZvciBhbGwgdGhlIGRlcCB2YXJzDQpmb3IgKGkgaW4gc2VxX2Fsb25nKG15X2xpc3QpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3RlcihteV9saXN0W1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KG15X2xpc3RbW2ldXSkNCiAgDQogICMgRXh0cmFjdCB0aGUgaW5mbw0KICBtdV9pbnQgPC0gc3VtW1sxXV0NCiAgbXVfc2QgPC0gc3VtW1sxLDJdXQ0KICBzaWdtYV9pbnQgPC0gc3VtW1szXV0NCiAgc2lnbWFfc2QgPC0gc3VtW1szLDJdXQ0KICBtdV90aW1lIDwtIHN1bSBbWzJdXQ0KICBtdV90aW1lX3NkIDwtIHN1bVtbMiwyXV0NCiAgc2lnX3RpbWUgPC0gc3VtW1s0XV0NCiAgc2lnX3RpbWVfc2QgPC0gc3VtW1s0LDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgZWJfcmVzdWx0c19kZiA8LSByYmluZChlYl9yZXN1bHRzX2RmLCBkYXRhLmZyYW1lKGRlcF92YXIgPSBkZXBfdmFyLCBtdV9pbnRlcmNlcHQgPSBtdV9pbnQsIG11X3NkID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdCA9IHNpZ21hX2ludCwgc2lnbWFfc2QgPSBzaWdtYV9zZCwgbXVfdGltZSA9IG11X3RpbWUsIG11X3RpbWVfc2QgPSBtdV90aW1lX3NkLCBzaWdfdGltZSA9IHNpZ190aW1lLCBzaWdfdGltZV9zZCA9IHNpZ190aW1lX3NkKSkNCiAgICB9DQogIH0gDQp9IA0KDQojIEl0IHByb2R1Y2VzIGFuIGVycm9yLCBidXQgYWN0dWFsbHkgZXZlcnl0aGluZyBoYXMgd29ya2VkIA0KZWJfcmVzdWx0c19lbXB0eV9kZiA8LSBlYl9yZXN1bHRzX2RmDQplYl9yZXN1bHRzX2VtcHR5X2RmJHdhdmVzZXQgPC0gNA0KDQpzYXZlKGViX3Jlc3VsdHNfZW1wdHlfZGYsIGZpbGU9ICIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZWJfcmVzdWx0c19lbXB0eV9kZjRfbmV3LlJEYXRhIiApDQpgYGANCg0KDQpgYGB7cn0NCiMgQW5kIGEgZmlmdGggdGltZQ0Kcm0obGlzdD1scygpKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfZW1wdHlfMjAwOV81LlJEYXRhIikNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmViX3Jlc3VsdHNfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCiMgR2V0IHRoZSBsaXN0cyBmcm9tIHRoZSBlbnZpcm9ubWVudA0KbGlzdHMgPC0gbHMoKQ0KDQpmb3IgKGogaW4gbGlzdHMpIHsgDQogIGlmKGlzLmxpc3QoZ2V0KGopKSkgeyANCiAgICBteV9saXN0IDwtIGdldChqKQ0KDQojIExvb3Agb3ZlciB0aGUgbGlzdCBmb3IgYWxsIHRoZSBkZXAgdmFycw0KZm9yIChpIGluIHNlcV9hbG9uZyhteV9saXN0KSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIobXlfbGlzdFtbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShteV9saXN0W1tpXV0pDQogIA0KICAjIEV4dHJhY3QgdGhlIGluZm8NCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbM11dDQogIHNpZ21hX3NkIDwtIHN1bVtbMywyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbNF1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbNCwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIGluIGEgZGF0YWZyYW1lDQogIGViX3Jlc3VsdHNfZGYgPC0gcmJpbmQoZWJfcmVzdWx0c19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0ID0gbXVfaW50LCBtdV9zZCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkID0gc2lnbWFfc2QsIG11X3RpbWUgPSBtdV90aW1lLCBtdV90aW1lX3NkID0gbXVfdGltZV9zZCwgc2lnX3RpbWUgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2QgPSBzaWdfdGltZV9zZCkpDQogICAgfQ0KICB9IA0KfSANCg0KIyBJdCBwcm9kdWNlcyBhbiBlcnJvciwgYnV0IGFjdHVhbGx5IGV2ZXJ5dGhpbmcgaGFzIHdvcmtlZCANCmViX3Jlc3VsdHNfZW1wdHlfZGYgPC0gZWJfcmVzdWx0c19kZg0KZWJfcmVzdWx0c19lbXB0eV9kZiR3YXZlc2V0IDwtIDUNCg0Kc2F2ZShlYl9yZXN1bHRzX2VtcHR5X2RmLCBmaWxlPSAiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2ViX3Jlc3VsdHNfZW1wdHlfZGY1X25ldy5SRGF0YSIgKQ0KYGBgDQoNCg0KYGBge3J9DQojIE5vdyBpIHdhbnQgdGhlIHNhbWUgZm9yIHRoZSBtb2RlbHMgd2l0aCB0aGUgcHJlZGljdG9ycw0KIyBGaXJzdCBjbGVhciB0aGUgZW52aXJvbm1lbnQgYmVjYXVzZSBJIGRvbid0IHdhbnQgdGhlIGVtcHR5IGxpc3RzIGl0ZXJhdGVkIGluIHRoZSBwcmVkaWN0b3IgbG9vcA0Kcm0obGlzdD1scygpKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2ViX2xpc3RfcHJlZHNfMTk4Nl8xX25ldy5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9wcmVkc18yMDA3XzFfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X3ByZWRzXzIwMDhfd19uZXcuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfcHJlZHNfMjAwOV8xX25ldy5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9wcmVkc18yMDExX3dfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X3ByZWRzX2J1eXByb2QxX25ldy5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9wcmVkc19jY2hhbmdlMl8xX25ldy5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9wcmVkc19kb3Byb3QxX25ldy5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9wcmVkc19lZmZfZGFpbHkxX25ldy5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9wcmVkc19wZXJzX2ltcDFfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X3ByZWRzX3Byc2FjdGlvbjFfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9lYl9saXN0X3ByZWRzX3F1YWxsaWZlMV9uZXcuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfcHJlZHNfZG9wcm90X2NpdHlfd19uZXcuUkRhdGEiKQ0KDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQplYl9yZXN1bHRzX3ByZWRzX2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIEdldCB0aGUgbGlzdHMgZnJvbSB0aGUgZW52aXJvbm1lbnQNCmxpc3RzIDwtIGxzKCkNCg0KZm9yIChqIGluIGxpc3RzKSB7IA0KICBpZihpcy5saXN0KGdldChqKSkpIHsgDQogICAgbXlfbGlzdCA8LSBnZXQoaikNCg0KIyBMb29wIG92ZXIgdGhlIGxpc3QgDQpmb3IgKGkgaW4gc2VxX2Fsb25nKG15X2xpc3QpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3RlcihteV9saXN0W1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KG15X2xpc3RbW2ldXSkNCiAgDQogICMgRXh0cmFjdCBpbmZvDQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzddXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzcsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzhdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzgsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBlYl9yZXN1bHRzX3ByZWRzX2RmIDwtIHJiaW5kKGViX3Jlc3VsdHNfcHJlZHNfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdF9wcmVkID0gbXVfaW50LCBtdV9zZF9wcmVkID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdF9wcmVkID0gc2lnbWFfaW50LCBzaWdtYV9zZF9wcmVkID0gc2lnbWFfc2QsIG11X3RpbWVfcHJlZCA9IG11X3RpbWUsIG11X3RpbWVfc2RfcHJlZCA9IG11X3RpbWVfc2QsIHNpZ190aW1lX3ByZWQgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2RfcHJlZCA9IHNpZ190aW1lX3NkKSkNCiAgICB9DQogIH0NCn0gDQoNCmViX3Jlc3VsdHNfcHJlZHNfZGYkd2F2ZXNldCA8LSAxDQoNCiMgQWdhaW4sIGFuIGVycm9yLCBidXQgdGhlIG91dHB1dCBpcyBjb3JyZWN0DQpzYXZlKGViX3Jlc3VsdHNfcHJlZHNfZGYsIGZpbGU9ICIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZWJfcmVzdWx0c19wcmVkc19kZjFfbmV3LlJEYXRhIiApDQpgYGANCg0KDQpgYGB7cn0NCiMgU2Vjb25kIHNldA0Kcm0obGlzdD1scygpKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2ViX2xpc3RfcHJlZHNfMTk4Nl8yX25ldy5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9wcmVkc18yMDA3XzJfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X3ByZWRzXzIwMDlfMl9uZXcuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfcHJlZHNfYnV5cHJvZDJfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X3ByZWRzX2NjaGFuZ2UyXzJfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X3ByZWRzX2RvcHJvdDJfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X3ByZWRzX2VmZl9kYWlseTJfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X3ByZWRzX3BlcnNfaW1wMl9uZXcuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfcHJlZHNfcHJzYWN0aW9uMl9uZXcuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2ViX2xpc3RfcHJlZHNfcXVhbGxpZmUyX25ldy5SRGF0YSIpDQoNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmViX3Jlc3VsdHNfcHJlZHNfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCiMgR2V0IHRoZSBsaXN0cyBmcm9tIHRoZSBlbnZpcm9ubWVudA0KbGlzdHMgPC0gbHMoKQ0KDQpmb3IgKGogaW4gbGlzdHMpIHsgDQogIGlmKGlzLmxpc3QoZ2V0KGopKSkgeyANCiAgICBteV9saXN0IDwtIGdldChqKQ0KDQojIExvb3Agb3ZlciB0aGUgbGlzdCANCmZvciAoaSBpbiBzZXFfYWxvbmcobXlfbGlzdCkpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKG15X2xpc3RbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkobXlfbGlzdFtbaV1dKQ0KICANCiAgIyBFeHRyYWN0IGluZm8NCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbN11dDQogIHNpZ21hX3NkIDwtIHN1bVtbNywyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbOF1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbOCwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIGluIGEgZGF0YWZyYW1lDQogIGViX3Jlc3VsdHNfcHJlZHNfZGYgPC0gcmJpbmQoZWJfcmVzdWx0c19wcmVkc19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0X3ByZWQgPSBtdV9pbnQsIG11X3NkX3ByZWQgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0X3ByZWQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkX3ByZWQgPSBzaWdtYV9zZCwgbXVfdGltZV9wcmVkID0gbXVfdGltZSwgbXVfdGltZV9zZF9wcmVkID0gbXVfdGltZV9zZCwgc2lnX3RpbWVfcHJlZCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9wcmVkID0gc2lnX3RpbWVfc2QpKQ0KICAgIH0NCiAgfQ0KfSANCg0KZWJfcmVzdWx0c19wcmVkc19kZiR3YXZlc2V0IDwtIDINCg0KIyBBZ2FpbiwgYW4gZXJyb3IsIGJ1dCB0aGUgb3V0cHV0IGlzIGNvcnJlY3QNCnNhdmUoZWJfcmVzdWx0c19wcmVkc19kZiwgZmlsZT0gIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9lYl9yZXN1bHRzX3ByZWRzX2RmMl9uZXcuUkRhdGEiICkNCmBgYA0KDQoNCmBgYHtyfQ0KIyBUaGlyZCBzZXQNCnJtKGxpc3Q9bHMoKSkNCg0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfcHJlZHNfMjAwN18zX25ldy5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9wcmVkc18yMDA5XzNfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X3ByZWRzX2NjaGFuZ2UyXzNfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X3ByZWRzX2VmZl9kYWlseTNfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X3ByZWRzX3Byc2FjdGlvbjNfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9lYl9saXN0X3ByZWRzX3F1YWxsaWZlM19uZXcuUkRhdGEiKQ0KDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQplYl9yZXN1bHRzX3ByZWRzX2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIEdldCB0aGUgbGlzdHMgZnJvbSB0aGUgZW52aXJvbm1lbnQNCmxpc3RzIDwtIGxzKCkNCg0KZm9yIChqIGluIGxpc3RzKSB7IA0KICBpZihpcy5saXN0KGdldChqKSkpIHsgDQogICAgbXlfbGlzdCA8LSBnZXQoaikNCg0KIyBMb29wIG92ZXIgdGhlIGxpc3QgDQpmb3IgKGkgaW4gc2VxX2Fsb25nKG15X2xpc3QpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3RlcihteV9saXN0W1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KG15X2xpc3RbW2ldXSkNCiAgDQogICMgRXh0cmFjdCBpbmZvDQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzddXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzcsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzhdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzgsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBlYl9yZXN1bHRzX3ByZWRzX2RmIDwtIHJiaW5kKGViX3Jlc3VsdHNfcHJlZHNfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdF9wcmVkID0gbXVfaW50LCBtdV9zZF9wcmVkID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdF9wcmVkID0gc2lnbWFfaW50LCBzaWdtYV9zZF9wcmVkID0gc2lnbWFfc2QsIG11X3RpbWVfcHJlZCA9IG11X3RpbWUsIG11X3RpbWVfc2RfcHJlZCA9IG11X3RpbWVfc2QsIHNpZ190aW1lX3ByZWQgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2RfcHJlZCA9IHNpZ190aW1lX3NkKSkNCiAgICB9DQogIH0NCn0gDQoNCmViX3Jlc3VsdHNfcHJlZHNfZGYkd2F2ZXNldCA8LSAzDQoNCiMgQWdhaW4sIGFuIGVycm9yLCBidXQgdGhlIG91dHB1dCBpcyBjb3JyZWN0DQpzYXZlKGViX3Jlc3VsdHNfcHJlZHNfZGYsIGZpbGU9ICIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZWJfcmVzdWx0c19wcmVkc19kZjNfbmV3LlJEYXRhIiApDQpgYGANCg0KDQpgYGB7cn0NCiMgRm91cnRoIHNldA0Kcm0obGlzdD1scygpKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfcHJlZHNfMjAwOV80X25ldy5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9wcmVkc19jY2hhbmdlMl80X25ldy5SRGF0YSIpDQoNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmViX3Jlc3VsdHNfcHJlZHNfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCiMgR2V0IHRoZSBsaXN0cyBmcm9tIHRoZSBlbnZpcm9ubWVudA0KbGlzdHMgPC0gbHMoKQ0KDQpmb3IgKGogaW4gbGlzdHMpIHsgDQogIGlmKGlzLmxpc3QoZ2V0KGopKSkgeyANCiAgICBteV9saXN0IDwtIGdldChqKQ0KDQojIExvb3Agb3ZlciB0aGUgbGlzdCANCmZvciAoaSBpbiBzZXFfYWxvbmcobXlfbGlzdCkpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKG15X2xpc3RbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkobXlfbGlzdFtbaV1dKQ0KICANCiAgIyBFeHRyYWN0IGluZm8NCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbN11dDQogIHNpZ21hX3NkIDwtIHN1bVtbNywyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbOF1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbOCwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIGluIGEgZGF0YWZyYW1lDQogIGViX3Jlc3VsdHNfcHJlZHNfZGYgPC0gcmJpbmQoZWJfcmVzdWx0c19wcmVkc19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0X3ByZWQgPSBtdV9pbnQsIG11X3NkX3ByZWQgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0X3ByZWQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkX3ByZWQgPSBzaWdtYV9zZCwgbXVfdGltZV9wcmVkID0gbXVfdGltZSwgbXVfdGltZV9zZF9wcmVkID0gbXVfdGltZV9zZCwgc2lnX3RpbWVfcHJlZCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9wcmVkID0gc2lnX3RpbWVfc2QpKQ0KICAgIH0NCiAgfQ0KfSANCg0KZWJfcmVzdWx0c19wcmVkc19kZiR3YXZlc2V0IDwtIDQNCg0KIyBBZ2FpbiwgYW4gZXJyb3IsIGJ1dCB0aGUgb3V0cHV0IGlzIGNvcnJlY3QNCnNhdmUoZWJfcmVzdWx0c19wcmVkc19kZiwgZmlsZT0gIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9lYl9yZXN1bHRzX3ByZWRzX2RmNF9uZXcuUkRhdGEiICkNCmBgYA0KDQoNCmBgYHtyfQ0KIyBBbmQgZmluYWxseSB0aGUgZmlmdGggDQpybShsaXN0PWxzKCkpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9wcmVkc18yMDA5XzVfbmV3LlJEYXRhIikNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmViX3Jlc3VsdHNfcHJlZHNfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCiMgR2V0IHRoZSBsaXN0cyBmcm9tIHRoZSBlbnZpcm9ubWVudA0KbGlzdHMgPC0gbHMoKQ0KDQpmb3IgKGogaW4gbGlzdHMpIHsgDQogIGlmKGlzLmxpc3QoZ2V0KGopKSkgeyANCiAgICBteV9saXN0IDwtIGdldChqKQ0KDQojIExvb3Agb3ZlciB0aGUgbGlzdCANCmZvciAoaSBpbiBzZXFfYWxvbmcobXlfbGlzdCkpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKG15X2xpc3RbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkobXlfbGlzdFtbaV1dKQ0KICANCiAgIyBFeHRyYWN0IGluZm8NCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbN11dDQogIHNpZ21hX3NkIDwtIHN1bVtbNywyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbOF1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbOCwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIGluIGEgZGF0YWZyYW1lDQogIGViX3Jlc3VsdHNfcHJlZHNfZGYgPC0gcmJpbmQoZWJfcmVzdWx0c19wcmVkc19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0X3ByZWQgPSBtdV9pbnQsIG11X3NkX3ByZWQgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0X3ByZWQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkX3ByZWQgPSBzaWdtYV9zZCwgbXVfdGltZV9wcmVkID0gbXVfdGltZSwgbXVfdGltZV9zZF9wcmVkID0gbXVfdGltZV9zZCwgc2lnX3RpbWVfcHJlZCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9wcmVkID0gc2lnX3RpbWVfc2QpKQ0KICAgIH0NCiAgfQ0KfSANCg0KZWJfcmVzdWx0c19wcmVkc19kZiR3YXZlc2V0IDwtIDUNCg0KIyBBZ2FpbiwgYW4gZXJyb3IsIGJ1dCB0aGUgb3V0cHV0IGlzIGNvcnJlY3QNCnNhdmUoZWJfcmVzdWx0c19wcmVkc19kZiwgZmlsZT0gIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9lYl9yZXN1bHRzX3ByZWRzX2RmNV9uZXcuUkRhdGEiICkNCmBgYA0KDQoNCmBgYHtyfQ0KIyBMYXN0bHkgZm9yIHRoZSBpbnRlcmFjdGlvbiBtb2RlbHMNCnJtKGxpc3Q9bHMoKSkNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X2ludGVyYWN0aW9uc18xOTg2X3dfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X2ludGVyYWN0aW9uc18yMDA3XzFfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X2ludGVyYWN0aW9uc18yMDA4X3dfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X2ludGVyYWN0aW9uc18yMDA5XzFfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X2ludGVyYWN0aW9uc18yMDExX3dfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X2ludGVyYWN0aW9uc19idXlwcm9kMV9uZXcuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfaW50ZXJhY3Rpb25zX2NjaGFuZ2UyXzFfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X2ludGVyYWN0aW9uc19kb3Byb3QxX25ldy5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9pbnRlcmFjdGlvbnNfZWZmX2RhaWx5MV9uZXcuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfaW50ZXJhY3Rpb25zX3BlcnNfaW1wMV9uZXcuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfaW50ZXJhY3Rpb25zX3Byc2FjdGlvbjFfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9lYl9saXN0X2ludGVyYWN0aW9uc19xdWFsbGlmZTFfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X2ludGVyYWN0aW9uc19kb3Byb3RfY2l0eV93X25ldy5SRGF0YSIpDQoNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmViX3Jlc3VsdHNfaW50ZXJhY3Rpb25zX2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIEdldCB0aGUgbGlzdHMgZnJvbSB0aGUgZW52aXJvbm1lbnQNCmxpc3RzIDwtIGxzKCkNCg0KZm9yIChqIGluIGxpc3RzKSB7IA0KICBpZihpcy5saXN0KGdldChqKSkpIHsgDQogICAgbXlfbGlzdCA8LSBnZXQoaikNCg0KIyBMb29wIG92ZXIgdGhlIG51bWJlciBvZiBkZXAgdmFycyBpbiB0aGUgbGlzdA0KZm9yIChpIGluIHNlcV9hbG9uZyhteV9saXN0KSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIobXlfbGlzdFtbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShteV9saXN0W1tpXV0pDQogIA0KICAjIEV4dHJhY3QgdGhlIGluZm8gSSBuZWVkIGZyb20gdGhlIHN1bW1hcnkNCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbMTFdXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzExLDJdXQ0KICBtdV90aW1lIDwtIHN1bSBbWzJdXQ0KICBtdV90aW1lX3NkIDwtIHN1bVtbMiwyXV0NCiAgc2lnX3RpbWUgPC0gc3VtW1sxMl1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbMTIsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBlYl9yZXN1bHRzX2ludGVyYWN0aW9uc19kZiA8LSByYmluZChlYl9yZXN1bHRzX2ludGVyYWN0aW9uc19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0X2ludCA9IG11X2ludCwgbXVfc2RfaW50ID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdF9pbnQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkX2ludCA9IHNpZ21hX3NkLCBtdV90aW1lX2ludCA9IG11X3RpbWUsIG11X3RpbWVfc2RfaW50ID0gbXVfdGltZV9zZCwgc2lnX3RpbWVfaW50ID0gc2lnX3RpbWUsIHNpZ190aW1lX3NkX2ludCA9IHNpZ190aW1lX3NkKSkNCiAgICB9DQogIH0gDQp9IA0KDQplYl9yZXN1bHRzX2ludGVyYWN0aW9uc19kZiR3YXZlc2V0IDwtIDENCg0Kc2F2ZShlYl9yZXN1bHRzX2ludGVyYWN0aW9uc19kZiwgZmlsZT0gIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9lYl9yZXN1bHRzX2ludGVyYWN0aW9uc19kZjFfbmV3LlJEYXRhIiApDQpgYGANCg0KDQpgYGB7cn0NCiMgU2Vjb25kIHNldA0Kcm0obGlzdD1scygpKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfaW50ZXJhY3Rpb25zXzIwMDdfMl9uZXcuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfaW50ZXJhY3Rpb25zXzIwMDlfMl9uZXcuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfaW50ZXJhY3Rpb25zX2J1eXByb2QyX25ldy5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9pbnRlcmFjdGlvbnNfY2NoYW5nZTJfMl9uZXcuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfaW50ZXJhY3Rpb25zX2RvcHJvdDJfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X2ludGVyYWN0aW9uc19lZmZfZGFpbHkyX25ldy5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9pbnRlcmFjdGlvbnNfcGVyc19pbXAyX25ldy5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9pbnRlcmFjdGlvbnNfcHJzYWN0aW9uMl9uZXcuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2ViX2xpc3RfaW50ZXJhY3Rpb25zX3F1YWxsaWZlMl9uZXcuUkRhdGEiKQ0KDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQplYl9yZXN1bHRzX2ludGVyYWN0aW9uc19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBHZXQgdGhlIGxpc3RzIGZyb20gdGhlIGVudmlyb25tZW50DQpsaXN0cyA8LSBscygpDQoNCmZvciAoaiBpbiBsaXN0cykgeyANCiAgaWYoaXMubGlzdChnZXQoaikpKSB7IA0KICAgIG15X2xpc3QgPC0gZ2V0KGopDQoNCiMgTG9vcCBvdmVyIHRoZSBudW1iZXIgb2YgZGVwIHZhcnMgaW4gdGhlIGxpc3QNCmZvciAoaSBpbiBzZXFfYWxvbmcobXlfbGlzdCkpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKG15X2xpc3RbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkobXlfbGlzdFtbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvIEkgbmVlZCBmcm9tIHRoZSBzdW1tYXJ5DQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzExXV0NCiAgc2lnbWFfc2QgPC0gc3VtW1sxMSwyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbMTJdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzEyLDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYgPC0gcmJpbmQoZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdF9pbnQgPSBtdV9pbnQsIG11X3NkX2ludCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHRfaW50ID0gc2lnbWFfaW50LCBzaWdtYV9zZF9pbnQgPSBzaWdtYV9zZCwgbXVfdGltZV9pbnQgPSBtdV90aW1lLCBtdV90aW1lX3NkX2ludCA9IG11X3RpbWVfc2QsIHNpZ190aW1lX2ludCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9pbnQgPSBzaWdfdGltZV9zZCkpDQogICAgfQ0KICB9IA0KfSANCg0KZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYkd2F2ZXNldCA8LSAyDQoNCnNhdmUoZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYsIGZpbGU9ICIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYyX25ldy5SRGF0YSIgKQ0KYGBgDQoNCg0KYGBge3J9DQojIFRoaXJkIHNldA0Kcm0obGlzdD1scygpKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfaW50ZXJhY3Rpb25zXzIwMDdfM19uZXcuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfaW50ZXJhY3Rpb25zXzIwMDlfM19uZXcuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2ViX2xpc3RfaW50ZXJhY3Rpb25zX2NjaGFuZ2UyXzNfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X2ludGVyYWN0aW9uc19lZmZfZGFpbHkzX25ldy5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9pbnRlcmFjdGlvbnNfcHJzYWN0aW9uM19uZXcuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2ViX2xpc3RfaW50ZXJhY3Rpb25zX3F1YWxsaWZlM19uZXcuUkRhdGEiKQ0KDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQplYl9yZXN1bHRzX2ludGVyYWN0aW9uc19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBHZXQgdGhlIGxpc3RzIGZyb20gdGhlIGVudmlyb25tZW50DQpsaXN0cyA8LSBscygpDQoNCmZvciAoaiBpbiBsaXN0cykgeyANCiAgaWYoaXMubGlzdChnZXQoaikpKSB7IA0KICAgIG15X2xpc3QgPC0gZ2V0KGopDQoNCiMgTG9vcCBvdmVyIHRoZSBudW1iZXIgb2YgZGVwIHZhcnMgaW4gdGhlIGxpc3QNCmZvciAoaSBpbiBzZXFfYWxvbmcobXlfbGlzdCkpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKG15X2xpc3RbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkobXlfbGlzdFtbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvIEkgbmVlZCBmcm9tIHRoZSBzdW1tYXJ5DQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzExXV0NCiAgc2lnbWFfc2QgPC0gc3VtW1sxMSwyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbMTJdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzEyLDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYgPC0gcmJpbmQoZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdF9pbnQgPSBtdV9pbnQsIG11X3NkX2ludCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHRfaW50ID0gc2lnbWFfaW50LCBzaWdtYV9zZF9pbnQgPSBzaWdtYV9zZCwgbXVfdGltZV9pbnQgPSBtdV90aW1lLCBtdV90aW1lX3NkX2ludCA9IG11X3RpbWVfc2QsIHNpZ190aW1lX2ludCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9pbnQgPSBzaWdfdGltZV9zZCkpDQogICAgfQ0KICB9IA0KfSANCg0KZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYkd2F2ZXNldCA8LSAzDQoNCnNhdmUoZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYsIGZpbGU9ICIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYzX25ldy5SRGF0YSIgKQ0KYGBgDQoNCg0KYGBge3J9DQojIEZvdXJ0aCBzZXQNCnJtKGxpc3Q9bHMoKSkNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X2ludGVyYWN0aW9uc18yMDA5XzRfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9lYl9saXN0X2ludGVyYWN0aW9uc19jY2hhbmdlMl80X25ldy5SRGF0YSIpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQplYl9yZXN1bHRzX2ludGVyYWN0aW9uc19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBHZXQgdGhlIGxpc3RzIGZyb20gdGhlIGVudmlyb25tZW50DQpsaXN0cyA8LSBscygpDQoNCmZvciAoaiBpbiBsaXN0cykgeyANCiAgaWYoaXMubGlzdChnZXQoaikpKSB7IA0KICAgIG15X2xpc3QgPC0gZ2V0KGopDQoNCiMgTG9vcCBvdmVyIHRoZSBudW1iZXIgb2YgZGVwIHZhcnMgaW4gdGhlIGxpc3QNCmZvciAoaSBpbiBzZXFfYWxvbmcobXlfbGlzdCkpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKG15X2xpc3RbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkobXlfbGlzdFtbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvIEkgbmVlZCBmcm9tIHRoZSBzdW1tYXJ5DQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzExXV0NCiAgc2lnbWFfc2QgPC0gc3VtW1sxMSwyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbMTJdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzEyLDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYgPC0gcmJpbmQoZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdF9pbnQgPSBtdV9pbnQsIG11X3NkX2ludCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHRfaW50ID0gc2lnbWFfaW50LCBzaWdtYV9zZF9pbnQgPSBzaWdtYV9zZCwgbXVfdGltZV9pbnQgPSBtdV90aW1lLCBtdV90aW1lX3NkX2ludCA9IG11X3RpbWVfc2QsIHNpZ190aW1lX2ludCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9pbnQgPSBzaWdfdGltZV9zZCkpDQogICAgfQ0KICB9IA0KfSANCg0KZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYkd2F2ZXNldCA8LSA0DQoNCnNhdmUoZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYsIGZpbGU9ICIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGY0X25ldy5SRGF0YSIgKQ0KYGBgDQoNCg0KYGBge3J9DQojIEFuZCB0aGUgZmlmdGggDQpybShsaXN0PWxzKCkpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvZWJfbGlzdF9pbnRlcmFjdGlvbnNfMjAwOV81X25ldy5SRGF0YSIpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQplYl9yZXN1bHRzX2ludGVyYWN0aW9uc19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBHZXQgdGhlIGxpc3RzIGZyb20gdGhlIGVudmlyb25tZW50DQpsaXN0cyA8LSBscygpDQoNCmZvciAoaiBpbiBsaXN0cykgeyANCiAgaWYoaXMubGlzdChnZXQoaikpKSB7IA0KICAgIG15X2xpc3QgPC0gZ2V0KGopDQoNCiMgTG9vcCBvdmVyIHRoZSBudW1iZXIgb2YgZGVwIHZhcnMgaW4gdGhlIGxpc3QNCmZvciAoaSBpbiBzZXFfYWxvbmcobXlfbGlzdCkpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKG15X2xpc3RbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkobXlfbGlzdFtbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvIEkgbmVlZCBmcm9tIHRoZSBzdW1tYXJ5DQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzExXV0NCiAgc2lnbWFfc2QgPC0gc3VtW1sxMSwyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbMTJdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzEyLDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYgPC0gcmJpbmQoZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdF9pbnQgPSBtdV9pbnQsIG11X3NkX2ludCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHRfaW50ID0gc2lnbWFfaW50LCBzaWdtYV9zZF9pbnQgPSBzaWdtYV9zZCwgbXVfdGltZV9pbnQgPSBtdV90aW1lLCBtdV90aW1lX3NkX2ludCA9IG11X3RpbWVfc2QsIHNpZ190aW1lX2ludCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9pbnQgPSBzaWdfdGltZV9zZCkpDQogICAgfQ0KICB9IA0KfSANCg0KZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYkd2F2ZXNldCA8LSA1DQoNCnNhdmUoZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYsIGZpbGU9ICIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGY1X25ldy5SRGF0YSIgKQ0KYGBgDQoNCiMjIFNPQ09OIHstfQ0KYGBge3J9DQojIE5vdyB0aGUgc2FtZSBmb3IgdGhlIFNPQ09ODQpybShsaXN0ID0gbHMoKSkNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9zb2Nvbl9saXN0X2VtcHR5MS5SRGF0YSIpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQpzb2Nvbl9lbXB0eV9kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBMb29wIG92ZXIgdGhlIGxpc3QgZm9yIGFsbCB0aGUgZGVwIHZhcnMNCmZvciAoaSBpbiBzZXFfYWxvbmcoc29jb25fbGlzdF9lbXB0eSkpIHsNCg0KICAjIEV4dHJhY3QgdGhlIG5hbWUgb2YgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKHNvY29uX2xpc3RfZW1wdHlbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkoc29jb25fbGlzdF9lbXB0eVtbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvDQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzNdXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzMsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzRdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzQsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBzb2Nvbl9lbXB0eV9kZiA8LSByYmluZChzb2Nvbl9lbXB0eV9kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0ID0gbXVfaW50LCBtdV9zZCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkID0gc2lnbWFfc2QsIG11X3RpbWUgPSBtdV90aW1lLCBtdV90aW1lX3NkID0gbXVfdGltZV9zZCwgc2lnX3RpbWUgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2QgPSBzaWdfdGltZV9zZCkpDQp9DQoNCiMgQW5kIHRoZSBwcmVkaWN0b3IgbW9kZWwNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9zb2Nvbl9saXN0X3ByZWRzMV9uZXcuUkRhdGEiKQ0KDQojIFN0b3JlIHRoZSByZXN1bHRzIGluIGEgbmV3IGRhdGFmcmFtZQ0Kc29jb25fcHJlZHNfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCiMgTG9vcCBvdmVyIHRoZSBsaXN0IG9mIG1vZGVscw0KZm9yIChpIGluIHNlcV9hbG9uZyhzb2Nvbl9saXN0X3ByZWRzKSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIoc29jb25fbGlzdF9wcmVkc1tbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShzb2Nvbl9saXN0X3ByZWRzW1tpXV0pDQogIA0KICAjIEV4dHJhY3QgdGhlIGludGVyY2VwdCBhbmQgc3RhbmRhcmQgZGV2aWF0aW9uIGZvciBtdSBhbmQgc2lnbWENCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbN11dDQogIHNpZ21hX3NkIDwtIHN1bVtbNywyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbOF1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbOCwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIA0KICBzb2Nvbl9wcmVkc19kZiA8LSByYmluZChzb2Nvbl9wcmVkc19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0X3ByZWQgPSBtdV9pbnQsIG11X3NkX3ByZWQgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0X3ByZWQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkX3ByZWQgPSBzaWdtYV9zZCwgbXVfdGltZV9wcmVkID0gbXVfdGltZSwgbXVfdGltZV9zZF9wcmVkID0gbXVfdGltZV9zZCwgc2lnX3RpbWVfcHJlZCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9wcmVkID0gc2lnX3RpbWVfc2QpKQ0KfQ0KDQojIEFuZCBsYXN0bHkgdGhlIGludGVyYWN0aW9uIG1vZGVsDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvc29jb25fbGlzdF9pbnRlcmFjdGlvbnMxX25ldy5SRGF0YSIpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQpzb2Nvbl9pbnRlcmFjdGlvbnNfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCiMgTG9vcCBvdmVyIHRoZSBudW1iZXIgb2YgZGVwIHZhcnMgaW4gdGhlIGxpc3QNCmZvciAoaSBpbiBzZXFfYWxvbmcoc29jb25fbGlzdF9pbnRlcmFjdGlvbnMpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3Rlcihzb2Nvbl9saXN0X2ludGVyYWN0aW9uc1tbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShzb2Nvbl9saXN0X2ludGVyYWN0aW9uc1tbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvIEkgbmVlZCBmcm9tIHRoZSBzdW1tYXJ5DQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzExXV0NCiAgc2lnbWFfc2QgPC0gc3VtW1sxMSwyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbMTJdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzEyLDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgc29jb25faW50ZXJhY3Rpb25zX2RmIDwtIHJiaW5kKHNvY29uX2ludGVyYWN0aW9uc19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0X2ludCA9IG11X2ludCwgbXVfc2RfaW50ID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdF9pbnQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkX2ludCA9IHNpZ21hX3NkLCBtdV90aW1lX2ludCA9IG11X3RpbWUsIG11X3RpbWVfc2RfaW50ID0gbXVfdGltZV9zZCwgc2lnX3RpbWVfaW50ID0gc2lnX3RpbWUsIHNpZ190aW1lX3NkX2ludCA9IHNpZ190aW1lX3NkKSkNCn0NCg0KIyBNZXJnZSB0aGUgcmVzdWx0cywgYW5kIGFkZCBzb21lIHZhcmlhYmxlcyB3aXRoIGV4dHJhIGluZm9ybWF0aW9uIA0Kc29jb25fcmVzdWx0c19kZiA8LSBtZXJnZShzb2Nvbl9lbXB0eV9kZiwgc29jb25fcHJlZHNfZGYpDQpzb2Nvbl9yZXN1bHRzX2RmIDwtIG1lcmdlKHNvY29uX3Jlc3VsdHNfZGYsIHNvY29uX2ludGVyYWN0aW9uc19kZikNCnNvY29uX3Jlc3VsdHNfZGYkZmlyc3RfeWVhciA8LSAyMDIwIA0Kc29jb25fcmVzdWx0c19kZiRtZWFuX3llYXIgPC0gMjAyMQ0Kc29jb25fcmVzdWx0c19kZiR3YXZlc2V0IDwtIDENCnNvY29uX3Jlc3VsdHNfZGYkZGF0YSA8LSAiU09DT04iDQoNCnNhdmUoc29jb25fcmVzdWx0c19kZiwgZmlsZT0iLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL3NvY29uX3Jlc3VsdHNfZGYxX25ldy5SRGF0YSIpDQpgYGANCg0KYGBge3J9DQojIE5vdyB0aGUgc2FtZSBmb3IgdGhlIFNPQ09ODQpybShsaXN0ID0gbHMoKSkNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9zb2Nvbl9saXN0X2VtcHR5Mi5SRGF0YSIpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQpzb2Nvbl9lbXB0eV9kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBMb29wIG92ZXIgdGhlIGxpc3QgZm9yIGFsbCB0aGUgZGVwIHZhcnMNCmZvciAoaSBpbiBzZXFfYWxvbmcoc29jb25fbGlzdF9lbXB0eSkpIHsNCg0KICAjIEV4dHJhY3QgdGhlIG5hbWUgb2YgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKHNvY29uX2xpc3RfZW1wdHlbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkoc29jb25fbGlzdF9lbXB0eVtbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvDQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzNdXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzMsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzRdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzQsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBzb2Nvbl9lbXB0eV9kZiA8LSByYmluZChzb2Nvbl9lbXB0eV9kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0ID0gbXVfaW50LCBtdV9zZCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkID0gc2lnbWFfc2QsIG11X3RpbWUgPSBtdV90aW1lLCBtdV90aW1lX3NkID0gbXVfdGltZV9zZCwgc2lnX3RpbWUgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2QgPSBzaWdfdGltZV9zZCkpDQp9DQoNCiMgQW5kIHRoZSBwcmVkaWN0b3IgbW9kZWwNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9zb2Nvbl9saXN0X3ByZWRzMl9uZXcuUkRhdGEiKQ0KDQojIFN0b3JlIHRoZSByZXN1bHRzIGluIGEgbmV3IGRhdGFmcmFtZQ0Kc29jb25fcHJlZHNfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCiMgTG9vcCBvdmVyIHRoZSBsaXN0IG9mIG1vZGVscw0KZm9yIChpIGluIHNlcV9hbG9uZyhzb2Nvbl9saXN0X3ByZWRzKSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIoc29jb25fbGlzdF9wcmVkc1tbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShzb2Nvbl9saXN0X3ByZWRzW1tpXV0pDQogIA0KICAjIEV4dHJhY3QgdGhlIGludGVyY2VwdCBhbmQgc3RhbmRhcmQgZGV2aWF0aW9uIGZvciBtdSBhbmQgc2lnbWENCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbN11dDQogIHNpZ21hX3NkIDwtIHN1bVtbNywyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbOF1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbOCwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIA0KICBzb2Nvbl9wcmVkc19kZiA8LSByYmluZChzb2Nvbl9wcmVkc19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0X3ByZWQgPSBtdV9pbnQsIG11X3NkX3ByZWQgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0X3ByZWQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkX3ByZWQgPSBzaWdtYV9zZCwgbXVfdGltZV9wcmVkID0gbXVfdGltZSwgbXVfdGltZV9zZF9wcmVkID0gbXVfdGltZV9zZCwgc2lnX3RpbWVfcHJlZCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9wcmVkID0gc2lnX3RpbWVfc2QpKQ0KfQ0KDQojIEFuZCBsYXN0bHkgdGhlIGludGVyYWN0aW9uIG1vZGVsDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvc29jb25fbGlzdF9pbnRlcmFjdGlvbnMyX25ldy5SRGF0YSIpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQpzb2Nvbl9pbnRlcmFjdGlvbnNfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCiMgTG9vcCBvdmVyIHRoZSBudW1iZXIgb2YgZGVwIHZhcnMgaW4gdGhlIGxpc3QNCmZvciAoaSBpbiBzZXFfYWxvbmcoc29jb25fbGlzdF9pbnRlcmFjdGlvbnMpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3Rlcihzb2Nvbl9saXN0X2ludGVyYWN0aW9uc1tbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShzb2Nvbl9saXN0X2ludGVyYWN0aW9uc1tbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvIEkgbmVlZCBmcm9tIHRoZSBzdW1tYXJ5DQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzExXV0NCiAgc2lnbWFfc2QgPC0gc3VtW1sxMSwyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbMTJdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzEyLDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgc29jb25faW50ZXJhY3Rpb25zX2RmIDwtIHJiaW5kKHNvY29uX2ludGVyYWN0aW9uc19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0X2ludCA9IG11X2ludCwgbXVfc2RfaW50ID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdF9pbnQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkX2ludCA9IHNpZ21hX3NkLCBtdV90aW1lX2ludCA9IG11X3RpbWUsIG11X3RpbWVfc2RfaW50ID0gbXVfdGltZV9zZCwgc2lnX3RpbWVfaW50ID0gc2lnX3RpbWUsIHNpZ190aW1lX3NkX2ludCA9IHNpZ190aW1lX3NkKSkNCn0NCg0KIyBNZXJnZSB0aGUgcmVzdWx0cywgYW5kIGFkZCBzb21lIHZhcmlhYmxlcyB3aXRoIGV4dHJhIGluZm9ybWF0aW9uIA0Kc29jb25fcmVzdWx0c19kZiA8LSBtZXJnZShzb2Nvbl9lbXB0eV9kZiwgc29jb25fcHJlZHNfZGYpDQpzb2Nvbl9yZXN1bHRzX2RmIDwtIG1lcmdlKHNvY29uX3Jlc3VsdHNfZGYsIHNvY29uX2ludGVyYWN0aW9uc19kZikNCnNvY29uX3Jlc3VsdHNfZGYkZmlyc3RfeWVhciA8LSAyMDIxIA0Kc29jb25fcmVzdWx0c19kZiRtZWFuX3llYXIgPC0gMjAyMQ0Kc29jb25fcmVzdWx0c19kZiR3YXZlc2V0IDwtIDINCnNvY29uX3Jlc3VsdHNfZGYkZGF0YSA8LSAiU09DT04iDQoNCnNhdmUoc29jb25fcmVzdWx0c19kZiwgZmlsZT0iLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL3NvY29uX3Jlc3VsdHNfZGYyX25ldy5SRGF0YSIpDQpgYGANCg0KIyMgTElTUyB7LX0NCg0KYGBge3J9DQojIE5vdyB0aGUgc2FtZSBmb3IgdGhlIExJU1MNCnJtKGxpc3Q9bHMoKSkNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9saXNzX2xpc3RfZW1wdHkxLlJEYXRhIikNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmxpc3NfZW1wdHlfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCiMgTG9vcCBvdmVyIHRoZSBsaXN0IGZvciBhbGwgdGhlIGRlcCB2YXJzDQpmb3IgKGkgaW4gc2VxX2Fsb25nKGxpc3NfbGlzdF9lbXB0eSkpIHsNCg0KICAjIEV4dHJhY3QgdGhlIG5hbWUgb2YgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKGxpc3NfbGlzdF9lbXB0eVtbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShsaXNzX2xpc3RfZW1wdHlbW2ldXSkNCiAgDQogICMgRXh0cmFjdCB0aGUgaW5mbw0KICBtdV9pbnQgPC0gc3VtW1sxXV0NCiAgbXVfc2QgPC0gc3VtW1sxLDJdXQ0KICBzaWdtYV9pbnQgPC0gc3VtW1szXV0NCiAgc2lnbWFfc2QgPC0gc3VtW1szLDJdXQ0KICBtdV90aW1lIDwtIHN1bSBbWzJdXQ0KICBtdV90aW1lX3NkIDwtIHN1bVtbMiwyXV0NCiAgc2lnX3RpbWUgPC0gc3VtW1s0XV0NCiAgc2lnX3RpbWVfc2QgPC0gc3VtW1s0LDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgbGlzc19lbXB0eV9kZiA8LSByYmluZChsaXNzX2VtcHR5X2RmLCBkYXRhLmZyYW1lKGRlcF92YXIgPSBkZXBfdmFyLCBtdV9pbnRlcmNlcHQgPSBtdV9pbnQsIG11X3NkID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdCA9IHNpZ21hX2ludCwgc2lnbWFfc2QgPSBzaWdtYV9zZCwgbXVfdGltZSA9IG11X3RpbWUsIG11X3RpbWVfc2QgPSBtdV90aW1lX3NkLCBzaWdfdGltZSA9IHNpZ190aW1lLCBzaWdfdGltZV9zZCA9IHNpZ190aW1lX3NkKSkNCn0NCg0KIyBBbmQgdGhlIHByZWRpY3RvciBtb2RlbA0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2xpc3NfbGlzdF9wcmVkczFfbmV3LlJEYXRhIikNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmxpc3NfcHJlZHNfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCiMgTG9vcCBvdmVyIHRoZSBsaXN0IG9mIG1vZGVscw0KZm9yIChpIGluIHNlcV9hbG9uZyhsaXNzX2xpc3RfcHJlZHMpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3RlcihsaXNzX2xpc3RfcHJlZHNbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkobGlzc19saXN0X3ByZWRzW1tpXV0pDQogIA0KICAjIEV4dHJhY3QgdGhlIGludGVyY2VwdCBhbmQgc3RhbmRhcmQgZGV2aWF0aW9uIGZvciBtdSBhbmQgc2lnbWENCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbN11dDQogIHNpZ21hX3NkIDwtIHN1bVtbNywyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbOF1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbOCwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIA0KICBsaXNzX3ByZWRzX2RmIDwtIHJiaW5kKGxpc3NfcHJlZHNfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdF9wcmVkID0gbXVfaW50LCBtdV9zZF9wcmVkID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdF9wcmVkID0gc2lnbWFfaW50LCBzaWdtYV9zZF9wcmVkID0gc2lnbWFfc2QsIG11X3RpbWVfcHJlZCA9IG11X3RpbWUsIG11X3RpbWVfc2RfcHJlZCA9IG11X3RpbWVfc2QsIHNpZ190aW1lX3ByZWQgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2RfcHJlZCA9IHNpZ190aW1lX3NkKSkNCn0NCg0KIyBBbmQgbGFzdGx5IHRoZSBpbnRlcmFjdGlvbiBtb2RlbA0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2xpc3NfbGlzdF9pbnRlcmFjdGlvbnMxX25ldy5SRGF0YSIpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQpsaXNzX2ludGVyYWN0aW9uc19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBMb29wIG92ZXIgdGhlIG51bWJlciBvZiBkZXAgdmFycyBpbiB0aGUgbGlzdA0KZm9yIChpIGluIHNlcV9hbG9uZyhsaXNzX2xpc3RfaW50ZXJhY3Rpb25zKSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIobGlzc19saXN0X2ludGVyYWN0aW9uc1tbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShsaXNzX2xpc3RfaW50ZXJhY3Rpb25zW1tpXV0pDQogIA0KICAjIEV4dHJhY3QgdGhlIGluZm8gSSBuZWVkIGZyb20gdGhlIHN1bW1hcnkNCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbMTFdXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzExLDJdXQ0KICBtdV90aW1lIDwtIHN1bSBbWzJdXQ0KICBtdV90aW1lX3NkIDwtIHN1bVtbMiwyXV0NCiAgc2lnX3RpbWUgPC0gc3VtW1sxMl1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbMTIsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBsaXNzX2ludGVyYWN0aW9uc19kZiA8LSByYmluZChsaXNzX2ludGVyYWN0aW9uc19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0X2ludCA9IG11X2ludCwgbXVfc2RfaW50ID0gbXVfc2QsIHNpZ21hX2ludGVyY2VwdF9pbnQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkX2ludCA9IHNpZ21hX3NkLCBtdV90aW1lX2ludCA9IG11X3RpbWUsIG11X3RpbWVfc2RfaW50ID0gbXVfdGltZV9zZCwgc2lnX3RpbWVfaW50ID0gc2lnX3RpbWUsIHNpZ190aW1lX3NkX2ludCA9IHNpZ190aW1lX3NkKSkNCn0NCg0KIyBNZXJnZSB0aGUgcmVzdWx0cywgYW5kIGFkZCBzb21lIHZhcmlhYmxlcyB3aXRoIGV4dHJhIGluZm9ybWF0aW9uIA0KbGlzc19yZXN1bHRzX2RmIDwtIG1lcmdlKGxpc3NfZW1wdHlfZGYsIGxpc3NfcHJlZHNfZGYpDQpsaXNzX3Jlc3VsdHNfZGYgPC0gbWVyZ2UobGlzc19yZXN1bHRzX2RmLCBsaXNzX2ludGVyYWN0aW9uc19kZikNCmxpc3NfcmVzdWx0c19kZiRmaXJzdF95ZWFyIDwtIDIwMTkNCmxpc3NfcmVzdWx0c19kZiRtZWFuX3llYXIgPC0gMjAyMA0KbGlzc19yZXN1bHRzX2RmJHdhdmVzZXQgPC0gMQ0KbGlzc19yZXN1bHRzX2RmJGRhdGEgPC0gIkxJU1MiDQoNCnNhdmUobGlzc19yZXN1bHRzX2RmLCBmaWxlPSIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvbGlzc19yZXN1bHRzX2RmMV9uZXcuUkRhdGEiKQ0KYGBgDQoNCmBgYHtyfQ0KIyBOb3cgdGhlIHNhbWUgZm9yIHRoZSBMSVNTDQpybShsaXN0PWxzKCkpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvbGlzc19saXN0X2VtcHR5Mi5SRGF0YSIpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQpsaXNzX2VtcHR5X2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIExvb3Agb3ZlciB0aGUgbGlzdCBmb3IgYWxsIHRoZSBkZXAgdmFycw0KZm9yIChpIGluIHNlcV9hbG9uZyhsaXNzX2xpc3RfZW1wdHkpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBuYW1lIG9mIHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3RlcihsaXNzX2xpc3RfZW1wdHlbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkobGlzc19saXN0X2VtcHR5W1tpXV0pDQogIA0KICAjIEV4dHJhY3QgdGhlIGluZm8NCiAgbXVfaW50IDwtIHN1bVtbMV1dDQogIG11X3NkIDwtIHN1bVtbMSwyXV0NCiAgc2lnbWFfaW50IDwtIHN1bVtbM11dDQogIHNpZ21hX3NkIDwtIHN1bVtbMywyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbNF1dDQogIHNpZ190aW1lX3NkIDwtIHN1bVtbNCwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIGluIGEgZGF0YWZyYW1lDQogIGxpc3NfZW1wdHlfZGYgPC0gcmJpbmQobGlzc19lbXB0eV9kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0ID0gbXVfaW50LCBtdV9zZCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkID0gc2lnbWFfc2QsIG11X3RpbWUgPSBtdV90aW1lLCBtdV90aW1lX3NkID0gbXVfdGltZV9zZCwgc2lnX3RpbWUgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2QgPSBzaWdfdGltZV9zZCkpDQp9DQoNCiMgQW5kIHRoZSBwcmVkaWN0b3IgbW9kZWwNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9saXNzX2xpc3RfcHJlZHMyX25ldy5SRGF0YSIpDQoNCiMgU3RvcmUgdGhlIHJlc3VsdHMgaW4gYSBuZXcgZGF0YWZyYW1lDQpsaXNzX3ByZWRzX2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIExvb3Agb3ZlciB0aGUgbGlzdCBvZiBtb2RlbHMNCmZvciAoaSBpbiBzZXFfYWxvbmcobGlzc19saXN0X3ByZWRzKSkgew0KDQogICMgRXh0cmFjdCB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIobGlzc19saXN0X3ByZWRzW1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KGxpc3NfbGlzdF9wcmVkc1tbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbnRlcmNlcHQgYW5kIHN0YW5kYXJkIGRldmlhdGlvbiBmb3IgbXUgYW5kIHNpZ21hDQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzddXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzcsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzhdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzgsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyANCiAgbGlzc19wcmVkc19kZiA8LSByYmluZChsaXNzX3ByZWRzX2RmLCBkYXRhLmZyYW1lKGRlcF92YXIgPSBkZXBfdmFyLCBtdV9pbnRlcmNlcHRfcHJlZCA9IG11X2ludCwgbXVfc2RfcHJlZCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHRfcHJlZCA9IHNpZ21hX2ludCwgc2lnbWFfc2RfcHJlZCA9IHNpZ21hX3NkLCBtdV90aW1lX3ByZWQgPSBtdV90aW1lLCBtdV90aW1lX3NkX3ByZWQgPSBtdV90aW1lX3NkLCBzaWdfdGltZV9wcmVkID0gc2lnX3RpbWUsIHNpZ190aW1lX3NkX3ByZWQgPSBzaWdfdGltZV9zZCkpDQp9DQoNCiMgQW5kIGxhc3RseSB0aGUgaW50ZXJhY3Rpb24gbW9kZWwNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9saXNzX2xpc3RfaW50ZXJhY3Rpb25zMl9uZXcuUkRhdGEiKQ0KDQojIFN0b3JlIHRoZSByZXN1bHRzIGluIGEgbmV3IGRhdGFmcmFtZQ0KbGlzc19pbnRlcmFjdGlvbnNfZGYgPC0gZGF0YS5mcmFtZShkZXBfdmFyID0gY2hhcmFjdGVyKCkpDQoNCiMgTG9vcCBvdmVyIHRoZSBudW1iZXIgb2YgZGVwIHZhcnMgaW4gdGhlIGxpc3QNCmZvciAoaSBpbiBzZXFfYWxvbmcobGlzc19saXN0X2ludGVyYWN0aW9ucykpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKGxpc3NfbGlzdF9pbnRlcmFjdGlvbnNbW2ldXSRtdS50ZXJtc1tbMl1dKQ0KICANCiAgICAjIFN1bW1hcml6ZSB0aGUgbW9kZWwNCiAgc3VtIDwtIHN1bW1hcnkobGlzc19saXN0X2ludGVyYWN0aW9uc1tbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvIEkgbmVlZCBmcm9tIHRoZSBzdW1tYXJ5DQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzExXV0NCiAgc2lnbWFfc2QgPC0gc3VtW1sxMSwyXV0NCiAgbXVfdGltZSA8LSBzdW0gW1syXV0NCiAgbXVfdGltZV9zZCA8LSBzdW1bWzIsMl1dDQogIHNpZ190aW1lIDwtIHN1bVtbMTJdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzEyLDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgaW4gYSBkYXRhZnJhbWUNCiAgbGlzc19pbnRlcmFjdGlvbnNfZGYgPC0gcmJpbmQobGlzc19pbnRlcmFjdGlvbnNfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdF9pbnQgPSBtdV9pbnQsIG11X3NkX2ludCA9IG11X3NkLCBzaWdtYV9pbnRlcmNlcHRfaW50ID0gc2lnbWFfaW50LCBzaWdtYV9zZF9pbnQgPSBzaWdtYV9zZCwgbXVfdGltZV9pbnQgPSBtdV90aW1lLCBtdV90aW1lX3NkX2ludCA9IG11X3RpbWVfc2QsIHNpZ190aW1lX2ludCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9pbnQgPSBzaWdfdGltZV9zZCkpDQp9DQoNCiMgTWVyZ2UgdGhlIHJlc3VsdHMsIGFuZCBhZGQgc29tZSB2YXJpYWJsZXMgd2l0aCBleHRyYSBpbmZvcm1hdGlvbiANCmxpc3NfcmVzdWx0c19kZiA8LSBtZXJnZShsaXNzX2VtcHR5X2RmLCBsaXNzX3ByZWRzX2RmKQ0KbGlzc19yZXN1bHRzX2RmIDwtIG1lcmdlKGxpc3NfcmVzdWx0c19kZiwgbGlzc19pbnRlcmFjdGlvbnNfZGYpDQpsaXNzX3Jlc3VsdHNfZGYkZmlyc3RfeWVhciA8LSAyMDIwDQpsaXNzX3Jlc3VsdHNfZGYkbWVhbl95ZWFyIDwtIDIwMjANCmxpc3NfcmVzdWx0c19kZiR3YXZlc2V0IDwtIDINCmxpc3NfcmVzdWx0c19kZiRkYXRhIDwtICJMSVNTIg0KDQpzYXZlKGxpc3NfcmVzdWx0c19kZiwgZmlsZT0iLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2xpc3NfcmVzdWx0c19kZjJfbmV3LlJEYXRhIikNCmBgYA0KDQpgYGB7cn0NCiMgTm93IHRoZSBzYW1lIGZvciB0aGUgTElTUw0Kcm0obGlzdD1scygpKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2xpc3NfbGlzdF9lbXB0eTMuUkRhdGEiKQ0KDQojIFN0b3JlIHRoZSByZXN1bHRzIGluIGEgbmV3IGRhdGFmcmFtZQ0KbGlzc19lbXB0eV9kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBMb29wIG92ZXIgdGhlIGxpc3QgZm9yIGFsbCB0aGUgZGVwIHZhcnMNCmZvciAoaSBpbiBzZXFfYWxvbmcobGlzc19saXN0X2VtcHR5KSkgew0KDQogICMgRXh0cmFjdCB0aGUgbmFtZSBvZiB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIHNvIHRoYXQgd2Uga25vdyBmb3Igd2hpY2ggZGVwIHZhciB0aGUgZWZmZWN0cyBhcmUNCiAgZGVwX3ZhciA8LSBhcy5jaGFyYWN0ZXIobGlzc19saXN0X2VtcHR5W1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KGxpc3NfbGlzdF9lbXB0eVtbaV1dKQ0KICANCiAgIyBFeHRyYWN0IHRoZSBpbmZvDQogIG11X2ludCA8LSBzdW1bWzFdXQ0KICBtdV9zZCA8LSBzdW1bWzEsMl1dDQogIHNpZ21hX2ludCA8LSBzdW1bWzNdXQ0KICBzaWdtYV9zZCA8LSBzdW1bWzMsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzRdXQ0KICBzaWdfdGltZV9zZCA8LSBzdW1bWzQsMl1dDQogIA0KICAjIFB1dCB0aGUgcmVzdWx0cyBpbiBhIGRhdGFmcmFtZQ0KICBsaXNzX2VtcHR5X2RmIDwtIHJiaW5kKGxpc3NfZW1wdHlfZGYsIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGRlcF92YXIsIG11X2ludGVyY2VwdCA9IG11X2ludCwgbXVfc2QgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0ID0gc2lnbWFfaW50LCBzaWdtYV9zZCA9IHNpZ21hX3NkLCBtdV90aW1lID0gbXVfdGltZSwgbXVfdGltZV9zZCA9IG11X3RpbWVfc2QsIHNpZ190aW1lID0gc2lnX3RpbWUsIHNpZ190aW1lX3NkID0gc2lnX3RpbWVfc2QpKQ0KfQ0KDQojIEFuZCB0aGUgcHJlZGljdG9yIG1vZGVsDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvbGlzc19saXN0X3ByZWRzM19uZXcuUkRhdGEiKQ0KDQojIFN0b3JlIHRoZSByZXN1bHRzIGluIGEgbmV3IGRhdGFmcmFtZQ0KbGlzc19wcmVkc19kZiA8LSBkYXRhLmZyYW1lKGRlcF92YXIgPSBjaGFyYWN0ZXIoKSkNCg0KIyBMb29wIG92ZXIgdGhlIGxpc3Qgb2YgbW9kZWxzDQpmb3IgKGkgaW4gc2VxX2Fsb25nKGxpc3NfbGlzdF9wcmVkcykpIHsNCg0KICAjIEV4dHJhY3QgdGhlIGRlcGVuZGVudCB2YXJpYWJsZSBzbyB0aGF0IHdlIGtub3cgZm9yIHdoaWNoIGRlcCB2YXIgdGhlIGVmZmVjdHMgYXJlDQogIGRlcF92YXIgPC0gYXMuY2hhcmFjdGVyKGxpc3NfbGlzdF9wcmVkc1tbaV1dJG11LnRlcm1zW1syXV0pDQogIA0KICAgICMgU3VtbWFyaXplIHRoZSBtb2RlbA0KICBzdW0gPC0gc3VtbWFyeShsaXNzX2xpc3RfcHJlZHNbW2ldXSkNCiAgDQogICMgRXh0cmFjdCB0aGUgaW50ZXJjZXB0IGFuZCBzdGFuZGFyZCBkZXZpYXRpb24gZm9yIG11IGFuZCBzaWdtYQ0KICBtdV9pbnQgPC0gc3VtW1sxXV0NCiAgbXVfc2QgPC0gc3VtW1sxLDJdXQ0KICBzaWdtYV9pbnQgPC0gc3VtW1s3XV0NCiAgc2lnbWFfc2QgPC0gc3VtW1s3LDJdXQ0KICBtdV90aW1lIDwtIHN1bSBbWzJdXQ0KICBtdV90aW1lX3NkIDwtIHN1bVtbMiwyXV0NCiAgc2lnX3RpbWUgPC0gc3VtW1s4XV0NCiAgc2lnX3RpbWVfc2QgPC0gc3VtW1s4LDJdXQ0KICANCiAgIyBQdXQgdGhlIHJlc3VsdHMgDQogIGxpc3NfcHJlZHNfZGYgPC0gcmJpbmQobGlzc19wcmVkc19kZiwgZGF0YS5mcmFtZShkZXBfdmFyID0gZGVwX3ZhciwgbXVfaW50ZXJjZXB0X3ByZWQgPSBtdV9pbnQsIG11X3NkX3ByZWQgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0X3ByZWQgPSBzaWdtYV9pbnQsIHNpZ21hX3NkX3ByZWQgPSBzaWdtYV9zZCwgbXVfdGltZV9wcmVkID0gbXVfdGltZSwgbXVfdGltZV9zZF9wcmVkID0gbXVfdGltZV9zZCwgc2lnX3RpbWVfcHJlZCA9IHNpZ190aW1lLCBzaWdfdGltZV9zZF9wcmVkID0gc2lnX3RpbWVfc2QpKQ0KfQ0KDQojIEFuZCBsYXN0bHkgdGhlIGludGVyYWN0aW9uIG1vZGVsDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvbGlzc19saXN0X2ludGVyYWN0aW9uczNfbmV3LlJEYXRhIikNCg0KIyBTdG9yZSB0aGUgcmVzdWx0cyBpbiBhIG5ldyBkYXRhZnJhbWUNCmxpc3NfaW50ZXJhY3Rpb25zX2RmIDwtIGRhdGEuZnJhbWUoZGVwX3ZhciA9IGNoYXJhY3RlcigpKQ0KDQojIExvb3Agb3ZlciB0aGUgbnVtYmVyIG9mIGRlcCB2YXJzIGluIHRoZSBsaXN0DQpmb3IgKGkgaW4gc2VxX2Fsb25nKGxpc3NfbGlzdF9pbnRlcmFjdGlvbnMpKSB7DQoNCiAgIyBFeHRyYWN0IHRoZSBkZXBlbmRlbnQgdmFyaWFibGUgc28gdGhhdCB3ZSBrbm93IGZvciB3aGljaCBkZXAgdmFyIHRoZSBlZmZlY3RzIGFyZQ0KICBkZXBfdmFyIDwtIGFzLmNoYXJhY3RlcihsaXNzX2xpc3RfaW50ZXJhY3Rpb25zW1tpXV0kbXUudGVybXNbWzJdXSkNCiAgDQogICAgIyBTdW1tYXJpemUgdGhlIG1vZGVsDQogIHN1bSA8LSBzdW1tYXJ5KGxpc3NfbGlzdF9pbnRlcmFjdGlvbnNbW2ldXSkNCiAgDQogICMgRXh0cmFjdCB0aGUgaW5mbyBJIG5lZWQgZnJvbSB0aGUgc3VtbWFyeQ0KICBtdV9pbnQgPC0gc3VtW1sxXV0NCiAgbXVfc2QgPC0gc3VtW1sxLDJdXQ0KICBzaWdtYV9pbnQgPC0gc3VtW1sxMV1dDQogIHNpZ21hX3NkIDwtIHN1bVtbMTEsMl1dDQogIG11X3RpbWUgPC0gc3VtIFtbMl1dDQogIG11X3RpbWVfc2QgPC0gc3VtW1syLDJdXQ0KICBzaWdfdGltZSA8LSBzdW1bWzEyXV0NCiAgc2lnX3RpbWVfc2QgPC0gc3VtW1sxMiwyXV0NCiAgDQogICMgUHV0IHRoZSByZXN1bHRzIGluIGEgZGF0YWZyYW1lDQogIGxpc3NfaW50ZXJhY3Rpb25zX2RmIDwtIHJiaW5kKGxpc3NfaW50ZXJhY3Rpb25zX2RmLCBkYXRhLmZyYW1lKGRlcF92YXIgPSBkZXBfdmFyLCBtdV9pbnRlcmNlcHRfaW50ID0gbXVfaW50LCBtdV9zZF9pbnQgPSBtdV9zZCwgc2lnbWFfaW50ZXJjZXB0X2ludCA9IHNpZ21hX2ludCwgc2lnbWFfc2RfaW50ID0gc2lnbWFfc2QsIG11X3RpbWVfaW50ID0gbXVfdGltZSwgbXVfdGltZV9zZF9pbnQgPSBtdV90aW1lX3NkLCBzaWdfdGltZV9pbnQgPSBzaWdfdGltZSwgc2lnX3RpbWVfc2RfaW50ID0gc2lnX3RpbWVfc2QpKQ0KfQ0KDQojIE1lcmdlIHRoZSByZXN1bHRzLCBhbmQgYWRkIHNvbWUgdmFyaWFibGVzIHdpdGggZXh0cmEgaW5mb3JtYXRpb24gDQpsaXNzX3Jlc3VsdHNfZGYgPC0gbWVyZ2UobGlzc19lbXB0eV9kZiwgbGlzc19wcmVkc19kZikNCmxpc3NfcmVzdWx0c19kZiA8LSBtZXJnZShsaXNzX3Jlc3VsdHNfZGYsIGxpc3NfaW50ZXJhY3Rpb25zX2RmKQ0KbGlzc19yZXN1bHRzX2RmJGZpcnN0X3llYXIgPC0gMjAyMA0KbGlzc19yZXN1bHRzX2RmJG1lYW5feWVhciA8LSAyMDIxDQpsaXNzX3Jlc3VsdHNfZGYkd2F2ZXNldCA8LSAzDQpsaXNzX3Jlc3VsdHNfZGYkZGF0YSA8LSAiTElTUyINCg0Kc2F2ZShsaXNzX3Jlc3VsdHNfZGYsIGZpbGU9Ii4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9saXNzX3Jlc3VsdHNfZGYzX25ldy5SRGF0YSIpDQpgYGANCg0KDQpgYGB7cn0NCiMgTWFrZSBvbmUgZGF0YWZyYW1lDQojIEZpcnN0IGVtcHR5IGxpc3RzDQpybShsaXN0PWxzKCkpDQojIFRoZXkgYWxsIGhhdmUgdGhlIHNhbWUgbmFtZXMsIHNvIEkgaGF2ZSB0byBhc3NpZ24gdGhlbSBhIG5ldyBuYW1lDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZWJfcmVzdWx0c19lbXB0eV9kZjFfbmV3LlJEYXRhIikNCmViXzFfZGYgPC0gZWJfcmVzdWx0c19lbXB0eV9kZg0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2ViX3Jlc3VsdHNfZW1wdHlfZGYyX25ldy5SRGF0YSIpDQplYl8yX2RmIDwtIGViX3Jlc3VsdHNfZW1wdHlfZGYNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9lYl9yZXN1bHRzX2VtcHR5X2RmM19uZXcuUkRhdGEiKQ0KZWJfM19kZiA8LSBlYl9yZXN1bHRzX2VtcHR5X2RmDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZWJfcmVzdWx0c19lbXB0eV9kZjRfbmV3LlJEYXRhIikNCmViXzRfZGYgPC0gZWJfcmVzdWx0c19lbXB0eV9kZg0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2ViX3Jlc3VsdHNfZW1wdHlfZGY1X25ldy5SRGF0YSIpDQplYl81X2RmIDwtIGViX3Jlc3VsdHNfZW1wdHlfZGYNCg0KZWJfZW1wdHlfZGZfd2F2ZXMgPC0gcmJpbmQgKGViXzFfZGYsIGViXzJfZGYsIGViXzNfZGYsIGViXzRfZGYsIGViXzVfZGYpDQplYl9lbXB0eV9kZl93YXZlcyRkZXBfdmFyX3dhdmUgPC0gcGFzdGUoZWJfZW1wdHlfZGZfd2F2ZXMkZGVwX3ZhciwgZWJfZW1wdHlfZGZfd2F2ZXMkd2F2ZXNldCwgc2VwID0gIl8iKQ0KDQpzYXZlKGViX2VtcHR5X2RmX3dhdmVzLCBmaWxlPSAiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2ViX2VtcHR5X2RmX3dhdmVzX25ldy5SRGF0YSIgKQ0KDQoNCiMgRm9yIHRoZSBwcmVkIG1vZGVscw0Kcm0obGlzdD1scygpKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2ViX3Jlc3VsdHNfcHJlZHNfZGYxX25ldy5SRGF0YSIpDQplYl8xX2RmIDwtIGViX3Jlc3VsdHNfcHJlZHNfZGYNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9lYl9yZXN1bHRzX3ByZWRzX2RmMl9uZXcuUkRhdGEiKQ0KZWJfMl9kZiA8LSBlYl9yZXN1bHRzX3ByZWRzX2RmDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZWJfcmVzdWx0c19wcmVkc19kZjNfbmV3LlJEYXRhIikNCmViXzNfZGYgPC0gZWJfcmVzdWx0c19wcmVkc19kZg0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2ViX3Jlc3VsdHNfcHJlZHNfZGY0X25ldy5SRGF0YSIpDQplYl80X2RmIDwtIGViX3Jlc3VsdHNfcHJlZHNfZGYNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9lYl9yZXN1bHRzX3ByZWRzX2RmNV9uZXcuUkRhdGEiKQ0KZWJfNV9kZiA8LSBlYl9yZXN1bHRzX3ByZWRzX2RmDQoNCmViX3ByZWRzX2RmX3dhdmVzIDwtIHJiaW5kIChlYl8xX2RmLCBlYl8yX2RmLCBlYl8zX2RmLCBlYl80X2RmLCBlYl81X2RmKQ0KZWJfcHJlZHNfZGZfd2F2ZXMkZGVwX3Zhcl93YXZlIDwtIHBhc3RlKGViX3ByZWRzX2RmX3dhdmVzJGRlcF92YXIsIGViX3ByZWRzX2RmX3dhdmVzJHdhdmVzZXQsIHNlcCA9ICJfIikNCg0Kc2F2ZShlYl9wcmVkc19kZl93YXZlcywgZmlsZT0gIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9lYl9wcmVkc19kZl93YXZlc19uZXcuUkRhdGEiICkNCg0KIyBBbmQgbGFzdGx5IHRoZSBzYW1lIGZvciB0aGUgaW50ZXJhY3Rpb25zDQpybShsaXN0PWxzKCkpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYxX25ldy5SRGF0YSIpDQplYl8xX2RmIDwtIGViX3Jlc3VsdHNfaW50ZXJhY3Rpb25zX2RmDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYyX25ldy5SRGF0YSIpDQplYl8yX2RmIDwtIGViX3Jlc3VsdHNfaW50ZXJhY3Rpb25zX2RmDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGYzX25ldy5SRGF0YSIpDQplYl8zX2RmIDwtIGViX3Jlc3VsdHNfaW50ZXJhY3Rpb25zX2RmDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGY0X25ldy5SRGF0YSIpDQplYl80X2RmIDwtIGViX3Jlc3VsdHNfaW50ZXJhY3Rpb25zX2RmDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZWJfcmVzdWx0c19pbnRlcmFjdGlvbnNfZGY1X25ldy5SRGF0YSIpDQplYl81X2RmIDwtIGViX3Jlc3VsdHNfaW50ZXJhY3Rpb25zX2RmDQoNCmViX2ludGVyYWN0aW9uc19kZl93YXZlcyA8LSByYmluZCAoZWJfMV9kZiwgZWJfMl9kZiwgZWJfM19kZiwgZWJfNF9kZiwgZWJfNV9kZikNCmViX2ludGVyYWN0aW9uc19kZl93YXZlcyRkZXBfdmFyX3dhdmUgPC0gcGFzdGUoZWJfaW50ZXJhY3Rpb25zX2RmX3dhdmVzJGRlcF92YXIsIGViX2ludGVyYWN0aW9uc19kZl93YXZlcyR3YXZlc2V0LCBzZXAgPSAiXyIpDQoNCnNhdmUoZWJfaW50ZXJhY3Rpb25zX2RmX3dhdmVzLCBmaWxlPSAiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2ViX2ludGVyYWN0aW9uc19kZl93YXZlc19uZXcuUkRhdGEiICkNCg0KIyBBbmQgbm93IG9uZSBsYXJnZSBkYXRhZnJhbWUgb2YgdGhlc2UgdGhyZWUgDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZWJfZW1wdHlfZGZfd2F2ZXNfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9lYl9wcmVkc19kZl93YXZlc19uZXcuUkRhdGEiKQ0KDQojIE1lcmdlIHRoZSByZXN1bHRzDQplYl9yZXN1bHRzX2RmIDwtIGxlZnRfam9pbihlYl9lbXB0eV9kZl93YXZlcywgZWJfcHJlZHNfZGZfd2F2ZXMpDQplYl9yZXN1bHRzX2RmIDwtIGxlZnRfam9pbihlYl9yZXN1bHRzX2RmLCBlYl9pbnRlcmFjdGlvbnNfZGZfd2F2ZXMpDQplYl9yZXN1bHRzX2RmJGRhdGEgPC0gIkVCIg0KDQojIEFzc2lnbiB5ZWFyIHBlciB2YXJpYWJsZQ0KZWJfcmVzdWx0c19kZiRmaXJzdF95ZWFyW2ViX3Jlc3VsdHNfZGYkZGVwX3ZhciA9PSAicm9sZV9pbmQiXSA8LSAyMDA3DQplYl9yZXN1bHRzX2RmJGZpcnN0X3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJiaWdfcG9sIl0gPC0gMjAwNw0KZWJfcmVzdWx0c19kZiRmaXJzdF95ZWFyW2ViX3Jlc3VsdHNfZGYkZGVwX3ZhciA9PSAiY2NfdW5zdG9wIl0gPC0gMjAwOA0KZWJfcmVzdWx0c19kZiRmaXJzdF95ZWFyW2ViX3Jlc3VsdHNfZGYkZGVwX3ZhciA9PSAiY2NfZXhhZyJdIDwtIDIwMDgNCmViX3Jlc3VsdHNfZGYkZmlyc3RfeWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImNjX3Bvc2V1Il0gPC0gMjAwOA0KZWJfcmVzdWx0c19kZiRmaXJzdF95ZWFyW2ViX3Jlc3VsdHNfZGYkZGVwX3ZhciA9PSAiY2NfcHJzYWN0Il0gPC0gMjAwOA0KZWJfcmVzdWx0c19kZiRmaXJzdF95ZWFyW2ViX3Jlc3VsdHNfZGYkZGVwX3ZhciA9PSAiY2NfcG9zZXUiXSA8LSAyMDA4DQplYl9yZXN1bHRzX2RmJGZpcnN0X3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJjY3BlcmNlcHQiXSA8LSAyMDA5DQplYl9yZXN1bHRzX2RmJGZpcnN0X3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJjY2hhbmdlIl0gPC0gMjAwOQ0KZWJfcmVzdWx0c19kZiRmaXJzdF95ZWFyW2ViX3Jlc3VsdHNfZGYkZGVwX3ZhciA9PSAiY2NoYW5nZTIiXSA8LSAyMDExDQplYl9yZXN1bHRzX2RmJGZpcnN0X3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJjY2hhbmdldG90Il0gPC0gMjAxMQ0KZWJfcmVzdWx0c19kZiRmaXJzdF95ZWFyW2ViX3Jlc3VsdHNfZGYkZGVwX3ZhciA9PSAiZW52cF9lZyJdIDwtIDIwMTENCmViX3Jlc3VsdHNfZGYkZmlyc3RfeWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImVmZnJfZWciXSA8LSAyMDExDQplYl9yZXN1bHRzX2RmJGZpcnN0X3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJidXlwcm9kIl0gPC0gMjAwNw0KZWJfcmVzdWx0c19kZiRmaXJzdF95ZWFyW2ViX3Jlc3VsdHNfZGYkZGVwX3ZhciA9PSAiZG9wcm90X25hdGdvdiJdIDwtIDIwMDkNCmViX3Jlc3VsdHNfZGYkZmlyc3RfeWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImRvcHJvdF9ldSJdIDwtIDIwMDkNCmViX3Jlc3VsdHNfZGYkZmlyc3RfeWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImRvcHJvdF9yZWdpb24iXSA8LSAyMDA5DQplYl9yZXN1bHRzX2RmJGZpcnN0X3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJkb3Byb3RfY29tcCJdIDwtIDIwMDkNCmViX3Jlc3VsdHNfZGYkZmlyc3RfeWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImRvcHJvdF9jaXRpeiJdIDwtIDIwMDkNCmViX3Jlc3VsdHNfZGYkZmlyc3RfeWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImRvcHJvdF9jaXR5Il0gPC0gMjAxNA0KZWJfcmVzdWx0c19kZiRmaXJzdF95ZWFyW2ViX3Jlc3VsdHNfZGYkZGVwX3ZhciA9PSAiZWZmX2RhaWx5Il0gPC0gMjAwNw0KZWJfcmVzdWx0c19kZiRmaXJzdF95ZWFyW2ViX3Jlc3VsdHNfZGYkZGVwX3ZhciA9PSAicGVyc19pbXAiXSA8LSAyMDA5DQplYl9yZXN1bHRzX2RmJGZpcnN0X3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJlbnZfcXVhbGxpZmUiXSA8LSAyMDA0DQplYl9yZXN1bHRzX2RmJGZpcnN0X3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJwcnNhY3Rpb24iXSA8LSAyMDExDQoNCiMgQW5kIHRoZSBhdmVyYWdlIHllYXIgDQplYl9yZXN1bHRzX2RmJG1lYW5feWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gInJvbGVfaW5kIl0gPC0gMjAxMg0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJiaWdfcG9sIl0gPC0gMjAxMg0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJjY191bnN0b3AiXSA8LSAyMDA4DQplYl9yZXN1bHRzX2RmJG1lYW5feWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImNjX2V4YWciXSA8LSAyMDA4DQplYl9yZXN1bHRzX2RmJG1lYW5feWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImNjX3Bvc2V1Il0gPC0gMjAwOA0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJjY19wcnNhY3QiXSA8LSAyMDA4DQplYl9yZXN1bHRzX2RmJG1lYW5feWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImNjX3Bvc2V1Il0gPC0gMjAwOA0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJjY3BlcmNlcHQiXSA8LSAyMDE0DQplYl9yZXN1bHRzX2RmJG1lYW5feWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImNjaGFuZ2UiXSA8LSAyMDE1DQplYl9yZXN1bHRzX2RmJG1lYW5feWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImNjaGFuZ2UyIl0gPC0gMjAxNQ0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJjY2hhbmdldG90Il0gPC0gMjAxNQ0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJlbnZwX2VnIl0gPC0gMjAxMw0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJlZmZyX2VnIl0gPC0gMjAxMw0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJidXlwcm9kIl0gPC0gMjAxMA0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJkb3Byb3RfbmF0Z292Il0gPC0gMjAxMw0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJkb3Byb3RfZXUiXSA8LSAyMDEzDQplYl9yZXN1bHRzX2RmJG1lYW5feWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImRvcHJvdF9yZWdpb24iXSA8LSAyMDEzDQplYl9yZXN1bHRzX2RmJG1lYW5feWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImRvcHJvdF9jb21wIl0gPC0gMjAxMw0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJkb3Byb3RfY2l0aXoiXSA8LSAyMDEzDQplYl9yZXN1bHRzX2RmJG1lYW5feWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gImRvcHJvdF9jaXR5Il0gPC0gMjAxNQ0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJlZmZfZGFpbHkiXSA8LSAyMDEyDQplYl9yZXN1bHRzX2RmJG1lYW5feWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gInBlcnNfaW1wIl0gPC0gMjAwOQ0KZWJfcmVzdWx0c19kZiRtZWFuX3llYXJbZWJfcmVzdWx0c19kZiRkZXBfdmFyID09ICJlbnZfcXVhbGxpZmUiXSA8LSAyMDA5DQplYl9yZXN1bHRzX2RmJG1lYW5feWVhcltlYl9yZXN1bHRzX2RmJGRlcF92YXIgPT0gInByc2FjdGlvbiJdIDwtIDIwMTQNCg0Kc2F2ZShlYl9yZXN1bHRzX2RmLCBmaWxlPSAiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2ViX3Jlc3VsdHNfZGZfd2F2ZXNfdG90YWxfbmV3LlJEYXRhIiApDQpgYGANCg0KDQpgYGB7cn0NCiMgVGhlIHNhbWUgbmVlZHMgdG8gYmUgZG9uZSBmb3IgRVZTLCBJJk8gYW5kIElTU1ANCiMgRVZTDQpybShsaXN0PWxzKCkpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZXZzX3Jlc3VsdHNfZGYxX25ldy5SRGF0YSIpDQpldnNfMV9kZiA8LSBldnNfcmVzdWx0c19kZg0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2V2c19yZXN1bHRzX2RmMl9uZXcuUkRhdGEiKQ0KZXZzXzJfZGYgPC0gZXZzX3Jlc3VsdHNfZGYNCg0KZXZzX3Jlc3VsdHNfZGZfd2F2ZXMgPC0gcmJpbmQgKGV2c18xX2RmLCBldnNfMl9kZikNCmV2c19yZXN1bHRzX2RmX3dhdmVzJGRlcF92YXJfd2F2ZSA8LSBwYXN0ZShldnNfcmVzdWx0c19kZl93YXZlcyRkZXBfdmFyLCBldnNfcmVzdWx0c19kZl93YXZlcyR3YXZlc2V0LCBzZXAgPSAiXyIpDQoNCnNhdmUoZXZzX3Jlc3VsdHNfZGZfd2F2ZXMsIGZpbGU9ICIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvZXZzX3Jlc3VsdHNfZGZfd2F2ZXNfbmV3LlJEYXRhIiApDQoNCiMgSSZPDQpybShsaXN0PWxzKCkpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvaW9fcmVzdWx0c19kZjFfbmV3LlJEYXRhIikNCmlvXzFfZGYgPC0gaW9fcmVzdWx0c19kZg0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2lvX3Jlc3VsdHNfZGYyX25ldy5SRGF0YSIpDQppb18yX2RmIDwtIGlvX3Jlc3VsdHNfZGYNCg0KaW9fcmVzdWx0c19kZl93YXZlcyA8LSByYmluZCAoaW9fMV9kZiwgaW9fMl9kZikNCmlvX3Jlc3VsdHNfZGZfd2F2ZXMkZGVwX3Zhcl93YXZlIDwtIHBhc3RlKGlvX3Jlc3VsdHNfZGZfd2F2ZXMkZGVwX3ZhciwgaW9fcmVzdWx0c19kZl93YXZlcyR3YXZlc2V0LCBzZXAgPSAiXyIpDQoNCnNhdmUoaW9fcmVzdWx0c19kZl93YXZlcywgZmlsZT0gIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9pb19yZXN1bHRzX2RmX3dhdmVzX25ldy5SRGF0YSIgKQ0KDQojIEFuZCBJU1NQDQpybShsaXN0PWxzKCkpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvaXNzcF9yZXN1bHRzX2RmMV9uZXcuUkRhdGEiKQ0KaXNzcF8xX2RmIDwtIGlzc3BfcmVzdWx0c19kZg0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2lzc3BfcmVzdWx0c19kZjJfbmV3LlJEYXRhIikNCmlzc3BfMl9kZiA8LSBpc3NwX3Jlc3VsdHNfZGYNCg0KaXNzcF9yZXN1bHRzX2RmX3dhdmVzIDwtIHJiaW5kIChpc3NwXzFfZGYsIGlzc3BfMl9kZikNCmlzc3BfcmVzdWx0c19kZl93YXZlcyRkZXBfdmFyX3dhdmUgPC0gcGFzdGUoaXNzcF9yZXN1bHRzX2RmX3dhdmVzJGRlcF92YXIsIGlzc3BfcmVzdWx0c19kZl93YXZlcyR3YXZlc2V0LCBzZXAgPSAiXyIpDQoNCnNhdmUoaXNzcF9yZXN1bHRzX2RmX3dhdmVzLCBmaWxlPSAiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2lzc3BfcmVzdWx0c19kZl93YXZlc19uZXcuUkRhdGEiICkNCg0KIyBTT0NPTg0Kcm0obGlzdD1scygpKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL3NvY29uX3Jlc3VsdHNfZGYxX25ldy5SRGF0YSIpDQpzb2Nvbl8xX2RmIDwtIHNvY29uX3Jlc3VsdHNfZGYNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9zb2Nvbl9yZXN1bHRzX2RmMl9uZXcuUkRhdGEiKQ0Kc29jb25fMl9kZiA8LSBzb2Nvbl9yZXN1bHRzX2RmDQoNCnNvY29uX3Jlc3VsdHNfZGZfd2F2ZXMgPC0gcmJpbmQgKHNvY29uXzFfZGYsIHNvY29uXzJfZGYpDQpzb2Nvbl9yZXN1bHRzX2RmX3dhdmVzJGRlcF92YXJfd2F2ZSA8LSBwYXN0ZShzb2Nvbl9yZXN1bHRzX2RmX3dhdmVzJGRlcF92YXIsIHNvY29uX3Jlc3VsdHNfZGZfd2F2ZXMkd2F2ZXNldCwgc2VwID0gIl8iKQ0KDQpzYXZlKHNvY29uX3Jlc3VsdHNfZGZfd2F2ZXMsIGZpbGU9ICIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvc29jb25fcmVzdWx0c19kZl93YXZlc19uZXcuUkRhdGEiICkNCg0KIyBMSVNTDQpybShsaXN0PWxzKCkpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvbGlzc19yZXN1bHRzX2RmMV9uZXcuUkRhdGEiKQ0KbGlzc18xX2RmIDwtIGxpc3NfcmVzdWx0c19kZg0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2xpc3NfcmVzdWx0c19kZjJfbmV3LlJEYXRhIikNCmxpc3NfMl9kZiA8LSBsaXNzX3Jlc3VsdHNfZGYNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9saXNzX3Jlc3VsdHNfZGYzX25ldy5SRGF0YSIpDQpsaXNzXzNfZGYgPC0gbGlzc19yZXN1bHRzX2RmDQoNCmxpc3NfcmVzdWx0c19kZl93YXZlcyA8LSByYmluZCAobGlzc18xX2RmLCBsaXNzXzJfZGYsIGxpc3NfM19kZikNCmxpc3NfcmVzdWx0c19kZl93YXZlcyRkZXBfdmFyX3dhdmUgPC0gcGFzdGUobGlzc19yZXN1bHRzX2RmX3dhdmVzJGRlcF92YXIsIGxpc3NfcmVzdWx0c19kZl93YXZlcyR3YXZlc2V0LCBzZXAgPSAiXyIpDQoNCnNhdmUobGlzc19yZXN1bHRzX2RmX3dhdmVzLCBmaWxlPSAiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2xpc3NfcmVzdWx0c19kZl93YXZlc19uZXcuUkRhdGEiICkNCg0KYGBgDQoNCg0KYGBge3J9DQojIFRoZSBmaW5hbCBzdGVwIGlzIHRvIG1lcmdlIGFsbCByZXN1bHRzIGludG8gb25lIGRhdGFmcmFtZQ0Kcm0obGlzdD1scygpKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2Vzc19yZXN1bHRzX2RmX3dfbmV3LlJEYXRhIikNCmVzc19yZXN1bHRzX2RmJHdhdmVzZXQgPC0gMQ0KZXNzX3Jlc3VsdHNfZGYkZGVwX3Zhcl93YXZlIDwtIHBhc3RlKGVzc19yZXN1bHRzX2RmJGRlcF92YXIsIGVzc19yZXN1bHRzX2RmJHdhdmVzZXQsIHNlcCA9ICJfIikNCg0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL2lzc3BfcmVzdWx0c18yX2RmX25ldy5SRGF0YSIpDQoNCmlzc3BfcmVzdWx0c18yX2RmJG1lYW5feWVhciA8LSAyMDA1DQppc3NwX3Jlc3VsdHNfMl9kZiR3YXZlc2V0IDwtIDENCmlzc3BfcmVzdWx0c18yX2RmJGRlcF92YXJfd2F2ZSA8LSBwYXN0ZShpc3NwX3Jlc3VsdHNfMl9kZiRkZXBfdmFyLCBpc3NwX3Jlc3VsdHNfMl9kZiR3YXZlc2V0LCBzZXAgPSAiXyIpDQoNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9tb3RfcmVzdWx0c19kZl93X25ldy5SRGF0YSIpDQptb3RfcmVzdWx0c19kZiR3YXZlc2V0IDwtIDENCm1vdF9yZXN1bHRzX2RmJGRlcF92YXJfd2F2ZSA8LSBwYXN0ZShtb3RfcmVzdWx0c19kZiRkZXBfdmFyLCBtb3RfcmVzdWx0c19kZiR3YXZlc2V0LCBzZXAgPSAiXyIpDQoNCg0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2V2c19yZXN1bHRzX2RmX3dhdmVzX25ldy5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvaW9fcmVzdWx0c19kZl93YXZlc19uZXcuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2lzc3BfcmVzdWx0c19kZl93YXZlc19uZXcuUkRhdGEiKQ0KbG9hZCgiLi9kYXRhL2ZpbmFsX2RhdGEvcmVncmVzc2lvbl9vdXRwdXRzL3Blcl93YXZlL2ViX3Jlc3VsdHNfZGZfd2F2ZXNfdG90YWxfbmV3LlJEYXRhIikNCmxvYWQoIi4vZGF0YS9maW5hbF9kYXRhL3JlZ3Jlc3Npb25fb3V0cHV0cy9wZXJfd2F2ZS9zb2Nvbl9yZXN1bHRzX2RmX3dhdmVzX25ldy5SRGF0YSIpDQpsb2FkKCIuL2RhdGEvZmluYWxfZGF0YS9yZWdyZXNzaW9uX291dHB1dHMvcGVyX3dhdmUvbGlzc19yZXN1bHRzX2RmX3dhdmVzX25ldy5SRGF0YSIpDQoNCnRvdGFsX3Jlc3VsdHNfd2F2ZXMgPC0gcmJpbmQoZWJfcmVzdWx0c19kZiwgZXNzX3Jlc3VsdHNfZGYsIGV2c19yZXN1bHRzX2RmX3dhdmVzLCBpb19yZXN1bHRzX2RmX3dhdmVzLCBpc3NwX3Jlc3VsdHNfZGZfd2F2ZXMsIGlzc3BfcmVzdWx0c18yX2RmLCBtb3RfcmVzdWx0c19kZiwgc29jb25fcmVzdWx0c19kZl93YXZlcywgbGlzc19yZXN1bHRzX2RmX3dhdmVzKSANCg0Kc2F2ZSh0b3RhbF9yZXN1bHRzX3dhdmVzLCBmaWxlPSAiLi9kYXRhL21ldGFfYW5hbHlzaXMvdG90YWxfcmVzdWx0c193YXZlc19uZXcuUkRhdGEiICkNCmBgYA0KDQpgYGB7cn0NCiMgSSBhbHNvIHdhbnQgdG8gYWRkIGEgdmFyaWFibGUgdGhhdCBkZXNjcmliZXMgd2hldGhlciB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIGlzIG1vc3RseSBvZiBhZmZlY3RpdmUsIGJlaGF2aW9yYWwgb3IgY29nbml0aXZlIG5hdHVyZSANCg0KIyAyIHZhcmlhYmxlcyB0aGF0IGFyZSBjYWxsZWQgd29ycnksIG5vdCBoYW5keQ0KdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyW3RvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAid29ycnkiICYgdG90YWxfcmVzdWx0c193YXZlcyRkYXRhID09ICJJU1NQIl0gPC0gIndvcnJ5X2lzc3AiDQoNCiMgQ2F0ZWdvcnkNCnRvdGFsX3Jlc3VsdHNfd2F2ZXMkYXR0aXR1ZGVfY2F0W3RvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiZG9kaWZmIiANCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAicGVyc19yZXNwIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJ3b3JyeSINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAid29ycmllZCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAid29ycnlfZnV0dXJlIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJmcm9udHJ1bm5lciINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAibWluX2NvbnRyIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJ3b3JyaWVkX21vdCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiZnV0dXJlZ2VuIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJub3dvciINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAibW90aXYiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImZ1dF9nZW5fc29jb24iDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gInBlcnNfcmVzcF9tb3QiXSA8LSAiYWZmZWN0aXZlIg0KDQp0b3RhbF9yZXN1bHRzX3dhdmVzJGF0dGl0dWRlX2NhdFt0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gIndpbGxpbmdfcHJpY2UiIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJ3aWxsaW5nX3RheCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAid2lsbGluZ19saXZpbmciDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImRvX3JpZ2h0Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJwZW9wbGVfZGVjaWRlIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJjbGltYXRlNSINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAicHJzYWN0aW9uIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJjY19wcnNhY3QiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImJ1eXByb2QiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJzdXN0X2Nob2ljZSINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImVuZXJneSINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImxpZmVzdHlsZSJdIDwtICJiZWhhdmlvcmFsIg0KDQp0b3RhbF9yZXN1bHRzX3dhdmVzJGF0dGl0dWRlX2NhdFt0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gIndvcnJ5X2lzc3AiIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJsaWZlaGFybSINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAicHJvZ2hhcm0iDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImVjb25wcm90ZWN0Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJncm93aGFybSINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiYnVzX2RlY2lkZSINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAibW9yZWltcCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAib3RoZXJzYW1lIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJleGFnIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJjb3VudHJ5X2VmZm9ydCIgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImNhdXNlIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJyZXNwX2NpdGl6Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJka19zdGFydCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiZG9fZ292Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJidXNzX2hlbHAiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImh1bWFuX3Jlc3AiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImVudl9lY19zdGF0Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJlbnZfcHJzaW1wIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiZW52cF9lZyINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiZWZmcl9lZyINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiY2NoYW5nZSINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiY2NoYW5nZTIiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImNjaGFuZ2V0b3QiIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJjY3BlcmNlcHQiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImVudl9xdWFsbGlmZSINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiZG9wcm90X2NvbXAiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImRvcHJvdF9yZWdpb24iDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImRvcHJvdF9uYXRnb3YiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImRvcHJvdF9jaXR5Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJkb3Byb3RfY2l0aXoiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImRvcHJvdF9ldSINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJjY191bnN0b3AiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImNjX2V4YWciDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImNjX3Bvc2V1Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJyb2xlX2luZCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiYmlnX3BvbCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiZWZmX2RhaWx5Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJwZXJzX2ltcCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJjY2hhbmdlX21vdCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJvbnRpbWUiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiZ292Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gInJlc3BfZ292Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gInJlc3BfY29tcCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJyZXNwX21rYiINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJyZXNwX2NpdGl6X21vdCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJyZXNwX3lvdSINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJjb250ciINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJub2lkZWEiXSA8LSAiY29nbml0aXZlIg0KDQojQ3JlYXRlIGEgdmFyaWFibGUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgZGVwZW5kZW50IHZhcmlhYmxlIGNhbiBiZSBpbnRlcnByZXRlZCBpbiAyIHdheXMgKGFtYmlndW91cykNCg0KdG90YWxfcmVzdWx0c193YXZlcyRhbWJpZ3VvdXNbdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyICE9ICJkb2RpZmYiIA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyICE9ICJmcm9udHJ1bm5lciINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciAhPSAibWluX2NvbnRyIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyICE9ICJwZW9wbGVfZGVjaWRlIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyICE9ICJlY29ucHJvdGVjdCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciAhPSAiZ3Jvd2hhcm0iDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgIT0gImJ1c19kZWNpZGUiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgIT0gIm90aGVyc2FtZSINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciAhPSAicmVzcF9jaXRpeiINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciAhPSAiZGtfc3RhcnQiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgIT0gImJ1c3NfaGVscCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciAhPSAiZW52cF9lZyINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciAhPSAiZWZmcl9lZyINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciAhPSAiZW52X3F1YWxsaWZlIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyICE9ICJjY191bnN0b3AiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgIT0gImNjX3Bvc2V1Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyICE9ICJiaWdfcG9sIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJub2lkZWEiXSA8LSAiTm8iDQp0b3RhbF9yZXN1bHRzX3dhdmVzJGFtYmlndW91c1t0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImRvZGlmZiIgDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImZyb250cnVubmVyIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJtaW5fY29udHIiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gInBlb3BsZV9kZWNpZGUiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImVjb25wcm90ZWN0Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJncm93aGFybSINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiYnVzX2RlY2lkZSINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAib3RoZXJzYW1lIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJyZXNwX2NpdGl6Ig0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJka19zdGFydCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiYnVzc19oZWxwIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJlbnZwX2VnIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJlZmZyX2VnIg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgdG90YWxfcmVzdWx0c193YXZlcyRkZXBfdmFyID09ICJlbnZfcXVhbGxpZmUiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImNjX3Vuc3RvcCINCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGVwX3ZhciA9PSAiY2NfcG9zZXUiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gImJpZ19wb2wiDQogICAgICAgICAgICAgICAgICAgICAgICAgICAgfCB0b3RhbF9yZXN1bHRzX3dhdmVzJGRlcF92YXIgPT0gIm5vaWRlYSJdIDwtICJZZXMiDQoNCiMgSSBhbHNvIHdhbnQgYW4gaW5kaWNhdG9yIGZvciB3aGV0aGVyIGl0IGlzIGEgbmF0aW9uYWwgb3IgaW50ZXJuYXRpb25hbCBkYXRhc2V0LiANCnRvdGFsX3Jlc3VsdHNfd2F2ZXMkbmF0aW9uYWxbdG90YWxfcmVzdWx0c193YXZlcyRkYXRhID09ICJJTyJ8DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGF0YSA9PSAiTU9UIiB8DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsX3Jlc3VsdHNfd2F2ZXMkZGF0YSA9PSAiTElTUyIgfA0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbF9yZXN1bHRzX3dhdmVzJGRhdGEgPT0gIlNPQ09OIl0gPC0gMQ0KdG90YWxfcmVzdWx0c193YXZlcyRuYXRpb25hbFt0b3RhbF9yZXN1bHRzX3dhdmVzJGRhdGEgPT0gIkVCInwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxfcmVzdWx0c193YXZlcyRkYXRhID09ICJFU1MiIHwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxfcmVzdWx0c193YXZlcyRkYXRhID09ICJFVlMiIHwNCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxfcmVzdWx0c193YXZlcyRkYXRhID09ICJJU1NQIl0gPC0gMA0KDQojIEkgYWxzbyBjYWxjdWxhdGVkIHRoZSBwZXJjZW50YWdlIG9mIG1pc3NpbmdzIHBlciB2YXJpYWJsZSwgaW4gaG93IG1hbnkgd2F2ZXMgaXQgd2FzIGFza2VkIGFuZCBob3cgbWFueSBjYXRlZ29yaWVzIHRoZSBvcmlnaW5hbCBzY2FsZSBoYWQuIEkgY29sbGVjdGVkIHRoZXNlIGRhdGEgaW4gRXhjZWwuDQptZXRhdmFyIDwtIHJlYWR4bDo6cmVhZF9leGNlbCgiLi9kYXRhL21ldGFfdmFyLnhsc3giKQ0KdG90YWxfcmVzdWx0c193YXZlcyA8LSBtZXJnZSh0b3RhbF9yZXN1bHRzX3dhdmVzLCBtZXRhdmFyKQ0KDQpzYXZlKHRvdGFsX3Jlc3VsdHNfd2F2ZXMsIGZpbGU9ICIuL2RhdGEvbWV0YV9hbmFseXNpcy90b3RhbF9yZXN1bHRzX3dhdmVzX25ldy5SRGF0YSIgKQ0KYGBgDQoNCg==</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("regression_to_meta_analysis_wg_waves_new.Rmd");
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
